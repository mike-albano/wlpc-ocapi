# -*- coding: utf-8 -*-
from operator import attrgetter
from pyangbind.lib.yangtypes import RestrictedPrecisionDecimalType
from pyangbind.lib.yangtypes import RestrictedClassType
from pyangbind.lib.yangtypes import TypedListType
from pyangbind.lib.yangtypes import YANGBool
from pyangbind.lib.yangtypes import YANGListType
from pyangbind.lib.yangtypes import YANGDynClass
from pyangbind.lib.yangtypes import ReferenceType
from pyangbind.lib.base import PybindBase
from collections import OrderedDict
from decimal import Decimal
from bitarray import bitarray
import six

# PY3 support of some PY2 keywords (needs improved)
if six.PY3:
  import builtins as __builtin__
  long = int
elif six.PY2:
  import __builtin__

class yc_config_openconfig_access_points__access_points_access_point_radios_radio_config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-access-points - based on the path /access-points/access-point/radios/radio/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configurable items at the global, radio interface
level
  """
  __slots__ = ('_path_helper', '_extmethods', '__id','__operating_frequency','__enabled','__transmit_power','__channel','__channel_width','__dca','__allowed_channels','__dtp','__dtp_min','__dtp_max','__antenna_gain','__scanning','__scanning_interval','__scanning_dwell_time','__scanning_defer_clients','__scanning_defer_traffic',)

  _yang_name = 'config'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__operating_frequency = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'oc-wifi-types:FREQ_2GHZ': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:FREQ_5GHZ': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:FREQ_2_5_GHZ': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'FREQ_5GHZ': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'FREQ_2_5_GHZ': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'FREQ_2GHZ': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}},), is_leaf=True, yang_name="operating-frequency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='identityref', is_config=True)
    self.__dtp = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="dtp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=True)
    self.__channel_width = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="channel-width", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint8', is_config=True)
    self.__antenna_gain = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['-128..127']}, int_size=8), is_leaf=True, yang_name="antenna-gain", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='int8', is_config=True)
    self.__scanning = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="scanning", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=True)
    self.__enabled = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=True)
    self.__dca = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="dca", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=True)
    self.__scanning_defer_clients = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="scanning-defer-clients", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint8', is_config=True)
    self.__transmit_power = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="transmit-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint8', is_config=True)
    self.__scanning_interval = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="scanning-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint8', is_config=True)
    self.__scanning_dwell_time = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="scanning-dwell-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint16', is_config=True)
    self.__dtp_max = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(15), is_leaf=True, yang_name="dtp-max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint8', is_config=True)
    self.__dtp_min = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(3), is_leaf=True, yang_name="dtp-min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint8', is_config=True)
    self.__allowed_channels = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={u'range': [u'1..14', u'36', u'40', u'44', u'48', u'52', u'56', u'60', u'64', u'100', u'104', u'108', u'112', u'116', u'120', u'124', u'128', u'132', u'136', u'140', u'144', u'149', u'153', u'157', u'161', u'165']})), is_leaf=False, yang_name="allowed-channels", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-wifi-types:channels-type', is_config=True)
    self.__scanning_defer_traffic = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="scanning-defer-traffic", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=True)
    self.__id = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint8', is_config=True)
    self.__channel = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={u'range': [u'1..165']}), is_leaf=True, yang_name="channel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint8', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'access-points', u'access-point', u'radios', u'radio', u'config']

  def _get_id(self):
    """
    Getter method for id, mapped from YANG variable /access_points/access_point/radios/radio/config/id (uint8)

    YANG Description: Unique ID of the radio.
    """
    return self.__id
      
  def _set_id(self, v, load=False):
    """
    Setter method for id, mapped from YANG variable /access_points/access_point/radios/radio/config/id (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: Unique ID of the radio.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """id must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint8', is_config=True)""",
        })

    self.__id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_id(self):
    self.__id = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint8', is_config=True)


  def _get_operating_frequency(self):
    """
    Getter method for operating_frequency, mapped from YANG variable /access_points/access_point/radios/radio/config/operating_frequency (identityref)

    YANG Description: Operating frequency of this radio.
    """
    return self.__operating_frequency
      
  def _set_operating_frequency(self, v, load=False):
    """
    Setter method for operating_frequency, mapped from YANG variable /access_points/access_point/radios/radio/config/operating_frequency (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_operating_frequency is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_operating_frequency() directly.

    YANG Description: Operating frequency of this radio.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'oc-wifi-types:FREQ_2GHZ': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:FREQ_5GHZ': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:FREQ_2_5_GHZ': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'FREQ_5GHZ': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'FREQ_2_5_GHZ': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'FREQ_2GHZ': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}},), is_leaf=True, yang_name="operating-frequency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='identityref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """operating_frequency must be of a type compatible with identityref""",
          'defined-type': "openconfig-access-points:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'oc-wifi-types:FREQ_2GHZ': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:FREQ_5GHZ': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:FREQ_2_5_GHZ': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'FREQ_5GHZ': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'FREQ_2_5_GHZ': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'FREQ_2GHZ': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}},), is_leaf=True, yang_name="operating-frequency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='identityref', is_config=True)""",
        })

    self.__operating_frequency = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_operating_frequency(self):
    self.__operating_frequency = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'oc-wifi-types:FREQ_2GHZ': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:FREQ_5GHZ': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:FREQ_2_5_GHZ': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'FREQ_5GHZ': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'FREQ_2_5_GHZ': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'FREQ_2GHZ': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}},), is_leaf=True, yang_name="operating-frequency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='identityref', is_config=True)


  def _get_enabled(self):
    """
    Getter method for enabled, mapped from YANG variable /access_points/access_point/radios/radio/config/enabled (boolean)

    YANG Description: The desired operational state (up/down) of this radio interface.
    """
    return self.__enabled
      
  def _set_enabled(self, v, load=False):
    """
    Setter method for enabled, mapped from YANG variable /access_points/access_point/radios/radio/config/enabled (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_enabled is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_enabled() directly.

    YANG Description: The desired operational state (up/down) of this radio interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """enabled must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=True)""",
        })

    self.__enabled = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_enabled(self):
    self.__enabled = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=True)


  def _get_transmit_power(self):
    """
    Getter method for transmit_power, mapped from YANG variable /access_points/access_point/radios/radio/config/transmit_power (uint8)

    YANG Description: Transmit power of the radio, in dBm.
    """
    return self.__transmit_power
      
  def _set_transmit_power(self, v, load=False):
    """
    Setter method for transmit_power, mapped from YANG variable /access_points/access_point/radios/radio/config/transmit_power (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_transmit_power is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_transmit_power() directly.

    YANG Description: Transmit power of the radio, in dBm.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="transmit-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """transmit_power must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="transmit-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint8', is_config=True)""",
        })

    self.__transmit_power = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_transmit_power(self):
    self.__transmit_power = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="transmit-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint8', is_config=True)


  def _get_channel(self):
    """
    Getter method for channel, mapped from YANG variable /access_points/access_point/radios/radio/config/channel (uint8)

    YANG Description: Operating channel of this radio. If using channel-bonding this
will represent the Primary 20MHz channel of the 40,80,160MHz channel.
    """
    return self.__channel
      
  def _set_channel(self, v, load=False):
    """
    Setter method for channel, mapped from YANG variable /access_points/access_point/radios/radio/config/channel (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_channel is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_channel() directly.

    YANG Description: Operating channel of this radio. If using channel-bonding this
will represent the Primary 20MHz channel of the 40,80,160MHz channel.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={u'range': [u'1..165']}), is_leaf=True, yang_name="channel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """channel must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={u'range': [u'1..165']}), is_leaf=True, yang_name="channel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint8', is_config=True)""",
        })

    self.__channel = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_channel(self):
    self.__channel = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={u'range': [u'1..165']}), is_leaf=True, yang_name="channel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint8', is_config=True)


  def _get_channel_width(self):
    """
    Getter method for channel_width, mapped from YANG variable /access_points/access_point/radios/radio/config/channel_width (uint8)

    YANG Description: Operating channel-width of this radio.
    """
    return self.__channel_width
      
  def _set_channel_width(self, v, load=False):
    """
    Setter method for channel_width, mapped from YANG variable /access_points/access_point/radios/radio/config/channel_width (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_channel_width is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_channel_width() directly.

    YANG Description: Operating channel-width of this radio.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="channel-width", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """channel_width must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="channel-width", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint8', is_config=True)""",
        })

    self.__channel_width = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_channel_width(self):
    self.__channel_width = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="channel-width", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint8', is_config=True)


  def _get_dca(self):
    """
    Getter method for dca, mapped from YANG variable /access_points/access_point/radios/radio/config/dca (boolean)

    YANG Description: Utilize Dynamic Channel Assignment on this Radio.
    """
    return self.__dca
      
  def _set_dca(self, v, load=False):
    """
    Setter method for dca, mapped from YANG variable /access_points/access_point/radios/radio/config/dca (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dca is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dca() directly.

    YANG Description: Utilize Dynamic Channel Assignment on this Radio.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="dca", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dca must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="dca", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=True)""",
        })

    self.__dca = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dca(self):
    self.__dca = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="dca", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=True)


  def _get_allowed_channels(self):
    """
    Getter method for allowed_channels, mapped from YANG variable /access_points/access_point/radios/radio/config/allowed_channels (oc-wifi-types:channels-type)

    YANG Description: Allowed channel list for this Radio to utilize.
    """
    return self.__allowed_channels
      
  def _set_allowed_channels(self, v, load=False):
    """
    Setter method for allowed_channels, mapped from YANG variable /access_points/access_point/radios/radio/config/allowed_channels (oc-wifi-types:channels-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_allowed_channels is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_allowed_channels() directly.

    YANG Description: Allowed channel list for this Radio to utilize.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={u'range': [u'1..14', u'36', u'40', u'44', u'48', u'52', u'56', u'60', u'64', u'100', u'104', u'108', u'112', u'116', u'120', u'124', u'128', u'132', u'136', u'140', u'144', u'149', u'153', u'157', u'161', u'165']})), is_leaf=False, yang_name="allowed-channels", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-wifi-types:channels-type', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """allowed_channels must be of a type compatible with oc-wifi-types:channels-type""",
          'defined-type': "oc-wifi-types:channels-type",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={u'range': [u'1..14', u'36', u'40', u'44', u'48', u'52', u'56', u'60', u'64', u'100', u'104', u'108', u'112', u'116', u'120', u'124', u'128', u'132', u'136', u'140', u'144', u'149', u'153', u'157', u'161', u'165']})), is_leaf=False, yang_name="allowed-channels", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-wifi-types:channels-type', is_config=True)""",
        })

    self.__allowed_channels = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_allowed_channels(self):
    self.__allowed_channels = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={u'range': [u'1..14', u'36', u'40', u'44', u'48', u'52', u'56', u'60', u'64', u'100', u'104', u'108', u'112', u'116', u'120', u'124', u'128', u'132', u'136', u'140', u'144', u'149', u'153', u'157', u'161', u'165']})), is_leaf=False, yang_name="allowed-channels", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-wifi-types:channels-type', is_config=True)


  def _get_dtp(self):
    """
    Getter method for dtp, mapped from YANG variable /access_points/access_point/radios/radio/config/dtp (boolean)

    YANG Description: Utilize dynamic transmit-power on this Radio.
    """
    return self.__dtp
      
  def _set_dtp(self, v, load=False):
    """
    Setter method for dtp, mapped from YANG variable /access_points/access_point/radios/radio/config/dtp (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dtp is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dtp() directly.

    YANG Description: Utilize dynamic transmit-power on this Radio.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="dtp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dtp must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="dtp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=True)""",
        })

    self.__dtp = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dtp(self):
    self.__dtp = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="dtp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=True)


  def _get_dtp_min(self):
    """
    Getter method for dtp_min, mapped from YANG variable /access_points/access_point/radios/radio/config/dtp_min (uint8)

    YANG Description: Minimum allowed transmit-power on this radio, if utilizing dtp.
Expressed in dBm.
    """
    return self.__dtp_min
      
  def _set_dtp_min(self, v, load=False):
    """
    Setter method for dtp_min, mapped from YANG variable /access_points/access_point/radios/radio/config/dtp_min (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dtp_min is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dtp_min() directly.

    YANG Description: Minimum allowed transmit-power on this radio, if utilizing dtp.
Expressed in dBm.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(3), is_leaf=True, yang_name="dtp-min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dtp_min must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(3), is_leaf=True, yang_name="dtp-min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint8', is_config=True)""",
        })

    self.__dtp_min = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dtp_min(self):
    self.__dtp_min = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(3), is_leaf=True, yang_name="dtp-min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint8', is_config=True)


  def _get_dtp_max(self):
    """
    Getter method for dtp_max, mapped from YANG variable /access_points/access_point/radios/radio/config/dtp_max (uint8)

    YANG Description: Maximum allowed transmit-power on this radio, if utilizing dtp.
Expressed in dBm.
    """
    return self.__dtp_max
      
  def _set_dtp_max(self, v, load=False):
    """
    Setter method for dtp_max, mapped from YANG variable /access_points/access_point/radios/radio/config/dtp_max (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dtp_max is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dtp_max() directly.

    YANG Description: Maximum allowed transmit-power on this radio, if utilizing dtp.
Expressed in dBm.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(15), is_leaf=True, yang_name="dtp-max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dtp_max must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(15), is_leaf=True, yang_name="dtp-max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint8', is_config=True)""",
        })

    self.__dtp_max = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dtp_max(self):
    self.__dtp_max = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(15), is_leaf=True, yang_name="dtp-max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint8', is_config=True)


  def _get_antenna_gain(self):
    """
    Getter method for antenna_gain, mapped from YANG variable /access_points/access_point/radios/radio/config/antenna_gain (int8)

    YANG Description: Antenna gain applied to this Radio; typically used when
external antennae connected.
    """
    return self.__antenna_gain
      
  def _set_antenna_gain(self, v, load=False):
    """
    Setter method for antenna_gain, mapped from YANG variable /access_points/access_point/radios/radio/config/antenna_gain (int8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_antenna_gain is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_antenna_gain() directly.

    YANG Description: Antenna gain applied to this Radio; typically used when
external antennae connected.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['-128..127']}, int_size=8), is_leaf=True, yang_name="antenna-gain", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='int8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """antenna_gain must be of a type compatible with int8""",
          'defined-type': "int8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['-128..127']}, int_size=8), is_leaf=True, yang_name="antenna-gain", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='int8', is_config=True)""",
        })

    self.__antenna_gain = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_antenna_gain(self):
    self.__antenna_gain = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['-128..127']}, int_size=8), is_leaf=True, yang_name="antenna-gain", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='int8', is_config=True)


  def _get_scanning(self):
    """
    Getter method for scanning, mapped from YANG variable /access_points/access_point/radios/radio/config/scanning (boolean)

    YANG Description: Whether the radio will perform off-channel scanning, to collect
neighboring RF information.
    """
    return self.__scanning
      
  def _set_scanning(self, v, load=False):
    """
    Setter method for scanning, mapped from YANG variable /access_points/access_point/radios/radio/config/scanning (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_scanning is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_scanning() directly.

    YANG Description: Whether the radio will perform off-channel scanning, to collect
neighboring RF information.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="scanning", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """scanning must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="scanning", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=True)""",
        })

    self.__scanning = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_scanning(self):
    self.__scanning = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="scanning", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=True)


  def _get_scanning_interval(self):
    """
    Getter method for scanning_interval, mapped from YANG variable /access_points/access_point/radios/radio/config/scanning_interval (uint8)

    YANG Description: How often, in seconds, the radio will go off-channel to perform
scanning.
    """
    return self.__scanning_interval
      
  def _set_scanning_interval(self, v, load=False):
    """
    Setter method for scanning_interval, mapped from YANG variable /access_points/access_point/radios/radio/config/scanning_interval (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_scanning_interval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_scanning_interval() directly.

    YANG Description: How often, in seconds, the radio will go off-channel to perform
scanning.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="scanning-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """scanning_interval must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="scanning-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint8', is_config=True)""",
        })

    self.__scanning_interval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_scanning_interval(self):
    self.__scanning_interval = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="scanning-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint8', is_config=True)


  def _get_scanning_dwell_time(self):
    """
    Getter method for scanning_dwell_time, mapped from YANG variable /access_points/access_point/radios/radio/config/scanning_dwell_time (uint16)

    YANG Description: Amount of time, in milliseconds, the radio will spend on a
channel during scanning-interval. If a Monitor-mode Radio, it will
cycle through scanning-allowed-channels spending this amount of time
on each.
    """
    return self.__scanning_dwell_time
      
  def _set_scanning_dwell_time(self, v, load=False):
    """
    Setter method for scanning_dwell_time, mapped from YANG variable /access_points/access_point/radios/radio/config/scanning_dwell_time (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_scanning_dwell_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_scanning_dwell_time() directly.

    YANG Description: Amount of time, in milliseconds, the radio will spend on a
channel during scanning-interval. If a Monitor-mode Radio, it will
cycle through scanning-allowed-channels spending this amount of time
on each.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="scanning-dwell-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """scanning_dwell_time must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="scanning-dwell-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint16', is_config=True)""",
        })

    self.__scanning_dwell_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_scanning_dwell_time(self):
    self.__scanning_dwell_time = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="scanning-dwell-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint16', is_config=True)


  def _get_scanning_defer_clients(self):
    """
    Getter method for scanning_defer_clients, mapped from YANG variable /access_points/access_point/radios/radio/config/scanning_defer_clients (uint8)

    YANG Description: Do not perform scanning if this amount of Stations are Associated
to the Radio.
    """
    return self.__scanning_defer_clients
      
  def _set_scanning_defer_clients(self, v, load=False):
    """
    Setter method for scanning_defer_clients, mapped from YANG variable /access_points/access_point/radios/radio/config/scanning_defer_clients (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_scanning_defer_clients is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_scanning_defer_clients() directly.

    YANG Description: Do not perform scanning if this amount of Stations are Associated
to the Radio.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="scanning-defer-clients", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """scanning_defer_clients must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="scanning-defer-clients", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint8', is_config=True)""",
        })

    self.__scanning_defer_clients = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_scanning_defer_clients(self):
    self.__scanning_defer_clients = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="scanning-defer-clients", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint8', is_config=True)


  def _get_scanning_defer_traffic(self):
    """
    Getter method for scanning_defer_traffic, mapped from YANG variable /access_points/access_point/radios/radio/config/scanning_defer_traffic (boolean)

    YANG Description: Do not perform scanning if any traffic received from an active Station
in the past 100ms marked as AC_VO or AC_VI.
    """
    return self.__scanning_defer_traffic
      
  def _set_scanning_defer_traffic(self, v, load=False):
    """
    Setter method for scanning_defer_traffic, mapped from YANG variable /access_points/access_point/radios/radio/config/scanning_defer_traffic (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_scanning_defer_traffic is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_scanning_defer_traffic() directly.

    YANG Description: Do not perform scanning if any traffic received from an active Station
in the past 100ms marked as AC_VO or AC_VI.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="scanning-defer-traffic", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """scanning_defer_traffic must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="scanning-defer-traffic", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=True)""",
        })

    self.__scanning_defer_traffic = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_scanning_defer_traffic(self):
    self.__scanning_defer_traffic = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="scanning-defer-traffic", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=True)

  id = __builtin__.property(_get_id, _set_id)
  operating_frequency = __builtin__.property(_get_operating_frequency, _set_operating_frequency)
  enabled = __builtin__.property(_get_enabled, _set_enabled)
  transmit_power = __builtin__.property(_get_transmit_power, _set_transmit_power)
  channel = __builtin__.property(_get_channel, _set_channel)
  channel_width = __builtin__.property(_get_channel_width, _set_channel_width)
  dca = __builtin__.property(_get_dca, _set_dca)
  allowed_channels = __builtin__.property(_get_allowed_channels, _set_allowed_channels)
  dtp = __builtin__.property(_get_dtp, _set_dtp)
  dtp_min = __builtin__.property(_get_dtp_min, _set_dtp_min)
  dtp_max = __builtin__.property(_get_dtp_max, _set_dtp_max)
  antenna_gain = __builtin__.property(_get_antenna_gain, _set_antenna_gain)
  scanning = __builtin__.property(_get_scanning, _set_scanning)
  scanning_interval = __builtin__.property(_get_scanning_interval, _set_scanning_interval)
  scanning_dwell_time = __builtin__.property(_get_scanning_dwell_time, _set_scanning_dwell_time)
  scanning_defer_clients = __builtin__.property(_get_scanning_defer_clients, _set_scanning_defer_clients)
  scanning_defer_traffic = __builtin__.property(_get_scanning_defer_traffic, _set_scanning_defer_traffic)


  _pyangbind_elements = OrderedDict([('id', id), ('operating_frequency', operating_frequency), ('enabled', enabled), ('transmit_power', transmit_power), ('channel', channel), ('channel_width', channel_width), ('dca', dca), ('allowed_channels', allowed_channels), ('dtp', dtp), ('dtp_min', dtp_min), ('dtp_max', dtp_max), ('antenna_gain', antenna_gain), ('scanning', scanning), ('scanning_interval', scanning_interval), ('scanning_dwell_time', scanning_dwell_time), ('scanning_defer_clients', scanning_defer_clients), ('scanning_defer_traffic', scanning_defer_traffic), ])


class yc_counters_openconfig_access_points__access_points_access_point_radios_radio_state_counters(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-access-points - based on the path /access-points/access-point/radios/radio/state/counters. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: A collection of radio-related statistics objects.
  """
  __slots__ = ('_path_helper', '_extmethods', '__failed_fcs_frames','__noise_floor',)

  _yang_name = 'counters'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__failed_fcs_frames = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="failed-fcs-frames", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)
    self.__noise_floor = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['-128..127']}, int_size=8), is_leaf=True, yang_name="noise-floor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='int8', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'access-points', u'access-point', u'radios', u'radio', u'state', u'counters']

  def _get_failed_fcs_frames(self):
    """
    Getter method for failed_fcs_frames, mapped from YANG variable /access_points/access_point/radios/radio/state/counters/failed_fcs_frames (oc-yang:counter64)

    YANG Description: Number of frames that failed the FCS
    """
    return self.__failed_fcs_frames
      
  def _set_failed_fcs_frames(self, v, load=False):
    """
    Setter method for failed_fcs_frames, mapped from YANG variable /access_points/access_point/radios/radio/state/counters/failed_fcs_frames (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_failed_fcs_frames is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_failed_fcs_frames() directly.

    YANG Description: Number of frames that failed the FCS
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="failed-fcs-frames", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """failed_fcs_frames must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="failed-fcs-frames", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__failed_fcs_frames = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_failed_fcs_frames(self):
    self.__failed_fcs_frames = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="failed-fcs-frames", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)


  def _get_noise_floor(self):
    """
    Getter method for noise_floor, mapped from YANG variable /access_points/access_point/radios/radio/state/counters/noise_floor (int8)

    YANG Description: Noise Floor, as measured by this radio.
    """
    return self.__noise_floor
      
  def _set_noise_floor(self, v, load=False):
    """
    Setter method for noise_floor, mapped from YANG variable /access_points/access_point/radios/radio/state/counters/noise_floor (int8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_noise_floor is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_noise_floor() directly.

    YANG Description: Noise Floor, as measured by this radio.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['-128..127']}, int_size=8), is_leaf=True, yang_name="noise-floor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='int8', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """noise_floor must be of a type compatible with int8""",
          'defined-type': "int8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['-128..127']}, int_size=8), is_leaf=True, yang_name="noise-floor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='int8', is_config=False)""",
        })

    self.__noise_floor = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_noise_floor(self):
    self.__noise_floor = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['-128..127']}, int_size=8), is_leaf=True, yang_name="noise-floor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='int8', is_config=False)

  failed_fcs_frames = __builtin__.property(_get_failed_fcs_frames)
  noise_floor = __builtin__.property(_get_noise_floor)


  _pyangbind_elements = OrderedDict([('failed_fcs_frames', failed_fcs_frames), ('noise_floor', noise_floor), ])


class yc_state_openconfig_access_points__access_points_access_point_radios_radio_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-access-points - based on the path /access-points/access-point/radios/radio/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Operational state data at the global radio level
  """
  __slots__ = ('_path_helper', '_extmethods', '__id','__operating_frequency','__enabled','__transmit_power','__channel','__channel_width','__dca','__allowed_channels','__dtp','__dtp_min','__dtp_max','__antenna_gain','__scanning','__scanning_interval','__scanning_dwell_time','__scanning_defer_clients','__scanning_defer_traffic','__base_radio_mac','__dfs_hit_time','__channel_change_reason','__total_channel_utilization','__rx_dot11_channel_utilization','__rx_noise_channel_utilization','__tx_dot11_channel_utilization','__counters',)

  _yang_name = 'state'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__operating_frequency = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'oc-wifi-types:FREQ_2GHZ': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:FREQ_5GHZ': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:FREQ_2_5_GHZ': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'FREQ_5GHZ': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'FREQ_2_5_GHZ': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'FREQ_2GHZ': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}},), is_leaf=True, yang_name="operating-frequency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='identityref', is_config=False)
    self.__scanning_defer_clients = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="scanning-defer-clients", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint8', is_config=False)
    self.__total_channel_utilization = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={u'range': [u'0..100']}), is_leaf=True, yang_name="total-channel-utilization", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:percentage', is_config=False)
    self.__scanning = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="scanning", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=False)
    self.__dfs_hit_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="dfs-hit-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:timeticks64', is_config=False)
    self.__channel_change_reason = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'oc-wifi-types:ERRORS': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:NOISE': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'BETTER-CHANNEL': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:DFS': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'ERRORS': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'DFS': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'NOISE': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:BETTER-CHANNEL': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}},), is_leaf=True, yang_name="channel-change-reason", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='identityref', is_config=False)
    self.__id = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint8', is_config=False)
    self.__rx_dot11_channel_utilization = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={u'range': [u'0..100']}), is_leaf=True, yang_name="rx-dot11-channel-utilization", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:percentage', is_config=False)
    self.__scanning_interval = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="scanning-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint8', is_config=False)
    self.__counters = YANGDynClass(base=yc_counters_openconfig_access_points__access_points_access_point_radios_radio_state_counters, is_container='container', yang_name="counters", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=False)
    self.__rx_noise_channel_utilization = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={u'range': [u'0..100']}), is_leaf=True, yang_name="rx-noise-channel-utilization", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:percentage', is_config=False)
    self.__antenna_gain = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['-128..127']}, int_size=8), is_leaf=True, yang_name="antenna-gain", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='int8', is_config=False)
    self.__channel_width = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="channel-width", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint8', is_config=False)
    self.__dca = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="dca", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=False)
    self.__transmit_power = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="transmit-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint8', is_config=False)
    self.__scanning_dwell_time = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="scanning-dwell-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint16', is_config=False)
    self.__scanning_defer_traffic = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="scanning-defer-traffic", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=False)
    self.__tx_dot11_channel_utilization = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={u'range': [u'0..100']}), is_leaf=True, yang_name="tx-dot11-channel-utilization", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:percentage', is_config=False)
    self.__enabled = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=False)
    self.__allowed_channels = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={u'range': [u'1..14', u'36', u'40', u'44', u'48', u'52', u'56', u'60', u'64', u'100', u'104', u'108', u'112', u'116', u'120', u'124', u'128', u'132', u'136', u'140', u'144', u'149', u'153', u'157', u'161', u'165']})), is_leaf=False, yang_name="allowed-channels", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-wifi-types:channels-type', is_config=False)
    self.__channel = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={u'range': [u'1..165']}), is_leaf=True, yang_name="channel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint8', is_config=False)
    self.__dtp_max = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(15), is_leaf=True, yang_name="dtp-max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint8', is_config=False)
    self.__dtp_min = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(3), is_leaf=True, yang_name="dtp-min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint8', is_config=False)
    self.__dtp = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="dtp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=False)
    self.__base_radio_mac = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}$'}), is_leaf=True, yang_name="base-radio-mac", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:mac-address', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'access-points', u'access-point', u'radios', u'radio', u'state']

  def _get_id(self):
    """
    Getter method for id, mapped from YANG variable /access_points/access_point/radios/radio/state/id (uint8)

    YANG Description: Unique ID of the radio.
    """
    return self.__id
      
  def _set_id(self, v, load=False):
    """
    Setter method for id, mapped from YANG variable /access_points/access_point/radios/radio/state/id (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: Unique ID of the radio.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint8', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """id must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint8', is_config=False)""",
        })

    self.__id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_id(self):
    self.__id = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint8', is_config=False)


  def _get_operating_frequency(self):
    """
    Getter method for operating_frequency, mapped from YANG variable /access_points/access_point/radios/radio/state/operating_frequency (identityref)

    YANG Description: Operating frequency of this radio.
    """
    return self.__operating_frequency
      
  def _set_operating_frequency(self, v, load=False):
    """
    Setter method for operating_frequency, mapped from YANG variable /access_points/access_point/radios/radio/state/operating_frequency (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_operating_frequency is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_operating_frequency() directly.

    YANG Description: Operating frequency of this radio.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'oc-wifi-types:FREQ_2GHZ': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:FREQ_5GHZ': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:FREQ_2_5_GHZ': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'FREQ_5GHZ': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'FREQ_2_5_GHZ': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'FREQ_2GHZ': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}},), is_leaf=True, yang_name="operating-frequency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='identityref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """operating_frequency must be of a type compatible with identityref""",
          'defined-type': "openconfig-access-points:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'oc-wifi-types:FREQ_2GHZ': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:FREQ_5GHZ': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:FREQ_2_5_GHZ': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'FREQ_5GHZ': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'FREQ_2_5_GHZ': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'FREQ_2GHZ': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}},), is_leaf=True, yang_name="operating-frequency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='identityref', is_config=False)""",
        })

    self.__operating_frequency = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_operating_frequency(self):
    self.__operating_frequency = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'oc-wifi-types:FREQ_2GHZ': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:FREQ_5GHZ': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:FREQ_2_5_GHZ': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'FREQ_5GHZ': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'FREQ_2_5_GHZ': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'FREQ_2GHZ': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}},), is_leaf=True, yang_name="operating-frequency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='identityref', is_config=False)


  def _get_enabled(self):
    """
    Getter method for enabled, mapped from YANG variable /access_points/access_point/radios/radio/state/enabled (boolean)

    YANG Description: The desired operational state (up/down) of this radio interface.
    """
    return self.__enabled
      
  def _set_enabled(self, v, load=False):
    """
    Setter method for enabled, mapped from YANG variable /access_points/access_point/radios/radio/state/enabled (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_enabled is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_enabled() directly.

    YANG Description: The desired operational state (up/down) of this radio interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """enabled must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=False)""",
        })

    self.__enabled = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_enabled(self):
    self.__enabled = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=False)


  def _get_transmit_power(self):
    """
    Getter method for transmit_power, mapped from YANG variable /access_points/access_point/radios/radio/state/transmit_power (uint8)

    YANG Description: Transmit power of the radio, in dBm.
    """
    return self.__transmit_power
      
  def _set_transmit_power(self, v, load=False):
    """
    Setter method for transmit_power, mapped from YANG variable /access_points/access_point/radios/radio/state/transmit_power (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_transmit_power is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_transmit_power() directly.

    YANG Description: Transmit power of the radio, in dBm.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="transmit-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint8', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """transmit_power must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="transmit-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint8', is_config=False)""",
        })

    self.__transmit_power = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_transmit_power(self):
    self.__transmit_power = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="transmit-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint8', is_config=False)


  def _get_channel(self):
    """
    Getter method for channel, mapped from YANG variable /access_points/access_point/radios/radio/state/channel (uint8)

    YANG Description: Operating channel of this radio. If using channel-bonding this
will represent the Primary 20MHz channel of the 40,80,160MHz channel.
    """
    return self.__channel
      
  def _set_channel(self, v, load=False):
    """
    Setter method for channel, mapped from YANG variable /access_points/access_point/radios/radio/state/channel (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_channel is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_channel() directly.

    YANG Description: Operating channel of this radio. If using channel-bonding this
will represent the Primary 20MHz channel of the 40,80,160MHz channel.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={u'range': [u'1..165']}), is_leaf=True, yang_name="channel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint8', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """channel must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={u'range': [u'1..165']}), is_leaf=True, yang_name="channel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint8', is_config=False)""",
        })

    self.__channel = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_channel(self):
    self.__channel = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={u'range': [u'1..165']}), is_leaf=True, yang_name="channel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint8', is_config=False)


  def _get_channel_width(self):
    """
    Getter method for channel_width, mapped from YANG variable /access_points/access_point/radios/radio/state/channel_width (uint8)

    YANG Description: Operating channel-width of this radio.
    """
    return self.__channel_width
      
  def _set_channel_width(self, v, load=False):
    """
    Setter method for channel_width, mapped from YANG variable /access_points/access_point/radios/radio/state/channel_width (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_channel_width is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_channel_width() directly.

    YANG Description: Operating channel-width of this radio.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="channel-width", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint8', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """channel_width must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="channel-width", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint8', is_config=False)""",
        })

    self.__channel_width = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_channel_width(self):
    self.__channel_width = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="channel-width", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint8', is_config=False)


  def _get_dca(self):
    """
    Getter method for dca, mapped from YANG variable /access_points/access_point/radios/radio/state/dca (boolean)

    YANG Description: Utilize Dynamic Channel Assignment on this Radio.
    """
    return self.__dca
      
  def _set_dca(self, v, load=False):
    """
    Setter method for dca, mapped from YANG variable /access_points/access_point/radios/radio/state/dca (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dca is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dca() directly.

    YANG Description: Utilize Dynamic Channel Assignment on this Radio.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="dca", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dca must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="dca", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=False)""",
        })

    self.__dca = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dca(self):
    self.__dca = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="dca", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=False)


  def _get_allowed_channels(self):
    """
    Getter method for allowed_channels, mapped from YANG variable /access_points/access_point/radios/radio/state/allowed_channels (oc-wifi-types:channels-type)

    YANG Description: Allowed channel list for this Radio to utilize.
    """
    return self.__allowed_channels
      
  def _set_allowed_channels(self, v, load=False):
    """
    Setter method for allowed_channels, mapped from YANG variable /access_points/access_point/radios/radio/state/allowed_channels (oc-wifi-types:channels-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_allowed_channels is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_allowed_channels() directly.

    YANG Description: Allowed channel list for this Radio to utilize.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={u'range': [u'1..14', u'36', u'40', u'44', u'48', u'52', u'56', u'60', u'64', u'100', u'104', u'108', u'112', u'116', u'120', u'124', u'128', u'132', u'136', u'140', u'144', u'149', u'153', u'157', u'161', u'165']})), is_leaf=False, yang_name="allowed-channels", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-wifi-types:channels-type', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """allowed_channels must be of a type compatible with oc-wifi-types:channels-type""",
          'defined-type': "oc-wifi-types:channels-type",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={u'range': [u'1..14', u'36', u'40', u'44', u'48', u'52', u'56', u'60', u'64', u'100', u'104', u'108', u'112', u'116', u'120', u'124', u'128', u'132', u'136', u'140', u'144', u'149', u'153', u'157', u'161', u'165']})), is_leaf=False, yang_name="allowed-channels", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-wifi-types:channels-type', is_config=False)""",
        })

    self.__allowed_channels = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_allowed_channels(self):
    self.__allowed_channels = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={u'range': [u'1..14', u'36', u'40', u'44', u'48', u'52', u'56', u'60', u'64', u'100', u'104', u'108', u'112', u'116', u'120', u'124', u'128', u'132', u'136', u'140', u'144', u'149', u'153', u'157', u'161', u'165']})), is_leaf=False, yang_name="allowed-channels", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-wifi-types:channels-type', is_config=False)


  def _get_dtp(self):
    """
    Getter method for dtp, mapped from YANG variable /access_points/access_point/radios/radio/state/dtp (boolean)

    YANG Description: Utilize dynamic transmit-power on this Radio.
    """
    return self.__dtp
      
  def _set_dtp(self, v, load=False):
    """
    Setter method for dtp, mapped from YANG variable /access_points/access_point/radios/radio/state/dtp (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dtp is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dtp() directly.

    YANG Description: Utilize dynamic transmit-power on this Radio.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="dtp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dtp must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="dtp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=False)""",
        })

    self.__dtp = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dtp(self):
    self.__dtp = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="dtp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=False)


  def _get_dtp_min(self):
    """
    Getter method for dtp_min, mapped from YANG variable /access_points/access_point/radios/radio/state/dtp_min (uint8)

    YANG Description: Minimum allowed transmit-power on this radio, if utilizing dtp.
Expressed in dBm.
    """
    return self.__dtp_min
      
  def _set_dtp_min(self, v, load=False):
    """
    Setter method for dtp_min, mapped from YANG variable /access_points/access_point/radios/radio/state/dtp_min (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dtp_min is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dtp_min() directly.

    YANG Description: Minimum allowed transmit-power on this radio, if utilizing dtp.
Expressed in dBm.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(3), is_leaf=True, yang_name="dtp-min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint8', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dtp_min must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(3), is_leaf=True, yang_name="dtp-min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint8', is_config=False)""",
        })

    self.__dtp_min = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dtp_min(self):
    self.__dtp_min = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(3), is_leaf=True, yang_name="dtp-min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint8', is_config=False)


  def _get_dtp_max(self):
    """
    Getter method for dtp_max, mapped from YANG variable /access_points/access_point/radios/radio/state/dtp_max (uint8)

    YANG Description: Maximum allowed transmit-power on this radio, if utilizing dtp.
Expressed in dBm.
    """
    return self.__dtp_max
      
  def _set_dtp_max(self, v, load=False):
    """
    Setter method for dtp_max, mapped from YANG variable /access_points/access_point/radios/radio/state/dtp_max (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dtp_max is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dtp_max() directly.

    YANG Description: Maximum allowed transmit-power on this radio, if utilizing dtp.
Expressed in dBm.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(15), is_leaf=True, yang_name="dtp-max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint8', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dtp_max must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(15), is_leaf=True, yang_name="dtp-max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint8', is_config=False)""",
        })

    self.__dtp_max = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dtp_max(self):
    self.__dtp_max = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(15), is_leaf=True, yang_name="dtp-max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint8', is_config=False)


  def _get_antenna_gain(self):
    """
    Getter method for antenna_gain, mapped from YANG variable /access_points/access_point/radios/radio/state/antenna_gain (int8)

    YANG Description: Antenna gain applied to this Radio; typically used when
external antennae connected.
    """
    return self.__antenna_gain
      
  def _set_antenna_gain(self, v, load=False):
    """
    Setter method for antenna_gain, mapped from YANG variable /access_points/access_point/radios/radio/state/antenna_gain (int8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_antenna_gain is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_antenna_gain() directly.

    YANG Description: Antenna gain applied to this Radio; typically used when
external antennae connected.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['-128..127']}, int_size=8), is_leaf=True, yang_name="antenna-gain", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='int8', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """antenna_gain must be of a type compatible with int8""",
          'defined-type': "int8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['-128..127']}, int_size=8), is_leaf=True, yang_name="antenna-gain", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='int8', is_config=False)""",
        })

    self.__antenna_gain = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_antenna_gain(self):
    self.__antenna_gain = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['-128..127']}, int_size=8), is_leaf=True, yang_name="antenna-gain", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='int8', is_config=False)


  def _get_scanning(self):
    """
    Getter method for scanning, mapped from YANG variable /access_points/access_point/radios/radio/state/scanning (boolean)

    YANG Description: Whether the radio will perform off-channel scanning, to collect
neighboring RF information.
    """
    return self.__scanning
      
  def _set_scanning(self, v, load=False):
    """
    Setter method for scanning, mapped from YANG variable /access_points/access_point/radios/radio/state/scanning (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_scanning is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_scanning() directly.

    YANG Description: Whether the radio will perform off-channel scanning, to collect
neighboring RF information.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="scanning", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """scanning must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="scanning", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=False)""",
        })

    self.__scanning = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_scanning(self):
    self.__scanning = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="scanning", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=False)


  def _get_scanning_interval(self):
    """
    Getter method for scanning_interval, mapped from YANG variable /access_points/access_point/radios/radio/state/scanning_interval (uint8)

    YANG Description: How often, in seconds, the radio will go off-channel to perform
scanning.
    """
    return self.__scanning_interval
      
  def _set_scanning_interval(self, v, load=False):
    """
    Setter method for scanning_interval, mapped from YANG variable /access_points/access_point/radios/radio/state/scanning_interval (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_scanning_interval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_scanning_interval() directly.

    YANG Description: How often, in seconds, the radio will go off-channel to perform
scanning.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="scanning-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint8', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """scanning_interval must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="scanning-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint8', is_config=False)""",
        })

    self.__scanning_interval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_scanning_interval(self):
    self.__scanning_interval = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="scanning-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint8', is_config=False)


  def _get_scanning_dwell_time(self):
    """
    Getter method for scanning_dwell_time, mapped from YANG variable /access_points/access_point/radios/radio/state/scanning_dwell_time (uint16)

    YANG Description: Amount of time, in milliseconds, the radio will spend on a
channel during scanning-interval. If a Monitor-mode Radio, it will
cycle through scanning-allowed-channels spending this amount of time
on each.
    """
    return self.__scanning_dwell_time
      
  def _set_scanning_dwell_time(self, v, load=False):
    """
    Setter method for scanning_dwell_time, mapped from YANG variable /access_points/access_point/radios/radio/state/scanning_dwell_time (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_scanning_dwell_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_scanning_dwell_time() directly.

    YANG Description: Amount of time, in milliseconds, the radio will spend on a
channel during scanning-interval. If a Monitor-mode Radio, it will
cycle through scanning-allowed-channels spending this amount of time
on each.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="scanning-dwell-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint16', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """scanning_dwell_time must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="scanning-dwell-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint16', is_config=False)""",
        })

    self.__scanning_dwell_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_scanning_dwell_time(self):
    self.__scanning_dwell_time = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="scanning-dwell-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint16', is_config=False)


  def _get_scanning_defer_clients(self):
    """
    Getter method for scanning_defer_clients, mapped from YANG variable /access_points/access_point/radios/radio/state/scanning_defer_clients (uint8)

    YANG Description: Do not perform scanning if this amount of Stations are Associated
to the Radio.
    """
    return self.__scanning_defer_clients
      
  def _set_scanning_defer_clients(self, v, load=False):
    """
    Setter method for scanning_defer_clients, mapped from YANG variable /access_points/access_point/radios/radio/state/scanning_defer_clients (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_scanning_defer_clients is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_scanning_defer_clients() directly.

    YANG Description: Do not perform scanning if this amount of Stations are Associated
to the Radio.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="scanning-defer-clients", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint8', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """scanning_defer_clients must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="scanning-defer-clients", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint8', is_config=False)""",
        })

    self.__scanning_defer_clients = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_scanning_defer_clients(self):
    self.__scanning_defer_clients = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="scanning-defer-clients", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint8', is_config=False)


  def _get_scanning_defer_traffic(self):
    """
    Getter method for scanning_defer_traffic, mapped from YANG variable /access_points/access_point/radios/radio/state/scanning_defer_traffic (boolean)

    YANG Description: Do not perform scanning if any traffic received from an active Station
in the past 100ms marked as AC_VO or AC_VI.
    """
    return self.__scanning_defer_traffic
      
  def _set_scanning_defer_traffic(self, v, load=False):
    """
    Setter method for scanning_defer_traffic, mapped from YANG variable /access_points/access_point/radios/radio/state/scanning_defer_traffic (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_scanning_defer_traffic is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_scanning_defer_traffic() directly.

    YANG Description: Do not perform scanning if any traffic received from an active Station
in the past 100ms marked as AC_VO or AC_VI.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="scanning-defer-traffic", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """scanning_defer_traffic must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="scanning-defer-traffic", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=False)""",
        })

    self.__scanning_defer_traffic = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_scanning_defer_traffic(self):
    self.__scanning_defer_traffic = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="scanning-defer-traffic", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=False)


  def _get_base_radio_mac(self):
    """
    Getter method for base_radio_mac, mapped from YANG variable /access_points/access_point/radios/radio/state/base_radio_mac (oc-yang:mac-address)

    YANG Description: Represents the 'burned-in' base-radio MAC
address for the a Radio interface.
    """
    return self.__base_radio_mac
      
  def _set_base_radio_mac(self, v, load=False):
    """
    Setter method for base_radio_mac, mapped from YANG variable /access_points/access_point/radios/radio/state/base_radio_mac (oc-yang:mac-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_base_radio_mac is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_base_radio_mac() directly.

    YANG Description: Represents the 'burned-in' base-radio MAC
address for the a Radio interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}$'}), is_leaf=True, yang_name="base-radio-mac", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:mac-address', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """base_radio_mac must be of a type compatible with oc-yang:mac-address""",
          'defined-type': "oc-yang:mac-address",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}$'}), is_leaf=True, yang_name="base-radio-mac", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:mac-address', is_config=False)""",
        })

    self.__base_radio_mac = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_base_radio_mac(self):
    self.__base_radio_mac = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}$'}), is_leaf=True, yang_name="base-radio-mac", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:mac-address', is_config=False)


  def _get_dfs_hit_time(self):
    """
    Getter method for dfs_hit_time, mapped from YANG variable /access_points/access_point/radios/radio/state/dfs_hit_time (oc-types:timeticks64)

    YANG Description: Reports the time of the last DFS hit. The value is the timestamp
in seconds relative to the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    return self.__dfs_hit_time
      
  def _set_dfs_hit_time(self, v, load=False):
    """
    Setter method for dfs_hit_time, mapped from YANG variable /access_points/access_point/radios/radio/state/dfs_hit_time (oc-types:timeticks64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dfs_hit_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dfs_hit_time() directly.

    YANG Description: Reports the time of the last DFS hit. The value is the timestamp
in seconds relative to the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="dfs-hit-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:timeticks64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dfs_hit_time must be of a type compatible with oc-types:timeticks64""",
          'defined-type': "oc-types:timeticks64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="dfs-hit-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:timeticks64', is_config=False)""",
        })

    self.__dfs_hit_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dfs_hit_time(self):
    self.__dfs_hit_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="dfs-hit-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:timeticks64', is_config=False)


  def _get_channel_change_reason(self):
    """
    Getter method for channel_change_reason, mapped from YANG variable /access_points/access_point/radios/radio/state/channel_change_reason (identityref)

    YANG Description: When an Access Point changes channels, this will
provide the reason that led to the change.
    """
    return self.__channel_change_reason
      
  def _set_channel_change_reason(self, v, load=False):
    """
    Setter method for channel_change_reason, mapped from YANG variable /access_points/access_point/radios/radio/state/channel_change_reason (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_channel_change_reason is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_channel_change_reason() directly.

    YANG Description: When an Access Point changes channels, this will
provide the reason that led to the change.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'oc-wifi-types:ERRORS': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:NOISE': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'BETTER-CHANNEL': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:DFS': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'ERRORS': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'DFS': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'NOISE': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:BETTER-CHANNEL': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}},), is_leaf=True, yang_name="channel-change-reason", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='identityref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """channel_change_reason must be of a type compatible with identityref""",
          'defined-type': "openconfig-access-points:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'oc-wifi-types:ERRORS': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:NOISE': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'BETTER-CHANNEL': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:DFS': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'ERRORS': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'DFS': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'NOISE': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:BETTER-CHANNEL': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}},), is_leaf=True, yang_name="channel-change-reason", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='identityref', is_config=False)""",
        })

    self.__channel_change_reason = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_channel_change_reason(self):
    self.__channel_change_reason = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'oc-wifi-types:ERRORS': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:NOISE': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'BETTER-CHANNEL': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:DFS': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'ERRORS': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'DFS': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'NOISE': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:BETTER-CHANNEL': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}},), is_leaf=True, yang_name="channel-change-reason", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='identityref', is_config=False)


  def _get_total_channel_utilization(self):
    """
    Getter method for total_channel_utilization, mapped from YANG variable /access_points/access_point/radios/radio/state/total_channel_utilization (oc-types:percentage)

    YANG Description: Total 802.11 and non-802.11 channel utilization on this Radio. The
total channel utilization should include all time periods the AP
spent actively receiving and transmitting 802.11 frames, and also
include all time spent with clear channel assessment (CCA) in a
busy state
    """
    return self.__total_channel_utilization
      
  def _set_total_channel_utilization(self, v, load=False):
    """
    Setter method for total_channel_utilization, mapped from YANG variable /access_points/access_point/radios/radio/state/total_channel_utilization (oc-types:percentage)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_total_channel_utilization is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_total_channel_utilization() directly.

    YANG Description: Total 802.11 and non-802.11 channel utilization on this Radio. The
total channel utilization should include all time periods the AP
spent actively receiving and transmitting 802.11 frames, and also
include all time spent with clear channel assessment (CCA) in a
busy state
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={u'range': [u'0..100']}), is_leaf=True, yang_name="total-channel-utilization", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:percentage', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """total_channel_utilization must be of a type compatible with oc-types:percentage""",
          'defined-type': "oc-types:percentage",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={u'range': [u'0..100']}), is_leaf=True, yang_name="total-channel-utilization", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:percentage', is_config=False)""",
        })

    self.__total_channel_utilization = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_total_channel_utilization(self):
    self.__total_channel_utilization = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={u'range': [u'0..100']}), is_leaf=True, yang_name="total-channel-utilization", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:percentage', is_config=False)


  def _get_rx_dot11_channel_utilization(self):
    """
    Getter method for rx_dot11_channel_utilization, mapped from YANG variable /access_points/access_point/radios/radio/state/rx_dot11_channel_utilization (oc-types:percentage)

    YANG Description: Received channel-utilization due to 802.11 frames
    """
    return self.__rx_dot11_channel_utilization
      
  def _set_rx_dot11_channel_utilization(self, v, load=False):
    """
    Setter method for rx_dot11_channel_utilization, mapped from YANG variable /access_points/access_point/radios/radio/state/rx_dot11_channel_utilization (oc-types:percentage)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_rx_dot11_channel_utilization is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_rx_dot11_channel_utilization() directly.

    YANG Description: Received channel-utilization due to 802.11 frames
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={u'range': [u'0..100']}), is_leaf=True, yang_name="rx-dot11-channel-utilization", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:percentage', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """rx_dot11_channel_utilization must be of a type compatible with oc-types:percentage""",
          'defined-type': "oc-types:percentage",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={u'range': [u'0..100']}), is_leaf=True, yang_name="rx-dot11-channel-utilization", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:percentage', is_config=False)""",
        })

    self.__rx_dot11_channel_utilization = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_rx_dot11_channel_utilization(self):
    self.__rx_dot11_channel_utilization = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={u'range': [u'0..100']}), is_leaf=True, yang_name="rx-dot11-channel-utilization", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:percentage', is_config=False)


  def _get_rx_noise_channel_utilization(self):
    """
    Getter method for rx_noise_channel_utilization, mapped from YANG variable /access_points/access_point/radios/radio/state/rx_noise_channel_utilization (oc-types:percentage)

    YANG Description: Received channel-utilization percentage due to Noise.
    """
    return self.__rx_noise_channel_utilization
      
  def _set_rx_noise_channel_utilization(self, v, load=False):
    """
    Setter method for rx_noise_channel_utilization, mapped from YANG variable /access_points/access_point/radios/radio/state/rx_noise_channel_utilization (oc-types:percentage)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_rx_noise_channel_utilization is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_rx_noise_channel_utilization() directly.

    YANG Description: Received channel-utilization percentage due to Noise.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={u'range': [u'0..100']}), is_leaf=True, yang_name="rx-noise-channel-utilization", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:percentage', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """rx_noise_channel_utilization must be of a type compatible with oc-types:percentage""",
          'defined-type': "oc-types:percentage",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={u'range': [u'0..100']}), is_leaf=True, yang_name="rx-noise-channel-utilization", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:percentage', is_config=False)""",
        })

    self.__rx_noise_channel_utilization = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_rx_noise_channel_utilization(self):
    self.__rx_noise_channel_utilization = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={u'range': [u'0..100']}), is_leaf=True, yang_name="rx-noise-channel-utilization", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:percentage', is_config=False)


  def _get_tx_dot11_channel_utilization(self):
    """
    Getter method for tx_dot11_channel_utilization, mapped from YANG variable /access_points/access_point/radios/radio/state/tx_dot11_channel_utilization (oc-types:percentage)

    YANG Description: Transmit channel-utilization percentage.
    """
    return self.__tx_dot11_channel_utilization
      
  def _set_tx_dot11_channel_utilization(self, v, load=False):
    """
    Setter method for tx_dot11_channel_utilization, mapped from YANG variable /access_points/access_point/radios/radio/state/tx_dot11_channel_utilization (oc-types:percentage)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tx_dot11_channel_utilization is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tx_dot11_channel_utilization() directly.

    YANG Description: Transmit channel-utilization percentage.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={u'range': [u'0..100']}), is_leaf=True, yang_name="tx-dot11-channel-utilization", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:percentage', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tx_dot11_channel_utilization must be of a type compatible with oc-types:percentage""",
          'defined-type': "oc-types:percentage",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={u'range': [u'0..100']}), is_leaf=True, yang_name="tx-dot11-channel-utilization", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:percentage', is_config=False)""",
        })

    self.__tx_dot11_channel_utilization = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tx_dot11_channel_utilization(self):
    self.__tx_dot11_channel_utilization = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={u'range': [u'0..100']}), is_leaf=True, yang_name="tx-dot11-channel-utilization", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:percentage', is_config=False)


  def _get_counters(self):
    """
    Getter method for counters, mapped from YANG variable /access_points/access_point/radios/radio/state/counters (container)

    YANG Description: A collection of radio-related statistics objects.
    """
    return self.__counters
      
  def _set_counters(self, v, load=False):
    """
    Setter method for counters, mapped from YANG variable /access_points/access_point/radios/radio/state/counters (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_counters is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_counters() directly.

    YANG Description: A collection of radio-related statistics objects.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_counters_openconfig_access_points__access_points_access_point_radios_radio_state_counters, is_container='container', yang_name="counters", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """counters must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_counters_openconfig_access_points__access_points_access_point_radios_radio_state_counters, is_container='container', yang_name="counters", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=False)""",
        })

    self.__counters = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_counters(self):
    self.__counters = YANGDynClass(base=yc_counters_openconfig_access_points__access_points_access_point_radios_radio_state_counters, is_container='container', yang_name="counters", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=False)

  id = __builtin__.property(_get_id)
  operating_frequency = __builtin__.property(_get_operating_frequency)
  enabled = __builtin__.property(_get_enabled)
  transmit_power = __builtin__.property(_get_transmit_power)
  channel = __builtin__.property(_get_channel)
  channel_width = __builtin__.property(_get_channel_width)
  dca = __builtin__.property(_get_dca)
  allowed_channels = __builtin__.property(_get_allowed_channels)
  dtp = __builtin__.property(_get_dtp)
  dtp_min = __builtin__.property(_get_dtp_min)
  dtp_max = __builtin__.property(_get_dtp_max)
  antenna_gain = __builtin__.property(_get_antenna_gain)
  scanning = __builtin__.property(_get_scanning)
  scanning_interval = __builtin__.property(_get_scanning_interval)
  scanning_dwell_time = __builtin__.property(_get_scanning_dwell_time)
  scanning_defer_clients = __builtin__.property(_get_scanning_defer_clients)
  scanning_defer_traffic = __builtin__.property(_get_scanning_defer_traffic)
  base_radio_mac = __builtin__.property(_get_base_radio_mac)
  dfs_hit_time = __builtin__.property(_get_dfs_hit_time)
  channel_change_reason = __builtin__.property(_get_channel_change_reason)
  total_channel_utilization = __builtin__.property(_get_total_channel_utilization)
  rx_dot11_channel_utilization = __builtin__.property(_get_rx_dot11_channel_utilization)
  rx_noise_channel_utilization = __builtin__.property(_get_rx_noise_channel_utilization)
  tx_dot11_channel_utilization = __builtin__.property(_get_tx_dot11_channel_utilization)
  counters = __builtin__.property(_get_counters)


  _pyangbind_elements = OrderedDict([('id', id), ('operating_frequency', operating_frequency), ('enabled', enabled), ('transmit_power', transmit_power), ('channel', channel), ('channel_width', channel_width), ('dca', dca), ('allowed_channels', allowed_channels), ('dtp', dtp), ('dtp_min', dtp_min), ('dtp_max', dtp_max), ('antenna_gain', antenna_gain), ('scanning', scanning), ('scanning_interval', scanning_interval), ('scanning_dwell_time', scanning_dwell_time), ('scanning_defer_clients', scanning_defer_clients), ('scanning_defer_traffic', scanning_defer_traffic), ('base_radio_mac', base_radio_mac), ('dfs_hit_time', dfs_hit_time), ('channel_change_reason', channel_change_reason), ('total_channel_utilization', total_channel_utilization), ('rx_dot11_channel_utilization', rx_dot11_channel_utilization), ('rx_noise_channel_utilization', rx_noise_channel_utilization), ('tx_dot11_channel_utilization', tx_dot11_channel_utilization), ('counters', counters), ])


class yc_state_openconfig_access_points__access_points_access_point_radios_radio_neighbors_neighbor_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-access-points - based on the path /access-points/access-point/radios/radio/neighbors/neighbor/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: State container for RF neighbors.
  """
  __slots__ = ('_path_helper', '_extmethods', '__bssid','__ssid','__rssi','__channel','__primary_channel','__last_seen',)

  _yang_name = 'state'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__ssid = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ssid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='string', is_config=False)
    self.__bssid = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}$'}), is_leaf=True, yang_name="bssid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:mac-address', is_config=False)
    self.__primary_channel = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="primary-channel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint16', is_config=False)
    self.__rssi = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['-128..127']}, int_size=8), is_leaf=True, yang_name="rssi", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='int8', is_config=False)
    self.__channel = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="channel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint16', is_config=False)
    self.__last_seen = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="last-seen", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:timeticks64', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'access-points', u'access-point', u'radios', u'radio', u'neighbors', u'neighbor', u'state']

  def _get_bssid(self):
    """
    Getter method for bssid, mapped from YANG variable /access_points/access_point/radios/radio/neighbors/neighbor/state/bssid (oc-yang:mac-address)

    YANG Description: Neighboring BSSID.
    """
    return self.__bssid
      
  def _set_bssid(self, v, load=False):
    """
    Setter method for bssid, mapped from YANG variable /access_points/access_point/radios/radio/neighbors/neighbor/state/bssid (oc-yang:mac-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bssid is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bssid() directly.

    YANG Description: Neighboring BSSID.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}$'}), is_leaf=True, yang_name="bssid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:mac-address', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bssid must be of a type compatible with oc-yang:mac-address""",
          'defined-type': "oc-yang:mac-address",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}$'}), is_leaf=True, yang_name="bssid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:mac-address', is_config=False)""",
        })

    self.__bssid = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bssid(self):
    self.__bssid = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}$'}), is_leaf=True, yang_name="bssid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:mac-address', is_config=False)


  def _get_ssid(self):
    """
    Getter method for ssid, mapped from YANG variable /access_points/access_point/radios/radio/neighbors/neighbor/state/ssid (string)

    YANG Description: The SSID of this neighboring BSSID.
    """
    return self.__ssid
      
  def _set_ssid(self, v, load=False):
    """
    Setter method for ssid, mapped from YANG variable /access_points/access_point/radios/radio/neighbors/neighbor/state/ssid (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ssid is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ssid() directly.

    YANG Description: The SSID of this neighboring BSSID.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="ssid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ssid must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ssid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='string', is_config=False)""",
        })

    self.__ssid = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ssid(self):
    self.__ssid = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ssid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='string', is_config=False)


  def _get_rssi(self):
    """
    Getter method for rssi, mapped from YANG variable /access_points/access_point/radios/radio/neighbors/neighbor/state/rssi (int8)

    YANG Description: The RSSI of this neighboring BSSID.
    """
    return self.__rssi
      
  def _set_rssi(self, v, load=False):
    """
    Setter method for rssi, mapped from YANG variable /access_points/access_point/radios/radio/neighbors/neighbor/state/rssi (int8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_rssi is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_rssi() directly.

    YANG Description: The RSSI of this neighboring BSSID.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['-128..127']}, int_size=8), is_leaf=True, yang_name="rssi", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='int8', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """rssi must be of a type compatible with int8""",
          'defined-type': "int8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['-128..127']}, int_size=8), is_leaf=True, yang_name="rssi", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='int8', is_config=False)""",
        })

    self.__rssi = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_rssi(self):
    self.__rssi = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['-128..127']}, int_size=8), is_leaf=True, yang_name="rssi", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='int8', is_config=False)


  def _get_channel(self):
    """
    Getter method for channel, mapped from YANG variable /access_points/access_point/radios/radio/neighbors/neighbor/state/channel (uint16)

    YANG Description: The channel of this neighboring BSSID. This is to utilize 802.11ac
nomenclature. For example, 40MHz channel 36-40 represented as
channel 38. primary-channel used to identify the primary
20MHz channel of the neighbor.
    """
    return self.__channel
      
  def _set_channel(self, v, load=False):
    """
    Setter method for channel, mapped from YANG variable /access_points/access_point/radios/radio/neighbors/neighbor/state/channel (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_channel is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_channel() directly.

    YANG Description: The channel of this neighboring BSSID. This is to utilize 802.11ac
nomenclature. For example, 40MHz channel 36-40 represented as
channel 38. primary-channel used to identify the primary
20MHz channel of the neighbor.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="channel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint16', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """channel must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="channel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint16', is_config=False)""",
        })

    self.__channel = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_channel(self):
    self.__channel = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="channel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint16', is_config=False)


  def _get_primary_channel(self):
    """
    Getter method for primary_channel, mapped from YANG variable /access_points/access_point/radios/radio/neighbors/neighbor/state/primary_channel (uint16)

    YANG Description: The primary 20MHz channel, if the neighbor is operating on bonded
channel.
    """
    return self.__primary_channel
      
  def _set_primary_channel(self, v, load=False):
    """
    Setter method for primary_channel, mapped from YANG variable /access_points/access_point/radios/radio/neighbors/neighbor/state/primary_channel (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_primary_channel is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_primary_channel() directly.

    YANG Description: The primary 20MHz channel, if the neighbor is operating on bonded
channel.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="primary-channel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint16', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """primary_channel must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="primary-channel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint16', is_config=False)""",
        })

    self.__primary_channel = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_primary_channel(self):
    self.__primary_channel = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="primary-channel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint16', is_config=False)


  def _get_last_seen(self):
    """
    Getter method for last_seen, mapped from YANG variable /access_points/access_point/radios/radio/neighbors/neighbor/state/last_seen (oc-types:timeticks64)

    YANG Description: Reports the time this reading was taken, indicating when this neighbor
was last seen. If a cache is used, it MUST be updated instantly when a
neighbor BSS changes channels, or a new BSS is seen. The value is the
timestamp in seconds relative to the Unix Epoch
(Jan 1, 1970 00:00:00 UTC).
    """
    return self.__last_seen
      
  def _set_last_seen(self, v, load=False):
    """
    Setter method for last_seen, mapped from YANG variable /access_points/access_point/radios/radio/neighbors/neighbor/state/last_seen (oc-types:timeticks64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_last_seen is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_last_seen() directly.

    YANG Description: Reports the time this reading was taken, indicating when this neighbor
was last seen. If a cache is used, it MUST be updated instantly when a
neighbor BSS changes channels, or a new BSS is seen. The value is the
timestamp in seconds relative to the Unix Epoch
(Jan 1, 1970 00:00:00 UTC).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="last-seen", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:timeticks64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """last_seen must be of a type compatible with oc-types:timeticks64""",
          'defined-type': "oc-types:timeticks64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="last-seen", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:timeticks64', is_config=False)""",
        })

    self.__last_seen = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_last_seen(self):
    self.__last_seen = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="last-seen", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:timeticks64', is_config=False)

  bssid = __builtin__.property(_get_bssid)
  ssid = __builtin__.property(_get_ssid)
  rssi = __builtin__.property(_get_rssi)
  channel = __builtin__.property(_get_channel)
  primary_channel = __builtin__.property(_get_primary_channel)
  last_seen = __builtin__.property(_get_last_seen)


  _pyangbind_elements = OrderedDict([('bssid', bssid), ('ssid', ssid), ('rssi', rssi), ('channel', channel), ('primary_channel', primary_channel), ('last_seen', last_seen), ])


class yc_neighbor_openconfig_access_points__access_points_access_point_radios_radio_neighbors_neighbor(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-access-points - based on the path /access-points/access-point/radios/radio/neighbors/neighbor. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The mac address, or BSSID, of a neighbor, and
their corresponding RSSI.
  """
  __slots__ = ('_path_helper', '_extmethods', '__bssid','__state',)

  _yang_name = 'neighbor'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__state = YANGDynClass(base=yc_state_openconfig_access_points__access_points_access_point_radios_radio_neighbors_neighbor_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=False)
    self.__bssid = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="bssid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='leafref', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'access-points', u'access-point', u'radios', u'radio', u'neighbors', u'neighbor']

  def _get_bssid(self):
    """
    Getter method for bssid, mapped from YANG variable /access_points/access_point/radios/radio/neighbors/neighbor/bssid (leafref)

    YANG Description: Reference to neighbor bssid.
    """
    return self.__bssid
      
  def _set_bssid(self, v, load=False):
    """
    Setter method for bssid, mapped from YANG variable /access_points/access_point/radios/radio/neighbors/neighbor/bssid (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bssid is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bssid() directly.

    YANG Description: Reference to neighbor bssid.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="bssid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='leafref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bssid must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="bssid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='leafref', is_config=False)""",
        })

    self.__bssid = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bssid(self):
    self.__bssid = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="bssid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='leafref', is_config=False)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /access_points/access_point/radios/radio/neighbors/neighbor/state (container)

    YANG Description: State container for RF neighbors.
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /access_points/access_point/radios/radio/neighbors/neighbor/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: State container for RF neighbors.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_access_points__access_points_access_point_radios_radio_neighbors_neighbor_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_access_points__access_points_access_point_radios_radio_neighbors_neighbor_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=False)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_access_points__access_points_access_point_radios_radio_neighbors_neighbor_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=False)

  bssid = __builtin__.property(_get_bssid)
  state = __builtin__.property(_get_state)


  _pyangbind_elements = OrderedDict([('bssid', bssid), ('state', state), ])


class yc_neighbors_openconfig_access_points__access_points_access_point_radios_radio_neighbors(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-access-points - based on the path /access-points/access-point/radios/radio/neighbors. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Top-level container for RF neighbors.
  """
  __slots__ = ('_path_helper', '_extmethods', '__neighbor',)

  _yang_name = 'neighbors'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__neighbor = YANGDynClass(base=YANGListType("bssid",yc_neighbor_openconfig_access_points__access_points_access_point_radios_radio_neighbors_neighbor, yang_name="neighbor", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='bssid', extensions=None), is_container='list', yang_name="neighbor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'access-points', u'access-point', u'radios', u'radio', u'neighbors']

  def _get_neighbor(self):
    """
    Getter method for neighbor, mapped from YANG variable /access_points/access_point/radios/radio/neighbors/neighbor (list)

    YANG Description: The mac address, or BSSID, of a neighbor, and
their corresponding RSSI.
    """
    return self.__neighbor
      
  def _set_neighbor(self, v, load=False):
    """
    Setter method for neighbor, mapped from YANG variable /access_points/access_point/radios/radio/neighbors/neighbor (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_neighbor is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_neighbor() directly.

    YANG Description: The mac address, or BSSID, of a neighbor, and
their corresponding RSSI.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("bssid",yc_neighbor_openconfig_access_points__access_points_access_point_radios_radio_neighbors_neighbor, yang_name="neighbor", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='bssid', extensions=None), is_container='list', yang_name="neighbor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """neighbor must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("bssid",yc_neighbor_openconfig_access_points__access_points_access_point_radios_radio_neighbors_neighbor, yang_name="neighbor", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='bssid', extensions=None), is_container='list', yang_name="neighbor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='list', is_config=True)""",
        })

    self.__neighbor = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_neighbor(self):
    self.__neighbor = YANGDynClass(base=YANGListType("bssid",yc_neighbor_openconfig_access_points__access_points_access_point_radios_radio_neighbors_neighbor, yang_name="neighbor", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='bssid', extensions=None), is_container='list', yang_name="neighbor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='list', is_config=True)

  neighbor = __builtin__.property(_get_neighbor, _set_neighbor)


  _pyangbind_elements = OrderedDict([('neighbor', neighbor), ])


class yc_radio_openconfig_access_points__access_points_access_point_radios_radio(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-access-points - based on the path /access-points/access-point/radios/radio. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The list of radios on the device.
  """
  __slots__ = ('_path_helper', '_extmethods', '__id','__config','__state','__neighbors',)

  _yang_name = 'radio'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__neighbors = YANGDynClass(base=yc_neighbors_openconfig_access_points__access_points_access_point_radios_radio_neighbors, is_container='container', yang_name="neighbors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)
    self.__state = YANGDynClass(base=yc_state_openconfig_access_points__access_points_access_point_radios_radio_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)
    self.__config = YANGDynClass(base=yc_config_openconfig_access_points__access_points_access_point_radios_radio_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='leafref', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'access-points', u'access-point', u'radios', u'radio']

  def _get_id(self):
    """
    Getter method for id, mapped from YANG variable /access_points/access_point/radios/radio/id (leafref)

    YANG Description: References the configured id of the radio
    """
    return self.__id
      
  def _set_id(self, v, load=False):
    """
    Setter method for id, mapped from YANG variable /access_points/access_point/radios/radio/id (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: References the configured id of the radio
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """id must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='leafref', is_config=True)""",
        })

    self.__id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_id(self):
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='leafref', is_config=True)


  def _get_config(self):
    """
    Getter method for config, mapped from YANG variable /access_points/access_point/radios/radio/config (container)

    YANG Description: Configurable items at the global, radio interface
level
    """
    return self.__config
      
  def _set_config(self, v, load=False):
    """
    Setter method for config, mapped from YANG variable /access_points/access_point/radios/radio/config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config() directly.

    YANG Description: Configurable items at the global, radio interface
level
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_config_openconfig_access_points__access_points_access_point_radios_radio_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_config_openconfig_access_points__access_points_access_point_radios_radio_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)""",
        })

    self.__config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config(self):
    self.__config = YANGDynClass(base=yc_config_openconfig_access_points__access_points_access_point_radios_radio_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /access_points/access_point/radios/radio/state (container)

    YANG Description: Operational state data at the global radio level
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /access_points/access_point/radios/radio/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: Operational state data at the global radio level
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_access_points__access_points_access_point_radios_radio_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_access_points__access_points_access_point_radios_radio_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_access_points__access_points_access_point_radios_radio_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)


  def _get_neighbors(self):
    """
    Getter method for neighbors, mapped from YANG variable /access_points/access_point/radios/radio/neighbors (container)

    YANG Description: Top-level container for RF neighbors.
    """
    return self.__neighbors
      
  def _set_neighbors(self, v, load=False):
    """
    Setter method for neighbors, mapped from YANG variable /access_points/access_point/radios/radio/neighbors (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_neighbors is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_neighbors() directly.

    YANG Description: Top-level container for RF neighbors.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_neighbors_openconfig_access_points__access_points_access_point_radios_radio_neighbors, is_container='container', yang_name="neighbors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """neighbors must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_neighbors_openconfig_access_points__access_points_access_point_radios_radio_neighbors, is_container='container', yang_name="neighbors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)""",
        })

    self.__neighbors = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_neighbors(self):
    self.__neighbors = YANGDynClass(base=yc_neighbors_openconfig_access_points__access_points_access_point_radios_radio_neighbors, is_container='container', yang_name="neighbors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)

  id = __builtin__.property(_get_id, _set_id)
  config = __builtin__.property(_get_config, _set_config)
  state = __builtin__.property(_get_state, _set_state)
  neighbors = __builtin__.property(_get_neighbors, _set_neighbors)


  _pyangbind_elements = OrderedDict([('id', id), ('config', config), ('state', state), ('neighbors', neighbors), ])


class yc_radios_openconfig_access_points__access_points_access_point_radios(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-access-points - based on the path /access-points/access-point/radios. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Top level container for radios, including configuration
and state data.
  """
  __slots__ = ('_path_helper', '_extmethods', '__radio',)

  _yang_name = 'radios'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__radio = YANGDynClass(base=YANGListType("id",yc_radio_openconfig_access_points__access_points_access_point_radios_radio, yang_name="radio", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="radio", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'access-points', u'access-point', u'radios']

  def _get_radio(self):
    """
    Getter method for radio, mapped from YANG variable /access_points/access_point/radios/radio (list)

    YANG Description: The list of radios on the device.
    """
    return self.__radio
      
  def _set_radio(self, v, load=False):
    """
    Setter method for radio, mapped from YANG variable /access_points/access_point/radios/radio (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_radio is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_radio() directly.

    YANG Description: The list of radios on the device.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("id",yc_radio_openconfig_access_points__access_points_access_point_radios_radio, yang_name="radio", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="radio", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """radio must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("id",yc_radio_openconfig_access_points__access_points_access_point_radios_radio, yang_name="radio", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="radio", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='list', is_config=True)""",
        })

    self.__radio = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_radio(self):
    self.__radio = YANGDynClass(base=YANGListType("id",yc_radio_openconfig_access_points__access_points_access_point_radios_radio, yang_name="radio", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="radio", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='list', is_config=True)

  radio = __builtin__.property(_get_radio, _set_radio)


  _pyangbind_elements = OrderedDict([('radio', radio), ])


class yc_config_openconfig_access_points__access_points_access_point_ssids_ssid_config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-access-points - based on the path /access-points/access-point/ssids/ssid/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configurable items at the global, ssid level
  """
  __slots__ = ('_path_helper', '_extmethods', '__name','__enabled','__hidden','__default_vlan','__vlan_list','__operating_frequency','__basic_data_rates','__supported_data_rates','__broadcast_filter','__multicast_filter','__ipv6_ndp_filter','__ipv6_ndp_filter_timer','__station_isolation','__opmode','__wpa2_psk','__server_group','__dva','__mobility_domain','__dhcp_required','__qbss_load','__advertise_apname','__csa','__ptk_timeout','__gtk_timeout','__dot11k','__okc',)

  _yang_name = 'config'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__operating_frequency = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'oc-wifi-types:FREQ_2GHZ': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:FREQ_5GHZ': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:FREQ_2_5_GHZ': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'FREQ_5GHZ': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'FREQ_2_5_GHZ': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'FREQ_2GHZ': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}},), is_leaf=True, yang_name="operating-frequency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='identityref', is_config=True)
    self.__enabled = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=True)
    self.__wpa2_psk = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'length': [u'8..63']}), is_leaf=True, yang_name="wpa2-psk", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='string', is_config=True)
    self.__dhcp_required = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="dhcp-required", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=True)
    self.__qbss_load = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="qbss-load", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=True)
    self.__server_group = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="server-group", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='string', is_config=True)
    self.__multicast_filter = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="multicast-filter", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=True)
    self.__basic_data_rates = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'RATE_6MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'RATE_11MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_1MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_2MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'RATE_5.5MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_12MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_48MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_11MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_24MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'RATE_12MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_54MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_6MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'RATE_18MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'RATE_1MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'RATE_54MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'RATE_24MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_36MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'RATE_36MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_9MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'RATE_9MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_5.5MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'RATE_2MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'RATE_48MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_18MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}},)), is_leaf=False, yang_name="basic-data-rates", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='identityref', is_config=True)
    self.__supported_data_rates = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'RATE_6MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'RATE_11MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_1MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_2MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'RATE_5.5MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_12MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_48MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_11MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_24MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'RATE_12MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_54MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_6MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'RATE_18MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'RATE_1MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'RATE_54MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'RATE_24MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_36MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'RATE_36MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_9MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'RATE_9MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_5.5MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'RATE_2MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'RATE_48MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_18MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}},)), is_leaf=False, yang_name="supported-data-rates", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='identityref', is_config=True)
    self.__csa = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="csa", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=True)
    self.__advertise_apname = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="advertise-apname", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=True)
    self.__mobility_domain = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="mobility-domain", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='string', is_config=True)
    self.__gtk_timeout = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="gtk-timeout", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint16', is_config=True)
    self.__opmode = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'WPA2_ENTERPRISE': {}, u'WPA2_PERSONAL': {}, u'OPEN': {}},), is_leaf=True, yang_name="opmode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='enumeration', is_config=True)
    self.__hidden = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="hidden", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=True)
    self.__ipv6_ndp_filter_timer = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="ipv6-ndp-filter-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint16', is_config=True)
    self.__dot11k = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="dot11k", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=True)
    self.__default_vlan = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={u'range': [u'1..4094']}), is_leaf=True, yang_name="default-vlan", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-vlan-types:vlan-id', is_config=True)
    self.__vlan_list = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={u'range': [u'1..4094']})), is_leaf=False, yang_name="vlan-list", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-vlan-types:vlan-id', is_config=True)
    self.__okc = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="okc", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=True)
    self.__station_isolation = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="station-isolation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=True)
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='string', is_config=True)
    self.__ptk_timeout = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="ptk-timeout", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint16', is_config=True)
    self.__broadcast_filter = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="broadcast-filter", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=True)
    self.__dva = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="dva", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=True)
    self.__ipv6_ndp_filter = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="ipv6-ndp-filter", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'access-points', u'access-point', u'ssids', u'ssid', u'config']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /access_points/access_point/ssids/ssid/config/name (string)

    YANG Description: The name of the SSID.
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /access_points/access_point/ssids/ssid/config/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: The name of the SSID.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='string', is_config=True)


  def _get_enabled(self):
    """
    Getter method for enabled, mapped from YANG variable /access_points/access_point/ssids/ssid/config/enabled (boolean)

    YANG Description: The desired operational state (up/down) of this SSID.
    """
    return self.__enabled
      
  def _set_enabled(self, v, load=False):
    """
    Setter method for enabled, mapped from YANG variable /access_points/access_point/ssids/ssid/config/enabled (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_enabled is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_enabled() directly.

    YANG Description: The desired operational state (up/down) of this SSID.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """enabled must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=True)""",
        })

    self.__enabled = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_enabled(self):
    self.__enabled = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=True)


  def _get_hidden(self):
    """
    Getter method for hidden, mapped from YANG variable /access_points/access_point/ssids/ssid/config/hidden (boolean)

    YANG Description: Whether this SSID IE is hidden within Beacons.
    """
    return self.__hidden
      
  def _set_hidden(self, v, load=False):
    """
    Setter method for hidden, mapped from YANG variable /access_points/access_point/ssids/ssid/config/hidden (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_hidden is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_hidden() directly.

    YANG Description: Whether this SSID IE is hidden within Beacons.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="hidden", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """hidden must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="hidden", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=True)""",
        })

    self.__hidden = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_hidden(self):
    self.__hidden = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="hidden", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=True)


  def _get_default_vlan(self):
    """
    Getter method for default_vlan, mapped from YANG variable /access_points/access_point/ssids/ssid/config/default_vlan (oc-vlan-types:vlan-id)

    YANG Description: Default VLAN tag used by the SSID. When unspecified, SSID
defaults to untagged. If DVA enabled and RADIUS returns a
VLAN not present in 'vlan-list', or RADIUS returns no VLAN
(Tunnel-Private-Group-Id), this VLAN will be used. If DVA
not enabled, all packets are tagged with this VLAN.
    """
    return self.__default_vlan
      
  def _set_default_vlan(self, v, load=False):
    """
    Setter method for default_vlan, mapped from YANG variable /access_points/access_point/ssids/ssid/config/default_vlan (oc-vlan-types:vlan-id)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_default_vlan is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_default_vlan() directly.

    YANG Description: Default VLAN tag used by the SSID. When unspecified, SSID
defaults to untagged. If DVA enabled and RADIUS returns a
VLAN not present in 'vlan-list', or RADIUS returns no VLAN
(Tunnel-Private-Group-Id), this VLAN will be used. If DVA
not enabled, all packets are tagged with this VLAN.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={u'range': [u'1..4094']}), is_leaf=True, yang_name="default-vlan", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-vlan-types:vlan-id', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """default_vlan must be of a type compatible with oc-vlan-types:vlan-id""",
          'defined-type': "oc-vlan-types:vlan-id",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={u'range': [u'1..4094']}), is_leaf=True, yang_name="default-vlan", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-vlan-types:vlan-id', is_config=True)""",
        })

    self.__default_vlan = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_default_vlan(self):
    self.__default_vlan = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={u'range': [u'1..4094']}), is_leaf=True, yang_name="default-vlan", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-vlan-types:vlan-id', is_config=True)


  def _get_vlan_list(self):
    """
    Getter method for vlan_list, mapped from YANG variable /access_points/access_point/ssids/ssid/config/vlan_list (oc-vlan-types:vlan-id)

    YANG Description: List of VLANs allowed on the SSID, if DVA is enabled. Note,
if DVA enabled and RADIUS returns no VLAN or a VLAN outside
of this list, the SSID will be tagged with the value of
vlan-id (or untagged if 'vlan-id' not configured).
    """
    return self.__vlan_list
      
  def _set_vlan_list(self, v, load=False):
    """
    Setter method for vlan_list, mapped from YANG variable /access_points/access_point/ssids/ssid/config/vlan_list (oc-vlan-types:vlan-id)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vlan_list is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vlan_list() directly.

    YANG Description: List of VLANs allowed on the SSID, if DVA is enabled. Note,
if DVA enabled and RADIUS returns no VLAN or a VLAN outside
of this list, the SSID will be tagged with the value of
vlan-id (or untagged if 'vlan-id' not configured).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={u'range': [u'1..4094']})), is_leaf=False, yang_name="vlan-list", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-vlan-types:vlan-id', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vlan_list must be of a type compatible with oc-vlan-types:vlan-id""",
          'defined-type': "oc-vlan-types:vlan-id",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={u'range': [u'1..4094']})), is_leaf=False, yang_name="vlan-list", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-vlan-types:vlan-id', is_config=True)""",
        })

    self.__vlan_list = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vlan_list(self):
    self.__vlan_list = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={u'range': [u'1..4094']})), is_leaf=False, yang_name="vlan-list", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-vlan-types:vlan-id', is_config=True)


  def _get_operating_frequency(self):
    """
    Getter method for operating_frequency, mapped from YANG variable /access_points/access_point/ssids/ssid/config/operating_frequency (identityref)

    YANG Description: Operating frequency of this SSID. When none specified, the
default is dual-band.
    """
    return self.__operating_frequency
      
  def _set_operating_frequency(self, v, load=False):
    """
    Setter method for operating_frequency, mapped from YANG variable /access_points/access_point/ssids/ssid/config/operating_frequency (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_operating_frequency is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_operating_frequency() directly.

    YANG Description: Operating frequency of this SSID. When none specified, the
default is dual-band.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'oc-wifi-types:FREQ_2GHZ': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:FREQ_5GHZ': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:FREQ_2_5_GHZ': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'FREQ_5GHZ': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'FREQ_2_5_GHZ': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'FREQ_2GHZ': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}},), is_leaf=True, yang_name="operating-frequency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='identityref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """operating_frequency must be of a type compatible with identityref""",
          'defined-type': "openconfig-access-points:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'oc-wifi-types:FREQ_2GHZ': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:FREQ_5GHZ': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:FREQ_2_5_GHZ': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'FREQ_5GHZ': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'FREQ_2_5_GHZ': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'FREQ_2GHZ': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}},), is_leaf=True, yang_name="operating-frequency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='identityref', is_config=True)""",
        })

    self.__operating_frequency = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_operating_frequency(self):
    self.__operating_frequency = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'oc-wifi-types:FREQ_2GHZ': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:FREQ_5GHZ': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:FREQ_2_5_GHZ': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'FREQ_5GHZ': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'FREQ_2_5_GHZ': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'FREQ_2GHZ': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}},), is_leaf=True, yang_name="operating-frequency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='identityref', is_config=True)


  def _get_basic_data_rates(self):
    """
    Getter method for basic_data_rates, mapped from YANG variable /access_points/access_point/ssids/ssid/config/basic_data_rates (identityref)

    YANG Description: Basic data-rates for the SSID.
    """
    return self.__basic_data_rates
      
  def _set_basic_data_rates(self, v, load=False):
    """
    Setter method for basic_data_rates, mapped from YANG variable /access_points/access_point/ssids/ssid/config/basic_data_rates (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_basic_data_rates is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_basic_data_rates() directly.

    YANG Description: Basic data-rates for the SSID.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'RATE_6MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'RATE_11MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_1MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_2MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'RATE_5.5MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_12MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_48MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_11MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_24MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'RATE_12MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_54MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_6MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'RATE_18MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'RATE_1MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'RATE_54MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'RATE_24MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_36MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'RATE_36MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_9MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'RATE_9MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_5.5MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'RATE_2MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'RATE_48MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_18MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}},)), is_leaf=False, yang_name="basic-data-rates", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='identityref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """basic_data_rates must be of a type compatible with identityref""",
          'defined-type': "openconfig-access-points:identityref",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'RATE_6MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'RATE_11MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_1MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_2MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'RATE_5.5MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_12MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_48MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_11MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_24MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'RATE_12MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_54MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_6MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'RATE_18MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'RATE_1MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'RATE_54MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'RATE_24MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_36MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'RATE_36MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_9MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'RATE_9MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_5.5MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'RATE_2MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'RATE_48MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_18MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}},)), is_leaf=False, yang_name="basic-data-rates", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='identityref', is_config=True)""",
        })

    self.__basic_data_rates = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_basic_data_rates(self):
    self.__basic_data_rates = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'RATE_6MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'RATE_11MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_1MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_2MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'RATE_5.5MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_12MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_48MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_11MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_24MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'RATE_12MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_54MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_6MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'RATE_18MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'RATE_1MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'RATE_54MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'RATE_24MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_36MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'RATE_36MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_9MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'RATE_9MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_5.5MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'RATE_2MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'RATE_48MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_18MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}},)), is_leaf=False, yang_name="basic-data-rates", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='identityref', is_config=True)


  def _get_supported_data_rates(self):
    """
    Getter method for supported_data_rates, mapped from YANG variable /access_points/access_point/ssids/ssid/config/supported_data_rates (identityref)

    YANG Description: Supported data-rates for the SSID. This list should be
mutually exclusive with basic-data-rates.
    """
    return self.__supported_data_rates
      
  def _set_supported_data_rates(self, v, load=False):
    """
    Setter method for supported_data_rates, mapped from YANG variable /access_points/access_point/ssids/ssid/config/supported_data_rates (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_supported_data_rates is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_supported_data_rates() directly.

    YANG Description: Supported data-rates for the SSID. This list should be
mutually exclusive with basic-data-rates.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'RATE_6MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'RATE_11MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_1MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_2MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'RATE_5.5MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_12MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_48MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_11MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_24MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'RATE_12MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_54MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_6MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'RATE_18MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'RATE_1MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'RATE_54MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'RATE_24MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_36MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'RATE_36MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_9MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'RATE_9MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_5.5MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'RATE_2MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'RATE_48MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_18MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}},)), is_leaf=False, yang_name="supported-data-rates", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='identityref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """supported_data_rates must be of a type compatible with identityref""",
          'defined-type': "openconfig-access-points:identityref",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'RATE_6MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'RATE_11MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_1MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_2MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'RATE_5.5MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_12MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_48MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_11MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_24MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'RATE_12MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_54MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_6MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'RATE_18MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'RATE_1MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'RATE_54MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'RATE_24MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_36MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'RATE_36MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_9MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'RATE_9MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_5.5MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'RATE_2MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'RATE_48MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_18MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}},)), is_leaf=False, yang_name="supported-data-rates", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='identityref', is_config=True)""",
        })

    self.__supported_data_rates = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_supported_data_rates(self):
    self.__supported_data_rates = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'RATE_6MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'RATE_11MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_1MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_2MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'RATE_5.5MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_12MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_48MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_11MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_24MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'RATE_12MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_54MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_6MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'RATE_18MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'RATE_1MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'RATE_54MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'RATE_24MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_36MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'RATE_36MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_9MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'RATE_9MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_5.5MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'RATE_2MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'RATE_48MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_18MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}},)), is_leaf=False, yang_name="supported-data-rates", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='identityref', is_config=True)


  def _get_broadcast_filter(self):
    """
    Getter method for broadcast_filter, mapped from YANG variable /access_points/access_point/ssids/ssid/config/broadcast_filter (boolean)

    YANG Description: Convert all downstream broadcast ARP to unicast
only if Station is associated to the AP. Drop packet
if Station is not associated to the AP. All other
broadcast, except DHCP, is dropped by the AP.

DHCP Offers/ACKs are converted to Unicast, over-the-air.
    """
    return self.__broadcast_filter
      
  def _set_broadcast_filter(self, v, load=False):
    """
    Setter method for broadcast_filter, mapped from YANG variable /access_points/access_point/ssids/ssid/config/broadcast_filter (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_broadcast_filter is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_broadcast_filter() directly.

    YANG Description: Convert all downstream broadcast ARP to unicast
only if Station is associated to the AP. Drop packet
if Station is not associated to the AP. All other
broadcast, except DHCP, is dropped by the AP.

DHCP Offers/ACKs are converted to Unicast, over-the-air.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="broadcast-filter", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """broadcast_filter must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="broadcast-filter", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=True)""",
        })

    self.__broadcast_filter = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_broadcast_filter(self):
    self.__broadcast_filter = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="broadcast-filter", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=True)


  def _get_multicast_filter(self):
    """
    Getter method for multicast_filter, mapped from YANG variable /access_points/access_point/ssids/ssid/config/multicast_filter (boolean)

    YANG Description: Drop all downstream Multicast packets.
    """
    return self.__multicast_filter
      
  def _set_multicast_filter(self, v, load=False):
    """
    Setter method for multicast_filter, mapped from YANG variable /access_points/access_point/ssids/ssid/config/multicast_filter (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_multicast_filter is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_multicast_filter() directly.

    YANG Description: Drop all downstream Multicast packets.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="multicast-filter", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """multicast_filter must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="multicast-filter", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=True)""",
        })

    self.__multicast_filter = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_multicast_filter(self):
    self.__multicast_filter = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="multicast-filter", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=True)


  def _get_ipv6_ndp_filter(self):
    """
    Getter method for ipv6_ndp_filter, mapped from YANG variable /access_points/access_point/ssids/ssid/config/ipv6_ndp_filter (boolean)

    YANG Description: Neighbor Advertisements will be cached at the AP (or WLC)
and unicast in response to Neighbor Solicitations.

Router Advertisements, in response to a Router Solicitation
are converted to Unicast for over-the-air transmission.
    """
    return self.__ipv6_ndp_filter
      
  def _set_ipv6_ndp_filter(self, v, load=False):
    """
    Setter method for ipv6_ndp_filter, mapped from YANG variable /access_points/access_point/ssids/ssid/config/ipv6_ndp_filter (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ipv6_ndp_filter is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ipv6_ndp_filter() directly.

    YANG Description: Neighbor Advertisements will be cached at the AP (or WLC)
and unicast in response to Neighbor Solicitations.

Router Advertisements, in response to a Router Solicitation
are converted to Unicast for over-the-air transmission.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="ipv6-ndp-filter", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ipv6_ndp_filter must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="ipv6-ndp-filter", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=True)""",
        })

    self.__ipv6_ndp_filter = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ipv6_ndp_filter(self):
    self.__ipv6_ndp_filter = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="ipv6-ndp-filter", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=True)


  def _get_ipv6_ndp_filter_timer(self):
    """
    Getter method for ipv6_ndp_filter_timer, mapped from YANG variable /access_points/access_point/ssids/ssid/config/ipv6_ndp_filter_timer (uint16)

    YANG Description: Time, in seconds, the ndp-filter will cache
Neighbor Advertisements (NA).
    """
    return self.__ipv6_ndp_filter_timer
      
  def _set_ipv6_ndp_filter_timer(self, v, load=False):
    """
    Setter method for ipv6_ndp_filter_timer, mapped from YANG variable /access_points/access_point/ssids/ssid/config/ipv6_ndp_filter_timer (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ipv6_ndp_filter_timer is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ipv6_ndp_filter_timer() directly.

    YANG Description: Time, in seconds, the ndp-filter will cache
Neighbor Advertisements (NA).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="ipv6-ndp-filter-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ipv6_ndp_filter_timer must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="ipv6-ndp-filter-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint16', is_config=True)""",
        })

    self.__ipv6_ndp_filter_timer = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ipv6_ndp_filter_timer(self):
    self.__ipv6_ndp_filter_timer = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="ipv6-ndp-filter-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint16', is_config=True)


  def _get_station_isolation(self):
    """
    Getter method for station_isolation, mapped from YANG variable /access_points/access_point/ssids/ssid/config/station_isolation (boolean)

    YANG Description: Block Station peer to peer communication.
    """
    return self.__station_isolation
      
  def _set_station_isolation(self, v, load=False):
    """
    Setter method for station_isolation, mapped from YANG variable /access_points/access_point/ssids/ssid/config/station_isolation (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_station_isolation is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_station_isolation() directly.

    YANG Description: Block Station peer to peer communication.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="station-isolation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """station_isolation must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="station-isolation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=True)""",
        })

    self.__station_isolation = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_station_isolation(self):
    self.__station_isolation = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="station-isolation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=True)


  def _get_opmode(self):
    """
    Getter method for opmode, mapped from YANG variable /access_points/access_point/ssids/ssid/config/opmode (enumeration)

    YANG Description: The type of Layer2 authentication in use.
    """
    return self.__opmode
      
  def _set_opmode(self, v, load=False):
    """
    Setter method for opmode, mapped from YANG variable /access_points/access_point/ssids/ssid/config/opmode (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_opmode is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_opmode() directly.

    YANG Description: The type of Layer2 authentication in use.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'WPA2_ENTERPRISE': {}, u'WPA2_PERSONAL': {}, u'OPEN': {}},), is_leaf=True, yang_name="opmode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """opmode must be of a type compatible with enumeration""",
          'defined-type': "openconfig-access-points:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'WPA2_ENTERPRISE': {}, u'WPA2_PERSONAL': {}, u'OPEN': {}},), is_leaf=True, yang_name="opmode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='enumeration', is_config=True)""",
        })

    self.__opmode = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_opmode(self):
    self.__opmode = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'WPA2_ENTERPRISE': {}, u'WPA2_PERSONAL': {}, u'OPEN': {}},), is_leaf=True, yang_name="opmode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='enumeration', is_config=True)


  def _get_wpa2_psk(self):
    """
    Getter method for wpa2_psk, mapped from YANG variable /access_points/access_point/ssids/ssid/config/wpa2_psk (string)

    YANG Description: The passphrase used on this WPA2-Personal SSID.
    """
    return self.__wpa2_psk
      
  def _set_wpa2_psk(self, v, load=False):
    """
    Setter method for wpa2_psk, mapped from YANG variable /access_points/access_point/ssids/ssid/config/wpa2_psk (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_wpa2_psk is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_wpa2_psk() directly.

    YANG Description: The passphrase used on this WPA2-Personal SSID.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'length': [u'8..63']}), is_leaf=True, yang_name="wpa2-psk", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """wpa2_psk must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'length': [u'8..63']}), is_leaf=True, yang_name="wpa2-psk", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='string', is_config=True)""",
        })

    self.__wpa2_psk = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_wpa2_psk(self):
    self.__wpa2_psk = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'length': [u'8..63']}), is_leaf=True, yang_name="wpa2-psk", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='string', is_config=True)


  def _get_server_group(self):
    """
    Getter method for server_group, mapped from YANG variable /access_points/access_point/ssids/ssid/config/server_group (string)

    YANG Description: Specifies the RADIUS server-group to be used,
as defined in the openconfig-aaa.yang model.

Including WPA2_PERSONAL as it can be accompained by MAB.
    """
    return self.__server_group
      
  def _set_server_group(self, v, load=False):
    """
    Setter method for server_group, mapped from YANG variable /access_points/access_point/ssids/ssid/config/server_group (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_server_group is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_server_group() directly.

    YANG Description: Specifies the RADIUS server-group to be used,
as defined in the openconfig-aaa.yang model.

Including WPA2_PERSONAL as it can be accompained by MAB.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="server-group", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """server_group must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="server-group", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='string', is_config=True)""",
        })

    self.__server_group = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_server_group(self):
    self.__server_group = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="server-group", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='string', is_config=True)


  def _get_dva(self):
    """
    Getter method for dva, mapped from YANG variable /access_points/access_point/ssids/ssid/config/dva (boolean)

    YANG Description: Enable/disable Dynamic VLAN Assignment,
using 'Tunnel-Private-Group-Id' RADIUS attribute.
    """
    return self.__dva
      
  def _set_dva(self, v, load=False):
    """
    Setter method for dva, mapped from YANG variable /access_points/access_point/ssids/ssid/config/dva (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dva is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dva() directly.

    YANG Description: Enable/disable Dynamic VLAN Assignment,
using 'Tunnel-Private-Group-Id' RADIUS attribute.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="dva", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dva must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="dva", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=True)""",
        })

    self.__dva = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dva(self):
    self.__dva = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="dva", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=True)


  def _get_mobility_domain(self):
    """
    Getter method for mobility_domain, mapped from YANG variable /access_points/access_point/ssids/ssid/config/mobility_domain (string)

    YANG Description: Specify the mobility domain where PMK-R0 distribution will
occur. Specifically, which APs will recieve PMK-R0 if using
802.11r (FT).
    """
    return self.__mobility_domain
      
  def _set_mobility_domain(self, v, load=False):
    """
    Setter method for mobility_domain, mapped from YANG variable /access_points/access_point/ssids/ssid/config/mobility_domain (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mobility_domain is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mobility_domain() directly.

    YANG Description: Specify the mobility domain where PMK-R0 distribution will
occur. Specifically, which APs will recieve PMK-R0 if using
802.11r (FT).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="mobility-domain", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mobility_domain must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="mobility-domain", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='string', is_config=True)""",
        })

    self.__mobility_domain = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mobility_domain(self):
    self.__mobility_domain = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="mobility-domain", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='string', is_config=True)


  def _get_dhcp_required(self):
    """
    Getter method for dhcp_required, mapped from YANG variable /access_points/access_point/ssids/ssid/config/dhcp_required (boolean)

    YANG Description: Allow a Station to access the network only if
a DHCP exchange has occurred.
    """
    return self.__dhcp_required
      
  def _set_dhcp_required(self, v, load=False):
    """
    Setter method for dhcp_required, mapped from YANG variable /access_points/access_point/ssids/ssid/config/dhcp_required (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dhcp_required is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dhcp_required() directly.

    YANG Description: Allow a Station to access the network only if
a DHCP exchange has occurred.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="dhcp-required", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dhcp_required must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="dhcp-required", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=True)""",
        })

    self.__dhcp_required = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dhcp_required(self):
    self.__dhcp_required = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="dhcp-required", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=True)


  def _get_qbss_load(self):
    """
    Getter method for qbss_load, mapped from YANG variable /access_points/access_point/ssids/ssid/config/qbss_load (boolean)

    YANG Description: Advertisement of the QBSS Load Information ELement.
    """
    return self.__qbss_load
      
  def _set_qbss_load(self, v, load=False):
    """
    Setter method for qbss_load, mapped from YANG variable /access_points/access_point/ssids/ssid/config/qbss_load (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_qbss_load is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_qbss_load() directly.

    YANG Description: Advertisement of the QBSS Load Information ELement.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="qbss-load", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """qbss_load must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="qbss-load", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=True)""",
        })

    self.__qbss_load = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_qbss_load(self):
    self.__qbss_load = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="qbss-load", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=True)


  def _get_advertise_apname(self):
    """
    Getter method for advertise_apname, mapped from YANG variable /access_points/access_point/ssids/ssid/config/advertise_apname (boolean)

    YANG Description: Advertise the AP hostname in Beacon and Probe Resp. frames.
    """
    return self.__advertise_apname
      
  def _set_advertise_apname(self, v, load=False):
    """
    Setter method for advertise_apname, mapped from YANG variable /access_points/access_point/ssids/ssid/config/advertise_apname (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_advertise_apname is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_advertise_apname() directly.

    YANG Description: Advertise the AP hostname in Beacon and Probe Resp. frames.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="advertise-apname", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """advertise_apname must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="advertise-apname", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=True)""",
        })

    self.__advertise_apname = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_advertise_apname(self):
    self.__advertise_apname = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="advertise-apname", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=True)


  def _get_csa(self):
    """
    Getter method for csa, mapped from YANG variable /access_points/access_point/ssids/ssid/config/csa (boolean)

    YANG Description: Enable/Disable 802.11h channel-switch-announcement.
    """
    return self.__csa
      
  def _set_csa(self, v, load=False):
    """
    Setter method for csa, mapped from YANG variable /access_points/access_point/ssids/ssid/config/csa (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_csa is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_csa() directly.

    YANG Description: Enable/Disable 802.11h channel-switch-announcement.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="csa", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """csa must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="csa", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=True)""",
        })

    self.__csa = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_csa(self):
    self.__csa = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="csa", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=True)


  def _get_ptk_timeout(self):
    """
    Getter method for ptk_timeout, mapped from YANG variable /access_points/access_point/ssids/ssid/config/ptk_timeout (uint16)

    YANG Description: Time, in seconds, for the Pairwise Transient Key.
    """
    return self.__ptk_timeout
      
  def _set_ptk_timeout(self, v, load=False):
    """
    Setter method for ptk_timeout, mapped from YANG variable /access_points/access_point/ssids/ssid/config/ptk_timeout (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ptk_timeout is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ptk_timeout() directly.

    YANG Description: Time, in seconds, for the Pairwise Transient Key.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="ptk-timeout", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ptk_timeout must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="ptk-timeout", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint16', is_config=True)""",
        })

    self.__ptk_timeout = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ptk_timeout(self):
    self.__ptk_timeout = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="ptk-timeout", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint16', is_config=True)


  def _get_gtk_timeout(self):
    """
    Getter method for gtk_timeout, mapped from YANG variable /access_points/access_point/ssids/ssid/config/gtk_timeout (uint16)

    YANG Description: TTL for the Group Temporal Key.
    """
    return self.__gtk_timeout
      
  def _set_gtk_timeout(self, v, load=False):
    """
    Setter method for gtk_timeout, mapped from YANG variable /access_points/access_point/ssids/ssid/config/gtk_timeout (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_gtk_timeout is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_gtk_timeout() directly.

    YANG Description: TTL for the Group Temporal Key.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="gtk-timeout", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """gtk_timeout must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="gtk-timeout", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint16', is_config=True)""",
        })

    self.__gtk_timeout = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_gtk_timeout(self):
    self.__gtk_timeout = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="gtk-timeout", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint16', is_config=True)


  def _get_dot11k(self):
    """
    Getter method for dot11k, mapped from YANG variable /access_points/access_point/ssids/ssid/config/dot11k (boolean)

    YANG Description: 802.11k neighbor-list enabled/disabled.
    """
    return self.__dot11k
      
  def _set_dot11k(self, v, load=False):
    """
    Setter method for dot11k, mapped from YANG variable /access_points/access_point/ssids/ssid/config/dot11k (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dot11k is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dot11k() directly.

    YANG Description: 802.11k neighbor-list enabled/disabled.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="dot11k", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dot11k must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="dot11k", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=True)""",
        })

    self.__dot11k = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dot11k(self):
    self.__dot11k = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="dot11k", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=True)


  def _get_okc(self):
    """
    Getter method for okc, mapped from YANG variable /access_points/access_point/ssids/ssid/config/okc (boolean)

    YANG Description: Enable/disable Opportunistic Key Caching.
    """
    return self.__okc
      
  def _set_okc(self, v, load=False):
    """
    Setter method for okc, mapped from YANG variable /access_points/access_point/ssids/ssid/config/okc (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_okc is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_okc() directly.

    YANG Description: Enable/disable Opportunistic Key Caching.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="okc", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """okc must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="okc", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=True)""",
        })

    self.__okc = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_okc(self):
    self.__okc = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="okc", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=True)

  name = __builtin__.property(_get_name, _set_name)
  enabled = __builtin__.property(_get_enabled, _set_enabled)
  hidden = __builtin__.property(_get_hidden, _set_hidden)
  default_vlan = __builtin__.property(_get_default_vlan, _set_default_vlan)
  vlan_list = __builtin__.property(_get_vlan_list, _set_vlan_list)
  operating_frequency = __builtin__.property(_get_operating_frequency, _set_operating_frequency)
  basic_data_rates = __builtin__.property(_get_basic_data_rates, _set_basic_data_rates)
  supported_data_rates = __builtin__.property(_get_supported_data_rates, _set_supported_data_rates)
  broadcast_filter = __builtin__.property(_get_broadcast_filter, _set_broadcast_filter)
  multicast_filter = __builtin__.property(_get_multicast_filter, _set_multicast_filter)
  ipv6_ndp_filter = __builtin__.property(_get_ipv6_ndp_filter, _set_ipv6_ndp_filter)
  ipv6_ndp_filter_timer = __builtin__.property(_get_ipv6_ndp_filter_timer, _set_ipv6_ndp_filter_timer)
  station_isolation = __builtin__.property(_get_station_isolation, _set_station_isolation)
  opmode = __builtin__.property(_get_opmode, _set_opmode)
  wpa2_psk = __builtin__.property(_get_wpa2_psk, _set_wpa2_psk)
  server_group = __builtin__.property(_get_server_group, _set_server_group)
  dva = __builtin__.property(_get_dva, _set_dva)
  mobility_domain = __builtin__.property(_get_mobility_domain, _set_mobility_domain)
  dhcp_required = __builtin__.property(_get_dhcp_required, _set_dhcp_required)
  qbss_load = __builtin__.property(_get_qbss_load, _set_qbss_load)
  advertise_apname = __builtin__.property(_get_advertise_apname, _set_advertise_apname)
  csa = __builtin__.property(_get_csa, _set_csa)
  ptk_timeout = __builtin__.property(_get_ptk_timeout, _set_ptk_timeout)
  gtk_timeout = __builtin__.property(_get_gtk_timeout, _set_gtk_timeout)
  dot11k = __builtin__.property(_get_dot11k, _set_dot11k)
  okc = __builtin__.property(_get_okc, _set_okc)


  _pyangbind_elements = OrderedDict([('name', name), ('enabled', enabled), ('hidden', hidden), ('default_vlan', default_vlan), ('vlan_list', vlan_list), ('operating_frequency', operating_frequency), ('basic_data_rates', basic_data_rates), ('supported_data_rates', supported_data_rates), ('broadcast_filter', broadcast_filter), ('multicast_filter', multicast_filter), ('ipv6_ndp_filter', ipv6_ndp_filter), ('ipv6_ndp_filter_timer', ipv6_ndp_filter_timer), ('station_isolation', station_isolation), ('opmode', opmode), ('wpa2_psk', wpa2_psk), ('server_group', server_group), ('dva', dva), ('mobility_domain', mobility_domain), ('dhcp_required', dhcp_required), ('qbss_load', qbss_load), ('advertise_apname', advertise_apname), ('csa', csa), ('ptk_timeout', ptk_timeout), ('gtk_timeout', gtk_timeout), ('dot11k', dot11k), ('okc', okc), ])


class yc_state_openconfig_access_points__access_points_access_point_ssids_ssid_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-access-points - based on the path /access-points/access-point/ssids/ssid/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Operational state data at the ssid level
  """
  __slots__ = ('_path_helper', '_extmethods', '__name','__enabled','__hidden','__default_vlan','__vlan_list','__operating_frequency','__basic_data_rates','__supported_data_rates','__broadcast_filter','__multicast_filter','__ipv6_ndp_filter','__ipv6_ndp_filter_timer','__station_isolation','__opmode','__wpa2_psk','__server_group','__dva','__mobility_domain','__dhcp_required','__qbss_load','__advertise_apname','__csa','__ptk_timeout','__gtk_timeout','__dot11k','__okc',)

  _yang_name = 'state'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__operating_frequency = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'oc-wifi-types:FREQ_2GHZ': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:FREQ_5GHZ': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:FREQ_2_5_GHZ': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'FREQ_5GHZ': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'FREQ_2_5_GHZ': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'FREQ_2GHZ': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}},), is_leaf=True, yang_name="operating-frequency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='identityref', is_config=False)
    self.__enabled = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=False)
    self.__wpa2_psk = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'length': [u'8..63']}), is_leaf=True, yang_name="wpa2-psk", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='string', is_config=False)
    self.__dhcp_required = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="dhcp-required", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=False)
    self.__qbss_load = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="qbss-load", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=False)
    self.__server_group = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="server-group", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='string', is_config=False)
    self.__multicast_filter = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="multicast-filter", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=False)
    self.__basic_data_rates = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'RATE_6MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'RATE_11MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_1MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_2MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'RATE_5.5MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_12MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_48MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_11MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_24MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'RATE_12MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_54MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_6MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'RATE_18MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'RATE_1MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'RATE_54MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'RATE_24MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_36MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'RATE_36MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_9MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'RATE_9MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_5.5MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'RATE_2MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'RATE_48MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_18MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}},)), is_leaf=False, yang_name="basic-data-rates", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='identityref', is_config=False)
    self.__supported_data_rates = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'RATE_6MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'RATE_11MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_1MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_2MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'RATE_5.5MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_12MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_48MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_11MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_24MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'RATE_12MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_54MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_6MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'RATE_18MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'RATE_1MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'RATE_54MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'RATE_24MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_36MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'RATE_36MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_9MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'RATE_9MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_5.5MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'RATE_2MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'RATE_48MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_18MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}},)), is_leaf=False, yang_name="supported-data-rates", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='identityref', is_config=False)
    self.__csa = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="csa", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=False)
    self.__advertise_apname = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="advertise-apname", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=False)
    self.__mobility_domain = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="mobility-domain", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='string', is_config=False)
    self.__gtk_timeout = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="gtk-timeout", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint16', is_config=False)
    self.__opmode = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'WPA2_ENTERPRISE': {}, u'WPA2_PERSONAL': {}, u'OPEN': {}},), is_leaf=True, yang_name="opmode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='enumeration', is_config=False)
    self.__hidden = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="hidden", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=False)
    self.__ipv6_ndp_filter_timer = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="ipv6-ndp-filter-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint16', is_config=False)
    self.__dot11k = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="dot11k", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=False)
    self.__default_vlan = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={u'range': [u'1..4094']}), is_leaf=True, yang_name="default-vlan", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-vlan-types:vlan-id', is_config=False)
    self.__vlan_list = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={u'range': [u'1..4094']})), is_leaf=False, yang_name="vlan-list", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-vlan-types:vlan-id', is_config=False)
    self.__okc = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="okc", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=False)
    self.__station_isolation = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="station-isolation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=False)
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='string', is_config=False)
    self.__ptk_timeout = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="ptk-timeout", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint16', is_config=False)
    self.__broadcast_filter = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="broadcast-filter", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=False)
    self.__dva = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="dva", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=False)
    self.__ipv6_ndp_filter = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="ipv6-ndp-filter", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'access-points', u'access-point', u'ssids', u'ssid', u'state']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /access_points/access_point/ssids/ssid/state/name (string)

    YANG Description: The name of the SSID.
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /access_points/access_point/ssids/ssid/state/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: The name of the SSID.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='string', is_config=False)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='string', is_config=False)


  def _get_enabled(self):
    """
    Getter method for enabled, mapped from YANG variable /access_points/access_point/ssids/ssid/state/enabled (boolean)

    YANG Description: The desired operational state (up/down) of this SSID.
    """
    return self.__enabled
      
  def _set_enabled(self, v, load=False):
    """
    Setter method for enabled, mapped from YANG variable /access_points/access_point/ssids/ssid/state/enabled (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_enabled is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_enabled() directly.

    YANG Description: The desired operational state (up/down) of this SSID.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """enabled must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=False)""",
        })

    self.__enabled = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_enabled(self):
    self.__enabled = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=False)


  def _get_hidden(self):
    """
    Getter method for hidden, mapped from YANG variable /access_points/access_point/ssids/ssid/state/hidden (boolean)

    YANG Description: Whether this SSID IE is hidden within Beacons.
    """
    return self.__hidden
      
  def _set_hidden(self, v, load=False):
    """
    Setter method for hidden, mapped from YANG variable /access_points/access_point/ssids/ssid/state/hidden (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_hidden is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_hidden() directly.

    YANG Description: Whether this SSID IE is hidden within Beacons.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="hidden", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """hidden must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="hidden", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=False)""",
        })

    self.__hidden = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_hidden(self):
    self.__hidden = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="hidden", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=False)


  def _get_default_vlan(self):
    """
    Getter method for default_vlan, mapped from YANG variable /access_points/access_point/ssids/ssid/state/default_vlan (oc-vlan-types:vlan-id)

    YANG Description: Default VLAN tag used by the SSID. When unspecified, SSID
defaults to untagged. If DVA enabled and RADIUS returns a
VLAN not present in 'vlan-list', or RADIUS returns no VLAN
(Tunnel-Private-Group-Id), this VLAN will be used. If DVA
not enabled, all packets are tagged with this VLAN.
    """
    return self.__default_vlan
      
  def _set_default_vlan(self, v, load=False):
    """
    Setter method for default_vlan, mapped from YANG variable /access_points/access_point/ssids/ssid/state/default_vlan (oc-vlan-types:vlan-id)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_default_vlan is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_default_vlan() directly.

    YANG Description: Default VLAN tag used by the SSID. When unspecified, SSID
defaults to untagged. If DVA enabled and RADIUS returns a
VLAN not present in 'vlan-list', or RADIUS returns no VLAN
(Tunnel-Private-Group-Id), this VLAN will be used. If DVA
not enabled, all packets are tagged with this VLAN.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={u'range': [u'1..4094']}), is_leaf=True, yang_name="default-vlan", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-vlan-types:vlan-id', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """default_vlan must be of a type compatible with oc-vlan-types:vlan-id""",
          'defined-type': "oc-vlan-types:vlan-id",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={u'range': [u'1..4094']}), is_leaf=True, yang_name="default-vlan", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-vlan-types:vlan-id', is_config=False)""",
        })

    self.__default_vlan = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_default_vlan(self):
    self.__default_vlan = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={u'range': [u'1..4094']}), is_leaf=True, yang_name="default-vlan", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-vlan-types:vlan-id', is_config=False)


  def _get_vlan_list(self):
    """
    Getter method for vlan_list, mapped from YANG variable /access_points/access_point/ssids/ssid/state/vlan_list (oc-vlan-types:vlan-id)

    YANG Description: List of VLANs allowed on the SSID, if DVA is enabled. Note,
if DVA enabled and RADIUS returns no VLAN or a VLAN outside
of this list, the SSID will be tagged with the value of
vlan-id (or untagged if 'vlan-id' not configured).
    """
    return self.__vlan_list
      
  def _set_vlan_list(self, v, load=False):
    """
    Setter method for vlan_list, mapped from YANG variable /access_points/access_point/ssids/ssid/state/vlan_list (oc-vlan-types:vlan-id)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vlan_list is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vlan_list() directly.

    YANG Description: List of VLANs allowed on the SSID, if DVA is enabled. Note,
if DVA enabled and RADIUS returns no VLAN or a VLAN outside
of this list, the SSID will be tagged with the value of
vlan-id (or untagged if 'vlan-id' not configured).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={u'range': [u'1..4094']})), is_leaf=False, yang_name="vlan-list", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-vlan-types:vlan-id', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vlan_list must be of a type compatible with oc-vlan-types:vlan-id""",
          'defined-type': "oc-vlan-types:vlan-id",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={u'range': [u'1..4094']})), is_leaf=False, yang_name="vlan-list", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-vlan-types:vlan-id', is_config=False)""",
        })

    self.__vlan_list = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vlan_list(self):
    self.__vlan_list = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={u'range': [u'1..4094']})), is_leaf=False, yang_name="vlan-list", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-vlan-types:vlan-id', is_config=False)


  def _get_operating_frequency(self):
    """
    Getter method for operating_frequency, mapped from YANG variable /access_points/access_point/ssids/ssid/state/operating_frequency (identityref)

    YANG Description: Operating frequency of this SSID. When none specified, the
default is dual-band.
    """
    return self.__operating_frequency
      
  def _set_operating_frequency(self, v, load=False):
    """
    Setter method for operating_frequency, mapped from YANG variable /access_points/access_point/ssids/ssid/state/operating_frequency (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_operating_frequency is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_operating_frequency() directly.

    YANG Description: Operating frequency of this SSID. When none specified, the
default is dual-band.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'oc-wifi-types:FREQ_2GHZ': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:FREQ_5GHZ': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:FREQ_2_5_GHZ': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'FREQ_5GHZ': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'FREQ_2_5_GHZ': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'FREQ_2GHZ': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}},), is_leaf=True, yang_name="operating-frequency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='identityref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """operating_frequency must be of a type compatible with identityref""",
          'defined-type': "openconfig-access-points:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'oc-wifi-types:FREQ_2GHZ': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:FREQ_5GHZ': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:FREQ_2_5_GHZ': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'FREQ_5GHZ': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'FREQ_2_5_GHZ': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'FREQ_2GHZ': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}},), is_leaf=True, yang_name="operating-frequency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='identityref', is_config=False)""",
        })

    self.__operating_frequency = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_operating_frequency(self):
    self.__operating_frequency = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'oc-wifi-types:FREQ_2GHZ': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:FREQ_5GHZ': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:FREQ_2_5_GHZ': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'FREQ_5GHZ': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'FREQ_2_5_GHZ': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'FREQ_2GHZ': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}},), is_leaf=True, yang_name="operating-frequency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='identityref', is_config=False)


  def _get_basic_data_rates(self):
    """
    Getter method for basic_data_rates, mapped from YANG variable /access_points/access_point/ssids/ssid/state/basic_data_rates (identityref)

    YANG Description: Basic data-rates for the SSID.
    """
    return self.__basic_data_rates
      
  def _set_basic_data_rates(self, v, load=False):
    """
    Setter method for basic_data_rates, mapped from YANG variable /access_points/access_point/ssids/ssid/state/basic_data_rates (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_basic_data_rates is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_basic_data_rates() directly.

    YANG Description: Basic data-rates for the SSID.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'RATE_6MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'RATE_11MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_1MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_2MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'RATE_5.5MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_12MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_48MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_11MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_24MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'RATE_12MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_54MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_6MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'RATE_18MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'RATE_1MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'RATE_54MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'RATE_24MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_36MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'RATE_36MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_9MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'RATE_9MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_5.5MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'RATE_2MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'RATE_48MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_18MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}},)), is_leaf=False, yang_name="basic-data-rates", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='identityref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """basic_data_rates must be of a type compatible with identityref""",
          'defined-type': "openconfig-access-points:identityref",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'RATE_6MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'RATE_11MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_1MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_2MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'RATE_5.5MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_12MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_48MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_11MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_24MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'RATE_12MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_54MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_6MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'RATE_18MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'RATE_1MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'RATE_54MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'RATE_24MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_36MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'RATE_36MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_9MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'RATE_9MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_5.5MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'RATE_2MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'RATE_48MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_18MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}},)), is_leaf=False, yang_name="basic-data-rates", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='identityref', is_config=False)""",
        })

    self.__basic_data_rates = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_basic_data_rates(self):
    self.__basic_data_rates = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'RATE_6MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'RATE_11MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_1MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_2MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'RATE_5.5MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_12MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_48MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_11MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_24MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'RATE_12MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_54MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_6MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'RATE_18MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'RATE_1MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'RATE_54MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'RATE_24MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_36MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'RATE_36MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_9MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'RATE_9MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_5.5MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'RATE_2MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'RATE_48MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_18MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}},)), is_leaf=False, yang_name="basic-data-rates", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='identityref', is_config=False)


  def _get_supported_data_rates(self):
    """
    Getter method for supported_data_rates, mapped from YANG variable /access_points/access_point/ssids/ssid/state/supported_data_rates (identityref)

    YANG Description: Supported data-rates for the SSID. This list should be
mutually exclusive with basic-data-rates.
    """
    return self.__supported_data_rates
      
  def _set_supported_data_rates(self, v, load=False):
    """
    Setter method for supported_data_rates, mapped from YANG variable /access_points/access_point/ssids/ssid/state/supported_data_rates (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_supported_data_rates is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_supported_data_rates() directly.

    YANG Description: Supported data-rates for the SSID. This list should be
mutually exclusive with basic-data-rates.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'RATE_6MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'RATE_11MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_1MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_2MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'RATE_5.5MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_12MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_48MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_11MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_24MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'RATE_12MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_54MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_6MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'RATE_18MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'RATE_1MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'RATE_54MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'RATE_24MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_36MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'RATE_36MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_9MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'RATE_9MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_5.5MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'RATE_2MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'RATE_48MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_18MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}},)), is_leaf=False, yang_name="supported-data-rates", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='identityref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """supported_data_rates must be of a type compatible with identityref""",
          'defined-type': "openconfig-access-points:identityref",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'RATE_6MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'RATE_11MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_1MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_2MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'RATE_5.5MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_12MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_48MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_11MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_24MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'RATE_12MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_54MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_6MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'RATE_18MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'RATE_1MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'RATE_54MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'RATE_24MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_36MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'RATE_36MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_9MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'RATE_9MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_5.5MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'RATE_2MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'RATE_48MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_18MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}},)), is_leaf=False, yang_name="supported-data-rates", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='identityref', is_config=False)""",
        })

    self.__supported_data_rates = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_supported_data_rates(self):
    self.__supported_data_rates = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'RATE_6MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'RATE_11MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_1MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_2MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'RATE_5.5MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_12MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_48MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_11MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_24MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'RATE_12MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_54MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_6MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'RATE_18MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'RATE_1MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'RATE_54MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'RATE_24MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_36MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'RATE_36MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_9MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'RATE_9MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_5.5MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'RATE_2MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'RATE_48MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_18MB': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}},)), is_leaf=False, yang_name="supported-data-rates", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='identityref', is_config=False)


  def _get_broadcast_filter(self):
    """
    Getter method for broadcast_filter, mapped from YANG variable /access_points/access_point/ssids/ssid/state/broadcast_filter (boolean)

    YANG Description: Convert all downstream broadcast ARP to unicast
only if Station is associated to the AP. Drop packet
if Station is not associated to the AP. All other
broadcast, except DHCP, is dropped by the AP.

DHCP Offers/ACKs are converted to Unicast, over-the-air.
    """
    return self.__broadcast_filter
      
  def _set_broadcast_filter(self, v, load=False):
    """
    Setter method for broadcast_filter, mapped from YANG variable /access_points/access_point/ssids/ssid/state/broadcast_filter (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_broadcast_filter is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_broadcast_filter() directly.

    YANG Description: Convert all downstream broadcast ARP to unicast
only if Station is associated to the AP. Drop packet
if Station is not associated to the AP. All other
broadcast, except DHCP, is dropped by the AP.

DHCP Offers/ACKs are converted to Unicast, over-the-air.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="broadcast-filter", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """broadcast_filter must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="broadcast-filter", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=False)""",
        })

    self.__broadcast_filter = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_broadcast_filter(self):
    self.__broadcast_filter = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="broadcast-filter", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=False)


  def _get_multicast_filter(self):
    """
    Getter method for multicast_filter, mapped from YANG variable /access_points/access_point/ssids/ssid/state/multicast_filter (boolean)

    YANG Description: Drop all downstream Multicast packets.
    """
    return self.__multicast_filter
      
  def _set_multicast_filter(self, v, load=False):
    """
    Setter method for multicast_filter, mapped from YANG variable /access_points/access_point/ssids/ssid/state/multicast_filter (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_multicast_filter is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_multicast_filter() directly.

    YANG Description: Drop all downstream Multicast packets.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="multicast-filter", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """multicast_filter must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="multicast-filter", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=False)""",
        })

    self.__multicast_filter = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_multicast_filter(self):
    self.__multicast_filter = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="multicast-filter", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=False)


  def _get_ipv6_ndp_filter(self):
    """
    Getter method for ipv6_ndp_filter, mapped from YANG variable /access_points/access_point/ssids/ssid/state/ipv6_ndp_filter (boolean)

    YANG Description: Neighbor Advertisements will be cached at the AP (or WLC)
and unicast in response to Neighbor Solicitations.

Router Advertisements, in response to a Router Solicitation
are converted to Unicast for over-the-air transmission.
    """
    return self.__ipv6_ndp_filter
      
  def _set_ipv6_ndp_filter(self, v, load=False):
    """
    Setter method for ipv6_ndp_filter, mapped from YANG variable /access_points/access_point/ssids/ssid/state/ipv6_ndp_filter (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ipv6_ndp_filter is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ipv6_ndp_filter() directly.

    YANG Description: Neighbor Advertisements will be cached at the AP (or WLC)
and unicast in response to Neighbor Solicitations.

Router Advertisements, in response to a Router Solicitation
are converted to Unicast for over-the-air transmission.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="ipv6-ndp-filter", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ipv6_ndp_filter must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="ipv6-ndp-filter", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=False)""",
        })

    self.__ipv6_ndp_filter = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ipv6_ndp_filter(self):
    self.__ipv6_ndp_filter = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="ipv6-ndp-filter", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=False)


  def _get_ipv6_ndp_filter_timer(self):
    """
    Getter method for ipv6_ndp_filter_timer, mapped from YANG variable /access_points/access_point/ssids/ssid/state/ipv6_ndp_filter_timer (uint16)

    YANG Description: Time, in seconds, the ndp-filter will cache
Neighbor Advertisements (NA).
    """
    return self.__ipv6_ndp_filter_timer
      
  def _set_ipv6_ndp_filter_timer(self, v, load=False):
    """
    Setter method for ipv6_ndp_filter_timer, mapped from YANG variable /access_points/access_point/ssids/ssid/state/ipv6_ndp_filter_timer (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ipv6_ndp_filter_timer is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ipv6_ndp_filter_timer() directly.

    YANG Description: Time, in seconds, the ndp-filter will cache
Neighbor Advertisements (NA).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="ipv6-ndp-filter-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint16', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ipv6_ndp_filter_timer must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="ipv6-ndp-filter-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint16', is_config=False)""",
        })

    self.__ipv6_ndp_filter_timer = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ipv6_ndp_filter_timer(self):
    self.__ipv6_ndp_filter_timer = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="ipv6-ndp-filter-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint16', is_config=False)


  def _get_station_isolation(self):
    """
    Getter method for station_isolation, mapped from YANG variable /access_points/access_point/ssids/ssid/state/station_isolation (boolean)

    YANG Description: Block Station peer to peer communication.
    """
    return self.__station_isolation
      
  def _set_station_isolation(self, v, load=False):
    """
    Setter method for station_isolation, mapped from YANG variable /access_points/access_point/ssids/ssid/state/station_isolation (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_station_isolation is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_station_isolation() directly.

    YANG Description: Block Station peer to peer communication.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="station-isolation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """station_isolation must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="station-isolation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=False)""",
        })

    self.__station_isolation = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_station_isolation(self):
    self.__station_isolation = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="station-isolation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=False)


  def _get_opmode(self):
    """
    Getter method for opmode, mapped from YANG variable /access_points/access_point/ssids/ssid/state/opmode (enumeration)

    YANG Description: The type of Layer2 authentication in use.
    """
    return self.__opmode
      
  def _set_opmode(self, v, load=False):
    """
    Setter method for opmode, mapped from YANG variable /access_points/access_point/ssids/ssid/state/opmode (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_opmode is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_opmode() directly.

    YANG Description: The type of Layer2 authentication in use.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'WPA2_ENTERPRISE': {}, u'WPA2_PERSONAL': {}, u'OPEN': {}},), is_leaf=True, yang_name="opmode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='enumeration', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """opmode must be of a type compatible with enumeration""",
          'defined-type': "openconfig-access-points:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'WPA2_ENTERPRISE': {}, u'WPA2_PERSONAL': {}, u'OPEN': {}},), is_leaf=True, yang_name="opmode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='enumeration', is_config=False)""",
        })

    self.__opmode = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_opmode(self):
    self.__opmode = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'WPA2_ENTERPRISE': {}, u'WPA2_PERSONAL': {}, u'OPEN': {}},), is_leaf=True, yang_name="opmode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='enumeration', is_config=False)


  def _get_wpa2_psk(self):
    """
    Getter method for wpa2_psk, mapped from YANG variable /access_points/access_point/ssids/ssid/state/wpa2_psk (string)

    YANG Description: The passphrase used on this WPA2-Personal SSID.
    """
    return self.__wpa2_psk
      
  def _set_wpa2_psk(self, v, load=False):
    """
    Setter method for wpa2_psk, mapped from YANG variable /access_points/access_point/ssids/ssid/state/wpa2_psk (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_wpa2_psk is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_wpa2_psk() directly.

    YANG Description: The passphrase used on this WPA2-Personal SSID.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'length': [u'8..63']}), is_leaf=True, yang_name="wpa2-psk", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """wpa2_psk must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'length': [u'8..63']}), is_leaf=True, yang_name="wpa2-psk", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='string', is_config=False)""",
        })

    self.__wpa2_psk = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_wpa2_psk(self):
    self.__wpa2_psk = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'length': [u'8..63']}), is_leaf=True, yang_name="wpa2-psk", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='string', is_config=False)


  def _get_server_group(self):
    """
    Getter method for server_group, mapped from YANG variable /access_points/access_point/ssids/ssid/state/server_group (string)

    YANG Description: Specifies the RADIUS server-group to be used,
as defined in the openconfig-aaa.yang model.

Including WPA2_PERSONAL as it can be accompained by MAB.
    """
    return self.__server_group
      
  def _set_server_group(self, v, load=False):
    """
    Setter method for server_group, mapped from YANG variable /access_points/access_point/ssids/ssid/state/server_group (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_server_group is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_server_group() directly.

    YANG Description: Specifies the RADIUS server-group to be used,
as defined in the openconfig-aaa.yang model.

Including WPA2_PERSONAL as it can be accompained by MAB.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="server-group", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """server_group must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="server-group", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='string', is_config=False)""",
        })

    self.__server_group = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_server_group(self):
    self.__server_group = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="server-group", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='string', is_config=False)


  def _get_dva(self):
    """
    Getter method for dva, mapped from YANG variable /access_points/access_point/ssids/ssid/state/dva (boolean)

    YANG Description: Enable/disable Dynamic VLAN Assignment,
using 'Tunnel-Private-Group-Id' RADIUS attribute.
    """
    return self.__dva
      
  def _set_dva(self, v, load=False):
    """
    Setter method for dva, mapped from YANG variable /access_points/access_point/ssids/ssid/state/dva (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dva is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dva() directly.

    YANG Description: Enable/disable Dynamic VLAN Assignment,
using 'Tunnel-Private-Group-Id' RADIUS attribute.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="dva", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dva must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="dva", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=False)""",
        })

    self.__dva = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dva(self):
    self.__dva = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="dva", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=False)


  def _get_mobility_domain(self):
    """
    Getter method for mobility_domain, mapped from YANG variable /access_points/access_point/ssids/ssid/state/mobility_domain (string)

    YANG Description: Specify the mobility domain where PMK-R0 distribution will
occur. Specifically, which APs will recieve PMK-R0 if using
802.11r (FT).
    """
    return self.__mobility_domain
      
  def _set_mobility_domain(self, v, load=False):
    """
    Setter method for mobility_domain, mapped from YANG variable /access_points/access_point/ssids/ssid/state/mobility_domain (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mobility_domain is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mobility_domain() directly.

    YANG Description: Specify the mobility domain where PMK-R0 distribution will
occur. Specifically, which APs will recieve PMK-R0 if using
802.11r (FT).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="mobility-domain", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mobility_domain must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="mobility-domain", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='string', is_config=False)""",
        })

    self.__mobility_domain = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mobility_domain(self):
    self.__mobility_domain = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="mobility-domain", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='string', is_config=False)


  def _get_dhcp_required(self):
    """
    Getter method for dhcp_required, mapped from YANG variable /access_points/access_point/ssids/ssid/state/dhcp_required (boolean)

    YANG Description: Allow a Station to access the network only if
a DHCP exchange has occurred.
    """
    return self.__dhcp_required
      
  def _set_dhcp_required(self, v, load=False):
    """
    Setter method for dhcp_required, mapped from YANG variable /access_points/access_point/ssids/ssid/state/dhcp_required (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dhcp_required is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dhcp_required() directly.

    YANG Description: Allow a Station to access the network only if
a DHCP exchange has occurred.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="dhcp-required", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dhcp_required must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="dhcp-required", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=False)""",
        })

    self.__dhcp_required = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dhcp_required(self):
    self.__dhcp_required = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="dhcp-required", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=False)


  def _get_qbss_load(self):
    """
    Getter method for qbss_load, mapped from YANG variable /access_points/access_point/ssids/ssid/state/qbss_load (boolean)

    YANG Description: Advertisement of the QBSS Load Information ELement.
    """
    return self.__qbss_load
      
  def _set_qbss_load(self, v, load=False):
    """
    Setter method for qbss_load, mapped from YANG variable /access_points/access_point/ssids/ssid/state/qbss_load (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_qbss_load is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_qbss_load() directly.

    YANG Description: Advertisement of the QBSS Load Information ELement.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="qbss-load", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """qbss_load must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="qbss-load", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=False)""",
        })

    self.__qbss_load = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_qbss_load(self):
    self.__qbss_load = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="qbss-load", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=False)


  def _get_advertise_apname(self):
    """
    Getter method for advertise_apname, mapped from YANG variable /access_points/access_point/ssids/ssid/state/advertise_apname (boolean)

    YANG Description: Advertise the AP hostname in Beacon and Probe Resp. frames.
    """
    return self.__advertise_apname
      
  def _set_advertise_apname(self, v, load=False):
    """
    Setter method for advertise_apname, mapped from YANG variable /access_points/access_point/ssids/ssid/state/advertise_apname (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_advertise_apname is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_advertise_apname() directly.

    YANG Description: Advertise the AP hostname in Beacon and Probe Resp. frames.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="advertise-apname", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """advertise_apname must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="advertise-apname", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=False)""",
        })

    self.__advertise_apname = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_advertise_apname(self):
    self.__advertise_apname = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="advertise-apname", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=False)


  def _get_csa(self):
    """
    Getter method for csa, mapped from YANG variable /access_points/access_point/ssids/ssid/state/csa (boolean)

    YANG Description: Enable/Disable 802.11h channel-switch-announcement.
    """
    return self.__csa
      
  def _set_csa(self, v, load=False):
    """
    Setter method for csa, mapped from YANG variable /access_points/access_point/ssids/ssid/state/csa (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_csa is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_csa() directly.

    YANG Description: Enable/Disable 802.11h channel-switch-announcement.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="csa", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """csa must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="csa", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=False)""",
        })

    self.__csa = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_csa(self):
    self.__csa = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="csa", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=False)


  def _get_ptk_timeout(self):
    """
    Getter method for ptk_timeout, mapped from YANG variable /access_points/access_point/ssids/ssid/state/ptk_timeout (uint16)

    YANG Description: Time, in seconds, for the Pairwise Transient Key.
    """
    return self.__ptk_timeout
      
  def _set_ptk_timeout(self, v, load=False):
    """
    Setter method for ptk_timeout, mapped from YANG variable /access_points/access_point/ssids/ssid/state/ptk_timeout (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ptk_timeout is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ptk_timeout() directly.

    YANG Description: Time, in seconds, for the Pairwise Transient Key.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="ptk-timeout", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint16', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ptk_timeout must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="ptk-timeout", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint16', is_config=False)""",
        })

    self.__ptk_timeout = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ptk_timeout(self):
    self.__ptk_timeout = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="ptk-timeout", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint16', is_config=False)


  def _get_gtk_timeout(self):
    """
    Getter method for gtk_timeout, mapped from YANG variable /access_points/access_point/ssids/ssid/state/gtk_timeout (uint16)

    YANG Description: TTL for the Group Temporal Key.
    """
    return self.__gtk_timeout
      
  def _set_gtk_timeout(self, v, load=False):
    """
    Setter method for gtk_timeout, mapped from YANG variable /access_points/access_point/ssids/ssid/state/gtk_timeout (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_gtk_timeout is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_gtk_timeout() directly.

    YANG Description: TTL for the Group Temporal Key.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="gtk-timeout", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint16', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """gtk_timeout must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="gtk-timeout", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint16', is_config=False)""",
        })

    self.__gtk_timeout = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_gtk_timeout(self):
    self.__gtk_timeout = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="gtk-timeout", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint16', is_config=False)


  def _get_dot11k(self):
    """
    Getter method for dot11k, mapped from YANG variable /access_points/access_point/ssids/ssid/state/dot11k (boolean)

    YANG Description: 802.11k neighbor-list enabled/disabled.
    """
    return self.__dot11k
      
  def _set_dot11k(self, v, load=False):
    """
    Setter method for dot11k, mapped from YANG variable /access_points/access_point/ssids/ssid/state/dot11k (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dot11k is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dot11k() directly.

    YANG Description: 802.11k neighbor-list enabled/disabled.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="dot11k", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dot11k must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="dot11k", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=False)""",
        })

    self.__dot11k = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dot11k(self):
    self.__dot11k = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="dot11k", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=False)


  def _get_okc(self):
    """
    Getter method for okc, mapped from YANG variable /access_points/access_point/ssids/ssid/state/okc (boolean)

    YANG Description: Enable/disable Opportunistic Key Caching.
    """
    return self.__okc
      
  def _set_okc(self, v, load=False):
    """
    Setter method for okc, mapped from YANG variable /access_points/access_point/ssids/ssid/state/okc (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_okc is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_okc() directly.

    YANG Description: Enable/disable Opportunistic Key Caching.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="okc", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """okc must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="okc", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=False)""",
        })

    self.__okc = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_okc(self):
    self.__okc = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="okc", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=False)

  name = __builtin__.property(_get_name)
  enabled = __builtin__.property(_get_enabled)
  hidden = __builtin__.property(_get_hidden)
  default_vlan = __builtin__.property(_get_default_vlan)
  vlan_list = __builtin__.property(_get_vlan_list)
  operating_frequency = __builtin__.property(_get_operating_frequency)
  basic_data_rates = __builtin__.property(_get_basic_data_rates)
  supported_data_rates = __builtin__.property(_get_supported_data_rates)
  broadcast_filter = __builtin__.property(_get_broadcast_filter)
  multicast_filter = __builtin__.property(_get_multicast_filter)
  ipv6_ndp_filter = __builtin__.property(_get_ipv6_ndp_filter)
  ipv6_ndp_filter_timer = __builtin__.property(_get_ipv6_ndp_filter_timer)
  station_isolation = __builtin__.property(_get_station_isolation)
  opmode = __builtin__.property(_get_opmode)
  wpa2_psk = __builtin__.property(_get_wpa2_psk)
  server_group = __builtin__.property(_get_server_group)
  dva = __builtin__.property(_get_dva)
  mobility_domain = __builtin__.property(_get_mobility_domain)
  dhcp_required = __builtin__.property(_get_dhcp_required)
  qbss_load = __builtin__.property(_get_qbss_load)
  advertise_apname = __builtin__.property(_get_advertise_apname)
  csa = __builtin__.property(_get_csa)
  ptk_timeout = __builtin__.property(_get_ptk_timeout)
  gtk_timeout = __builtin__.property(_get_gtk_timeout)
  dot11k = __builtin__.property(_get_dot11k)
  okc = __builtin__.property(_get_okc)


  _pyangbind_elements = OrderedDict([('name', name), ('enabled', enabled), ('hidden', hidden), ('default_vlan', default_vlan), ('vlan_list', vlan_list), ('operating_frequency', operating_frequency), ('basic_data_rates', basic_data_rates), ('supported_data_rates', supported_data_rates), ('broadcast_filter', broadcast_filter), ('multicast_filter', multicast_filter), ('ipv6_ndp_filter', ipv6_ndp_filter), ('ipv6_ndp_filter_timer', ipv6_ndp_filter_timer), ('station_isolation', station_isolation), ('opmode', opmode), ('wpa2_psk', wpa2_psk), ('server_group', server_group), ('dva', dva), ('mobility_domain', mobility_domain), ('dhcp_required', dhcp_required), ('qbss_load', qbss_load), ('advertise_apname', advertise_apname), ('csa', csa), ('ptk_timeout', ptk_timeout), ('gtk_timeout', gtk_timeout), ('dot11k', dot11k), ('okc', okc), ])


class yc_rx_data_dist_openconfig_access_points__access_points_access_point_ssids_ssid_bssids_bssid_state_counters_rx_data_dist(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-access-points - based on the path /access-points/access-point/ssids/ssid/bssids/bssid/state/counters/rx-data-dist. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The distribution of Data frame sizes in bytes of
successfully recieved AMPDU, or MPDU for non-aggregated,
frames. The distribution should characterize frame sizes
starting at 64 bytes or less with the bin size doubling for
each successive bin to a maximum of 1MB or larger, as
represented in the following table:

Lower Bound Upper Bound
  0          64
  65         128
  129        256
  257        512
  513        1024
  1025       2048
  2049       4096
  4097       8192
  8193       16384
  16385      32768
  32769      65536
  65537      131072
  131073     262144
  262145     524288
  524289     1048576
  """
  __slots__ = ('_path_helper', '_extmethods', '__rx_0_64','__rx_65_128','__rx_129_256','__rx_257_512','__rx_513_1024','__rx_1025_2048','__rx_2049_4096','__rx_4097_8192','__rx_8193_16384','__rx_16385_32768','__rx_32769_65536','__rx_65537_131072','__rx_131073_262144','__rx_262145_524288','__rx_524289_1048576',)

  _yang_name = 'rx-data-dist'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__rx_1025_2048 = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="rx-1025-2048", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)
    self.__rx_4097_8192 = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="rx-4097-8192", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)
    self.__rx_32769_65536 = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="rx-32769-65536", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)
    self.__rx_2049_4096 = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="rx-2049-4096", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)
    self.__rx_262145_524288 = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="rx-262145-524288", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)
    self.__rx_131073_262144 = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="rx-131073-262144", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)
    self.__rx_257_512 = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="rx-257-512", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)
    self.__rx_16385_32768 = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="rx-16385-32768", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)
    self.__rx_0_64 = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="rx-0-64", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)
    self.__rx_129_256 = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="rx-129-256", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)
    self.__rx_8193_16384 = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="rx-8193-16384", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)
    self.__rx_65_128 = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="rx-65-128", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)
    self.__rx_513_1024 = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="rx-513-1024", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)
    self.__rx_524289_1048576 = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="rx-524289-1048576", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)
    self.__rx_65537_131072 = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="rx-65537-131072", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'access-points', u'access-point', u'ssids', u'ssid', u'bssids', u'bssid', u'state', u'counters', u'rx-data-dist']

  def _get_rx_0_64(self):
    """
    Getter method for rx_0_64, mapped from YANG variable /access_points/access_point/ssids/ssid/bssids/bssid/state/counters/rx_data_dist/rx_0_64 (oc-yang:counter64)

    YANG Description: Transmitted AMPDU or MPDUs from 0 to 64 Bytes.
    """
    return self.__rx_0_64
      
  def _set_rx_0_64(self, v, load=False):
    """
    Setter method for rx_0_64, mapped from YANG variable /access_points/access_point/ssids/ssid/bssids/bssid/state/counters/rx_data_dist/rx_0_64 (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_rx_0_64 is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_rx_0_64() directly.

    YANG Description: Transmitted AMPDU or MPDUs from 0 to 64 Bytes.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="rx-0-64", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """rx_0_64 must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="rx-0-64", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__rx_0_64 = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_rx_0_64(self):
    self.__rx_0_64 = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="rx-0-64", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)


  def _get_rx_65_128(self):
    """
    Getter method for rx_65_128, mapped from YANG variable /access_points/access_point/ssids/ssid/bssids/bssid/state/counters/rx_data_dist/rx_65_128 (oc-yang:counter64)

    YANG Description: Transmitted AMPDU or MPDUs from 65 to 128 Bytes.
    """
    return self.__rx_65_128
      
  def _set_rx_65_128(self, v, load=False):
    """
    Setter method for rx_65_128, mapped from YANG variable /access_points/access_point/ssids/ssid/bssids/bssid/state/counters/rx_data_dist/rx_65_128 (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_rx_65_128 is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_rx_65_128() directly.

    YANG Description: Transmitted AMPDU or MPDUs from 65 to 128 Bytes.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="rx-65-128", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """rx_65_128 must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="rx-65-128", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__rx_65_128 = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_rx_65_128(self):
    self.__rx_65_128 = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="rx-65-128", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)


  def _get_rx_129_256(self):
    """
    Getter method for rx_129_256, mapped from YANG variable /access_points/access_point/ssids/ssid/bssids/bssid/state/counters/rx_data_dist/rx_129_256 (oc-yang:counter64)

    YANG Description: Transmitted AMPDU or MPDUs from 129 to 256 Bytes.
    """
    return self.__rx_129_256
      
  def _set_rx_129_256(self, v, load=False):
    """
    Setter method for rx_129_256, mapped from YANG variable /access_points/access_point/ssids/ssid/bssids/bssid/state/counters/rx_data_dist/rx_129_256 (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_rx_129_256 is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_rx_129_256() directly.

    YANG Description: Transmitted AMPDU or MPDUs from 129 to 256 Bytes.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="rx-129-256", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """rx_129_256 must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="rx-129-256", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__rx_129_256 = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_rx_129_256(self):
    self.__rx_129_256 = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="rx-129-256", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)


  def _get_rx_257_512(self):
    """
    Getter method for rx_257_512, mapped from YANG variable /access_points/access_point/ssids/ssid/bssids/bssid/state/counters/rx_data_dist/rx_257_512 (oc-yang:counter64)

    YANG Description: Transmitted AMPDU or MPDUs from 257 to 512 Bytes.
    """
    return self.__rx_257_512
      
  def _set_rx_257_512(self, v, load=False):
    """
    Setter method for rx_257_512, mapped from YANG variable /access_points/access_point/ssids/ssid/bssids/bssid/state/counters/rx_data_dist/rx_257_512 (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_rx_257_512 is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_rx_257_512() directly.

    YANG Description: Transmitted AMPDU or MPDUs from 257 to 512 Bytes.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="rx-257-512", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """rx_257_512 must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="rx-257-512", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__rx_257_512 = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_rx_257_512(self):
    self.__rx_257_512 = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="rx-257-512", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)


  def _get_rx_513_1024(self):
    """
    Getter method for rx_513_1024, mapped from YANG variable /access_points/access_point/ssids/ssid/bssids/bssid/state/counters/rx_data_dist/rx_513_1024 (oc-yang:counter64)

    YANG Description: Transmitted AMPDU or MPDUs from 513 to 1024 Bytes.
    """
    return self.__rx_513_1024
      
  def _set_rx_513_1024(self, v, load=False):
    """
    Setter method for rx_513_1024, mapped from YANG variable /access_points/access_point/ssids/ssid/bssids/bssid/state/counters/rx_data_dist/rx_513_1024 (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_rx_513_1024 is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_rx_513_1024() directly.

    YANG Description: Transmitted AMPDU or MPDUs from 513 to 1024 Bytes.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="rx-513-1024", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """rx_513_1024 must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="rx-513-1024", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__rx_513_1024 = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_rx_513_1024(self):
    self.__rx_513_1024 = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="rx-513-1024", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)


  def _get_rx_1025_2048(self):
    """
    Getter method for rx_1025_2048, mapped from YANG variable /access_points/access_point/ssids/ssid/bssids/bssid/state/counters/rx_data_dist/rx_1025_2048 (oc-yang:counter64)

    YANG Description: Transmitted AMPDU or MPDUs from 1025 to 2048 Bytes.
    """
    return self.__rx_1025_2048
      
  def _set_rx_1025_2048(self, v, load=False):
    """
    Setter method for rx_1025_2048, mapped from YANG variable /access_points/access_point/ssids/ssid/bssids/bssid/state/counters/rx_data_dist/rx_1025_2048 (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_rx_1025_2048 is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_rx_1025_2048() directly.

    YANG Description: Transmitted AMPDU or MPDUs from 1025 to 2048 Bytes.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="rx-1025-2048", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """rx_1025_2048 must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="rx-1025-2048", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__rx_1025_2048 = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_rx_1025_2048(self):
    self.__rx_1025_2048 = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="rx-1025-2048", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)


  def _get_rx_2049_4096(self):
    """
    Getter method for rx_2049_4096, mapped from YANG variable /access_points/access_point/ssids/ssid/bssids/bssid/state/counters/rx_data_dist/rx_2049_4096 (oc-yang:counter64)

    YANG Description: Transmitted AMPDU or MPDUs from 2049 to 4096 Bytes.
    """
    return self.__rx_2049_4096
      
  def _set_rx_2049_4096(self, v, load=False):
    """
    Setter method for rx_2049_4096, mapped from YANG variable /access_points/access_point/ssids/ssid/bssids/bssid/state/counters/rx_data_dist/rx_2049_4096 (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_rx_2049_4096 is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_rx_2049_4096() directly.

    YANG Description: Transmitted AMPDU or MPDUs from 2049 to 4096 Bytes.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="rx-2049-4096", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """rx_2049_4096 must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="rx-2049-4096", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__rx_2049_4096 = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_rx_2049_4096(self):
    self.__rx_2049_4096 = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="rx-2049-4096", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)


  def _get_rx_4097_8192(self):
    """
    Getter method for rx_4097_8192, mapped from YANG variable /access_points/access_point/ssids/ssid/bssids/bssid/state/counters/rx_data_dist/rx_4097_8192 (oc-yang:counter64)

    YANG Description: Transmitted AMPDU or MPDUs from 4097 to 8192 Bytes.
    """
    return self.__rx_4097_8192
      
  def _set_rx_4097_8192(self, v, load=False):
    """
    Setter method for rx_4097_8192, mapped from YANG variable /access_points/access_point/ssids/ssid/bssids/bssid/state/counters/rx_data_dist/rx_4097_8192 (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_rx_4097_8192 is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_rx_4097_8192() directly.

    YANG Description: Transmitted AMPDU or MPDUs from 4097 to 8192 Bytes.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="rx-4097-8192", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """rx_4097_8192 must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="rx-4097-8192", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__rx_4097_8192 = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_rx_4097_8192(self):
    self.__rx_4097_8192 = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="rx-4097-8192", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)


  def _get_rx_8193_16384(self):
    """
    Getter method for rx_8193_16384, mapped from YANG variable /access_points/access_point/ssids/ssid/bssids/bssid/state/counters/rx_data_dist/rx_8193_16384 (oc-yang:counter64)

    YANG Description: Transmitted AMPDU or MPDUs from 8193 to 16384 Bytes.
    """
    return self.__rx_8193_16384
      
  def _set_rx_8193_16384(self, v, load=False):
    """
    Setter method for rx_8193_16384, mapped from YANG variable /access_points/access_point/ssids/ssid/bssids/bssid/state/counters/rx_data_dist/rx_8193_16384 (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_rx_8193_16384 is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_rx_8193_16384() directly.

    YANG Description: Transmitted AMPDU or MPDUs from 8193 to 16384 Bytes.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="rx-8193-16384", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """rx_8193_16384 must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="rx-8193-16384", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__rx_8193_16384 = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_rx_8193_16384(self):
    self.__rx_8193_16384 = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="rx-8193-16384", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)


  def _get_rx_16385_32768(self):
    """
    Getter method for rx_16385_32768, mapped from YANG variable /access_points/access_point/ssids/ssid/bssids/bssid/state/counters/rx_data_dist/rx_16385_32768 (oc-yang:counter64)

    YANG Description: Transmitted AMPDU or MPDUs from 16385 to 32768 Bytes.
    """
    return self.__rx_16385_32768
      
  def _set_rx_16385_32768(self, v, load=False):
    """
    Setter method for rx_16385_32768, mapped from YANG variable /access_points/access_point/ssids/ssid/bssids/bssid/state/counters/rx_data_dist/rx_16385_32768 (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_rx_16385_32768 is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_rx_16385_32768() directly.

    YANG Description: Transmitted AMPDU or MPDUs from 16385 to 32768 Bytes.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="rx-16385-32768", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """rx_16385_32768 must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="rx-16385-32768", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__rx_16385_32768 = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_rx_16385_32768(self):
    self.__rx_16385_32768 = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="rx-16385-32768", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)


  def _get_rx_32769_65536(self):
    """
    Getter method for rx_32769_65536, mapped from YANG variable /access_points/access_point/ssids/ssid/bssids/bssid/state/counters/rx_data_dist/rx_32769_65536 (oc-yang:counter64)

    YANG Description: Transmitted AMPDU or MPDUs from 32769 to 65536 Bytes.
    """
    return self.__rx_32769_65536
      
  def _set_rx_32769_65536(self, v, load=False):
    """
    Setter method for rx_32769_65536, mapped from YANG variable /access_points/access_point/ssids/ssid/bssids/bssid/state/counters/rx_data_dist/rx_32769_65536 (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_rx_32769_65536 is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_rx_32769_65536() directly.

    YANG Description: Transmitted AMPDU or MPDUs from 32769 to 65536 Bytes.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="rx-32769-65536", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """rx_32769_65536 must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="rx-32769-65536", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__rx_32769_65536 = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_rx_32769_65536(self):
    self.__rx_32769_65536 = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="rx-32769-65536", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)


  def _get_rx_65537_131072(self):
    """
    Getter method for rx_65537_131072, mapped from YANG variable /access_points/access_point/ssids/ssid/bssids/bssid/state/counters/rx_data_dist/rx_65537_131072 (oc-yang:counter64)

    YANG Description: Transmitted AMPDU from 65537 to 131072 Bytes.
    """
    return self.__rx_65537_131072
      
  def _set_rx_65537_131072(self, v, load=False):
    """
    Setter method for rx_65537_131072, mapped from YANG variable /access_points/access_point/ssids/ssid/bssids/bssid/state/counters/rx_data_dist/rx_65537_131072 (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_rx_65537_131072 is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_rx_65537_131072() directly.

    YANG Description: Transmitted AMPDU from 65537 to 131072 Bytes.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="rx-65537-131072", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """rx_65537_131072 must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="rx-65537-131072", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__rx_65537_131072 = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_rx_65537_131072(self):
    self.__rx_65537_131072 = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="rx-65537-131072", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)


  def _get_rx_131073_262144(self):
    """
    Getter method for rx_131073_262144, mapped from YANG variable /access_points/access_point/ssids/ssid/bssids/bssid/state/counters/rx_data_dist/rx_131073_262144 (oc-yang:counter64)

    YANG Description: Transmitted AMPDU from 131073 to 262144 Bytes.
    """
    return self.__rx_131073_262144
      
  def _set_rx_131073_262144(self, v, load=False):
    """
    Setter method for rx_131073_262144, mapped from YANG variable /access_points/access_point/ssids/ssid/bssids/bssid/state/counters/rx_data_dist/rx_131073_262144 (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_rx_131073_262144 is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_rx_131073_262144() directly.

    YANG Description: Transmitted AMPDU from 131073 to 262144 Bytes.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="rx-131073-262144", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """rx_131073_262144 must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="rx-131073-262144", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__rx_131073_262144 = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_rx_131073_262144(self):
    self.__rx_131073_262144 = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="rx-131073-262144", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)


  def _get_rx_262145_524288(self):
    """
    Getter method for rx_262145_524288, mapped from YANG variable /access_points/access_point/ssids/ssid/bssids/bssid/state/counters/rx_data_dist/rx_262145_524288 (oc-yang:counter64)

    YANG Description: Transmitted AMPDU from 262145 to 524288 Bytes.
    """
    return self.__rx_262145_524288
      
  def _set_rx_262145_524288(self, v, load=False):
    """
    Setter method for rx_262145_524288, mapped from YANG variable /access_points/access_point/ssids/ssid/bssids/bssid/state/counters/rx_data_dist/rx_262145_524288 (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_rx_262145_524288 is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_rx_262145_524288() directly.

    YANG Description: Transmitted AMPDU from 262145 to 524288 Bytes.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="rx-262145-524288", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """rx_262145_524288 must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="rx-262145-524288", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__rx_262145_524288 = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_rx_262145_524288(self):
    self.__rx_262145_524288 = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="rx-262145-524288", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)


  def _get_rx_524289_1048576(self):
    """
    Getter method for rx_524289_1048576, mapped from YANG variable /access_points/access_point/ssids/ssid/bssids/bssid/state/counters/rx_data_dist/rx_524289_1048576 (oc-yang:counter64)

    YANG Description: Transmitted AMPDU from 524289 to 1048576 Bytes.
    """
    return self.__rx_524289_1048576
      
  def _set_rx_524289_1048576(self, v, load=False):
    """
    Setter method for rx_524289_1048576, mapped from YANG variable /access_points/access_point/ssids/ssid/bssids/bssid/state/counters/rx_data_dist/rx_524289_1048576 (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_rx_524289_1048576 is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_rx_524289_1048576() directly.

    YANG Description: Transmitted AMPDU from 524289 to 1048576 Bytes.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="rx-524289-1048576", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """rx_524289_1048576 must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="rx-524289-1048576", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__rx_524289_1048576 = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_rx_524289_1048576(self):
    self.__rx_524289_1048576 = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="rx-524289-1048576", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)

  rx_0_64 = __builtin__.property(_get_rx_0_64)
  rx_65_128 = __builtin__.property(_get_rx_65_128)
  rx_129_256 = __builtin__.property(_get_rx_129_256)
  rx_257_512 = __builtin__.property(_get_rx_257_512)
  rx_513_1024 = __builtin__.property(_get_rx_513_1024)
  rx_1025_2048 = __builtin__.property(_get_rx_1025_2048)
  rx_2049_4096 = __builtin__.property(_get_rx_2049_4096)
  rx_4097_8192 = __builtin__.property(_get_rx_4097_8192)
  rx_8193_16384 = __builtin__.property(_get_rx_8193_16384)
  rx_16385_32768 = __builtin__.property(_get_rx_16385_32768)
  rx_32769_65536 = __builtin__.property(_get_rx_32769_65536)
  rx_65537_131072 = __builtin__.property(_get_rx_65537_131072)
  rx_131073_262144 = __builtin__.property(_get_rx_131073_262144)
  rx_262145_524288 = __builtin__.property(_get_rx_262145_524288)
  rx_524289_1048576 = __builtin__.property(_get_rx_524289_1048576)


  _pyangbind_elements = OrderedDict([('rx_0_64', rx_0_64), ('rx_65_128', rx_65_128), ('rx_129_256', rx_129_256), ('rx_257_512', rx_257_512), ('rx_513_1024', rx_513_1024), ('rx_1025_2048', rx_1025_2048), ('rx_2049_4096', rx_2049_4096), ('rx_4097_8192', rx_4097_8192), ('rx_8193_16384', rx_8193_16384), ('rx_16385_32768', rx_16385_32768), ('rx_32769_65536', rx_32769_65536), ('rx_65537_131072', rx_65537_131072), ('rx_131073_262144', rx_131073_262144), ('rx_262145_524288', rx_262145_524288), ('rx_524289_1048576', rx_524289_1048576), ])


class yc_rx_data_wmm_openconfig_access_points__access_points_access_point_ssids_ssid_bssids_bssid_state_counters_rx_data_wmm(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-access-points - based on the path /access-points/access-point/ssids/ssid/bssids/bssid/state/counters/rx-data-wmm. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Received 802.11 Data frames, per WMM Access Category.
  """
  __slots__ = ('_path_helper', '_extmethods', '__vi','__vo','__be','__bk',)

  _yang_name = 'rx-data-wmm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__vi = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="vi", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)
    self.__be = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="be", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)
    self.__bk = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="bk", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)
    self.__vo = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="vo", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'access-points', u'access-point', u'ssids', u'ssid', u'bssids', u'bssid', u'state', u'counters', u'rx-data-wmm']

  def _get_vi(self):
    """
    Getter method for vi, mapped from YANG variable /access_points/access_point/ssids/ssid/bssids/bssid/state/counters/rx_data_wmm/vi (oc-yang:counter64)

    YANG Description: Rx Data frames marked as Access Category Video.
    """
    return self.__vi
      
  def _set_vi(self, v, load=False):
    """
    Setter method for vi, mapped from YANG variable /access_points/access_point/ssids/ssid/bssids/bssid/state/counters/rx_data_wmm/vi (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vi is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vi() directly.

    YANG Description: Rx Data frames marked as Access Category Video.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="vi", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vi must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="vi", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__vi = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vi(self):
    self.__vi = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="vi", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)


  def _get_vo(self):
    """
    Getter method for vo, mapped from YANG variable /access_points/access_point/ssids/ssid/bssids/bssid/state/counters/rx_data_wmm/vo (oc-yang:counter64)

    YANG Description: Rx Data frames marked as Access Category Voice.
    """
    return self.__vo
      
  def _set_vo(self, v, load=False):
    """
    Setter method for vo, mapped from YANG variable /access_points/access_point/ssids/ssid/bssids/bssid/state/counters/rx_data_wmm/vo (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vo is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vo() directly.

    YANG Description: Rx Data frames marked as Access Category Voice.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="vo", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vo must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="vo", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__vo = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vo(self):
    self.__vo = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="vo", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)


  def _get_be(self):
    """
    Getter method for be, mapped from YANG variable /access_points/access_point/ssids/ssid/bssids/bssid/state/counters/rx_data_wmm/be (oc-yang:counter64)

    YANG Description: Rx Data frames marked as Access Category Best Effort.
    """
    return self.__be
      
  def _set_be(self, v, load=False):
    """
    Setter method for be, mapped from YANG variable /access_points/access_point/ssids/ssid/bssids/bssid/state/counters/rx_data_wmm/be (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_be is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_be() directly.

    YANG Description: Rx Data frames marked as Access Category Best Effort.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="be", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """be must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="be", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__be = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_be(self):
    self.__be = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="be", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)


  def _get_bk(self):
    """
    Getter method for bk, mapped from YANG variable /access_points/access_point/ssids/ssid/bssids/bssid/state/counters/rx_data_wmm/bk (oc-yang:counter64)

    YANG Description: Rx Data frames marked as Access Category Background.
    """
    return self.__bk
      
  def _set_bk(self, v, load=False):
    """
    Setter method for bk, mapped from YANG variable /access_points/access_point/ssids/ssid/bssids/bssid/state/counters/rx_data_wmm/bk (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bk is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bk() directly.

    YANG Description: Rx Data frames marked as Access Category Background.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="bk", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bk must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="bk", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__bk = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bk(self):
    self.__bk = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="bk", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)

  vi = __builtin__.property(_get_vi)
  vo = __builtin__.property(_get_vo)
  be = __builtin__.property(_get_be)
  bk = __builtin__.property(_get_bk)


  _pyangbind_elements = OrderedDict([('vi', vi), ('vo', vo), ('be', be), ('bk', bk), ])


class yc_rx_mcs_openconfig_access_points__access_points_access_point_ssids_ssid_bssids_bssid_state_counters_rx_mcs(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-access-points - based on the path /access-points/access-point/ssids/ssid/bssids/bssid/state/counters/rx-mcs. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Received Data frames, per MCS Index. It is expected that
vendors bucketize 802.11n MCS frames in their matching
802.11ac buckets.

Example, 802.11n MCS 15 = 802.11ac MCS 7.
802.11n MCS 20 = 802.11ac MCS 4.
  """
  __slots__ = ('_path_helper', '_extmethods', '__mcs0','__mcs1','__mcs2','__mcs3','__mcs4','__mcs5','__mcs6','__mcs7','__mcs8','__mcs9',)

  _yang_name = 'rx-mcs'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__mcs9 = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="mcs9", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)
    self.__mcs8 = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="mcs8", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)
    self.__mcs1 = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="mcs1", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)
    self.__mcs0 = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="mcs0", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)
    self.__mcs3 = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="mcs3", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)
    self.__mcs2 = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="mcs2", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)
    self.__mcs5 = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="mcs5", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)
    self.__mcs4 = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="mcs4", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)
    self.__mcs7 = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="mcs7", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)
    self.__mcs6 = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="mcs6", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'access-points', u'access-point', u'ssids', u'ssid', u'bssids', u'bssid', u'state', u'counters', u'rx-mcs']

  def _get_mcs0(self):
    """
    Getter method for mcs0, mapped from YANG variable /access_points/access_point/ssids/ssid/bssids/bssid/state/counters/rx_mcs/mcs0 (oc-yang:counter64)

    YANG Description: Rx Data frames at MCS 0.
    """
    return self.__mcs0
      
  def _set_mcs0(self, v, load=False):
    """
    Setter method for mcs0, mapped from YANG variable /access_points/access_point/ssids/ssid/bssids/bssid/state/counters/rx_mcs/mcs0 (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mcs0 is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mcs0() directly.

    YANG Description: Rx Data frames at MCS 0.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="mcs0", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mcs0 must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="mcs0", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__mcs0 = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mcs0(self):
    self.__mcs0 = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="mcs0", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)


  def _get_mcs1(self):
    """
    Getter method for mcs1, mapped from YANG variable /access_points/access_point/ssids/ssid/bssids/bssid/state/counters/rx_mcs/mcs1 (oc-yang:counter64)

    YANG Description: Rx Data frames at MCS 1.
    """
    return self.__mcs1
      
  def _set_mcs1(self, v, load=False):
    """
    Setter method for mcs1, mapped from YANG variable /access_points/access_point/ssids/ssid/bssids/bssid/state/counters/rx_mcs/mcs1 (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mcs1 is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mcs1() directly.

    YANG Description: Rx Data frames at MCS 1.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="mcs1", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mcs1 must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="mcs1", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__mcs1 = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mcs1(self):
    self.__mcs1 = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="mcs1", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)


  def _get_mcs2(self):
    """
    Getter method for mcs2, mapped from YANG variable /access_points/access_point/ssids/ssid/bssids/bssid/state/counters/rx_mcs/mcs2 (oc-yang:counter64)

    YANG Description: Rx Data frames at MCS 2.
    """
    return self.__mcs2
      
  def _set_mcs2(self, v, load=False):
    """
    Setter method for mcs2, mapped from YANG variable /access_points/access_point/ssids/ssid/bssids/bssid/state/counters/rx_mcs/mcs2 (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mcs2 is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mcs2() directly.

    YANG Description: Rx Data frames at MCS 2.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="mcs2", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mcs2 must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="mcs2", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__mcs2 = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mcs2(self):
    self.__mcs2 = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="mcs2", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)


  def _get_mcs3(self):
    """
    Getter method for mcs3, mapped from YANG variable /access_points/access_point/ssids/ssid/bssids/bssid/state/counters/rx_mcs/mcs3 (oc-yang:counter64)

    YANG Description: Rx Data frames at MCS 3.
    """
    return self.__mcs3
      
  def _set_mcs3(self, v, load=False):
    """
    Setter method for mcs3, mapped from YANG variable /access_points/access_point/ssids/ssid/bssids/bssid/state/counters/rx_mcs/mcs3 (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mcs3 is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mcs3() directly.

    YANG Description: Rx Data frames at MCS 3.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="mcs3", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mcs3 must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="mcs3", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__mcs3 = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mcs3(self):
    self.__mcs3 = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="mcs3", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)


  def _get_mcs4(self):
    """
    Getter method for mcs4, mapped from YANG variable /access_points/access_point/ssids/ssid/bssids/bssid/state/counters/rx_mcs/mcs4 (oc-yang:counter64)

    YANG Description: Rx Data frames at MCS 4.
    """
    return self.__mcs4
      
  def _set_mcs4(self, v, load=False):
    """
    Setter method for mcs4, mapped from YANG variable /access_points/access_point/ssids/ssid/bssids/bssid/state/counters/rx_mcs/mcs4 (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mcs4 is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mcs4() directly.

    YANG Description: Rx Data frames at MCS 4.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="mcs4", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mcs4 must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="mcs4", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__mcs4 = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mcs4(self):
    self.__mcs4 = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="mcs4", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)


  def _get_mcs5(self):
    """
    Getter method for mcs5, mapped from YANG variable /access_points/access_point/ssids/ssid/bssids/bssid/state/counters/rx_mcs/mcs5 (oc-yang:counter64)

    YANG Description: Rx Data frames at MCS 5.
    """
    return self.__mcs5
      
  def _set_mcs5(self, v, load=False):
    """
    Setter method for mcs5, mapped from YANG variable /access_points/access_point/ssids/ssid/bssids/bssid/state/counters/rx_mcs/mcs5 (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mcs5 is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mcs5() directly.

    YANG Description: Rx Data frames at MCS 5.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="mcs5", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mcs5 must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="mcs5", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__mcs5 = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mcs5(self):
    self.__mcs5 = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="mcs5", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)


  def _get_mcs6(self):
    """
    Getter method for mcs6, mapped from YANG variable /access_points/access_point/ssids/ssid/bssids/bssid/state/counters/rx_mcs/mcs6 (oc-yang:counter64)

    YANG Description: Rx Data frames at MCS 6.
    """
    return self.__mcs6
      
  def _set_mcs6(self, v, load=False):
    """
    Setter method for mcs6, mapped from YANG variable /access_points/access_point/ssids/ssid/bssids/bssid/state/counters/rx_mcs/mcs6 (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mcs6 is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mcs6() directly.

    YANG Description: Rx Data frames at MCS 6.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="mcs6", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mcs6 must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="mcs6", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__mcs6 = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mcs6(self):
    self.__mcs6 = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="mcs6", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)


  def _get_mcs7(self):
    """
    Getter method for mcs7, mapped from YANG variable /access_points/access_point/ssids/ssid/bssids/bssid/state/counters/rx_mcs/mcs7 (oc-yang:counter64)

    YANG Description: Rx Data frames at MCS 7.
    """
    return self.__mcs7
      
  def _set_mcs7(self, v, load=False):
    """
    Setter method for mcs7, mapped from YANG variable /access_points/access_point/ssids/ssid/bssids/bssid/state/counters/rx_mcs/mcs7 (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mcs7 is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mcs7() directly.

    YANG Description: Rx Data frames at MCS 7.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="mcs7", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mcs7 must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="mcs7", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__mcs7 = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mcs7(self):
    self.__mcs7 = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="mcs7", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)


  def _get_mcs8(self):
    """
    Getter method for mcs8, mapped from YANG variable /access_points/access_point/ssids/ssid/bssids/bssid/state/counters/rx_mcs/mcs8 (oc-yang:counter64)

    YANG Description: Rx Data frames at MCS 8.
    """
    return self.__mcs8
      
  def _set_mcs8(self, v, load=False):
    """
    Setter method for mcs8, mapped from YANG variable /access_points/access_point/ssids/ssid/bssids/bssid/state/counters/rx_mcs/mcs8 (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mcs8 is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mcs8() directly.

    YANG Description: Rx Data frames at MCS 8.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="mcs8", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mcs8 must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="mcs8", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__mcs8 = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mcs8(self):
    self.__mcs8 = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="mcs8", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)


  def _get_mcs9(self):
    """
    Getter method for mcs9, mapped from YANG variable /access_points/access_point/ssids/ssid/bssids/bssid/state/counters/rx_mcs/mcs9 (oc-yang:counter64)

    YANG Description: Rx Data frames at MCS 9.
    """
    return self.__mcs9
      
  def _set_mcs9(self, v, load=False):
    """
    Setter method for mcs9, mapped from YANG variable /access_points/access_point/ssids/ssid/bssids/bssid/state/counters/rx_mcs/mcs9 (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mcs9 is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mcs9() directly.

    YANG Description: Rx Data frames at MCS 9.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="mcs9", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mcs9 must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="mcs9", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__mcs9 = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mcs9(self):
    self.__mcs9 = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="mcs9", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)

  mcs0 = __builtin__.property(_get_mcs0)
  mcs1 = __builtin__.property(_get_mcs1)
  mcs2 = __builtin__.property(_get_mcs2)
  mcs3 = __builtin__.property(_get_mcs3)
  mcs4 = __builtin__.property(_get_mcs4)
  mcs5 = __builtin__.property(_get_mcs5)
  mcs6 = __builtin__.property(_get_mcs6)
  mcs7 = __builtin__.property(_get_mcs7)
  mcs8 = __builtin__.property(_get_mcs8)
  mcs9 = __builtin__.property(_get_mcs9)


  _pyangbind_elements = OrderedDict([('mcs0', mcs0), ('mcs1', mcs1), ('mcs2', mcs2), ('mcs3', mcs3), ('mcs4', mcs4), ('mcs5', mcs5), ('mcs6', mcs6), ('mcs7', mcs7), ('mcs8', mcs8), ('mcs9', mcs9), ])


class yc_tx_data_dist_openconfig_access_points__access_points_access_point_ssids_ssid_bssids_bssid_state_counters_tx_data_dist(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-access-points - based on the path /access-points/access-point/ssids/ssid/bssids/bssid/state/counters/tx-data-dist. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The distribution of Data frame sizes in bytes of
successfully transmitted AMPDU, or MPDU for non-aggregated,
frames. The distribution should characterize frame sizes
starting at 64 bytes or less with the bin size doubling for
each successive bin to a maximum of 1MB or larger, as
represented in the following table:

Lower Bound Upper Bound
  0          64
  65         128
  129        256
  257        512
  513        1024
  1025       2048
  2049       4096
  4097       8192
  8193       16384
  16385      32768
  32769      65536
  65537      131072
  131073     262144
  262145     524288
  524289     1048576
  """
  __slots__ = ('_path_helper', '_extmethods', '__tx_0_64','__tx_65_128','__tx_129_256','__tx_257_512','__tx_513_1024','__tx_1025_2048','__tx_2049_4096','__tx_4097_8192','__tx_8193_16384','__tx_16385_32768','__tx_32769_65536','__tx_65537_131072','__tx_131073_262144','__tx_262145_524288','__tx_524289_1048576',)

  _yang_name = 'tx-data-dist'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__tx_262145_524288 = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="tx-262145-524288", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)
    self.__tx_32769_65536 = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="tx-32769-65536", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)
    self.__tx_65537_131072 = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="tx-65537-131072", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)
    self.__tx_131073_262144 = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="tx-131073-262144", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)
    self.__tx_257_512 = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="tx-257-512", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)
    self.__tx_8193_16384 = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="tx-8193-16384", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)
    self.__tx_129_256 = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="tx-129-256", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)
    self.__tx_1025_2048 = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="tx-1025-2048", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)
    self.__tx_4097_8192 = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="tx-4097-8192", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)
    self.__tx_16385_32768 = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="tx-16385-32768", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)
    self.__tx_524289_1048576 = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="tx-524289-1048576", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)
    self.__tx_2049_4096 = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="tx-2049-4096", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)
    self.__tx_513_1024 = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="tx-513-1024", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)
    self.__tx_65_128 = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="tx-65-128", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)
    self.__tx_0_64 = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="tx-0-64", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'access-points', u'access-point', u'ssids', u'ssid', u'bssids', u'bssid', u'state', u'counters', u'tx-data-dist']

  def _get_tx_0_64(self):
    """
    Getter method for tx_0_64, mapped from YANG variable /access_points/access_point/ssids/ssid/bssids/bssid/state/counters/tx_data_dist/tx_0_64 (oc-yang:counter64)

    YANG Description: Transmitted AMPDU or MPDUs from 0 to 64 Bytes.
    """
    return self.__tx_0_64
      
  def _set_tx_0_64(self, v, load=False):
    """
    Setter method for tx_0_64, mapped from YANG variable /access_points/access_point/ssids/ssid/bssids/bssid/state/counters/tx_data_dist/tx_0_64 (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tx_0_64 is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tx_0_64() directly.

    YANG Description: Transmitted AMPDU or MPDUs from 0 to 64 Bytes.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="tx-0-64", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tx_0_64 must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="tx-0-64", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__tx_0_64 = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tx_0_64(self):
    self.__tx_0_64 = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="tx-0-64", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)


  def _get_tx_65_128(self):
    """
    Getter method for tx_65_128, mapped from YANG variable /access_points/access_point/ssids/ssid/bssids/bssid/state/counters/tx_data_dist/tx_65_128 (oc-yang:counter64)

    YANG Description: Transmitted AMPDU or MPDUs from 65 to 128 Bytes.
    """
    return self.__tx_65_128
      
  def _set_tx_65_128(self, v, load=False):
    """
    Setter method for tx_65_128, mapped from YANG variable /access_points/access_point/ssids/ssid/bssids/bssid/state/counters/tx_data_dist/tx_65_128 (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tx_65_128 is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tx_65_128() directly.

    YANG Description: Transmitted AMPDU or MPDUs from 65 to 128 Bytes.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="tx-65-128", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tx_65_128 must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="tx-65-128", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__tx_65_128 = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tx_65_128(self):
    self.__tx_65_128 = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="tx-65-128", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)


  def _get_tx_129_256(self):
    """
    Getter method for tx_129_256, mapped from YANG variable /access_points/access_point/ssids/ssid/bssids/bssid/state/counters/tx_data_dist/tx_129_256 (oc-yang:counter64)

    YANG Description: Transmitted AMPDU or MPDUs from 129 to 256 Bytes.
    """
    return self.__tx_129_256
      
  def _set_tx_129_256(self, v, load=False):
    """
    Setter method for tx_129_256, mapped from YANG variable /access_points/access_point/ssids/ssid/bssids/bssid/state/counters/tx_data_dist/tx_129_256 (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tx_129_256 is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tx_129_256() directly.

    YANG Description: Transmitted AMPDU or MPDUs from 129 to 256 Bytes.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="tx-129-256", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tx_129_256 must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="tx-129-256", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__tx_129_256 = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tx_129_256(self):
    self.__tx_129_256 = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="tx-129-256", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)


  def _get_tx_257_512(self):
    """
    Getter method for tx_257_512, mapped from YANG variable /access_points/access_point/ssids/ssid/bssids/bssid/state/counters/tx_data_dist/tx_257_512 (oc-yang:counter64)

    YANG Description: Transmitted AMPDU or MPDUs from 257 to 512 Bytes.
    """
    return self.__tx_257_512
      
  def _set_tx_257_512(self, v, load=False):
    """
    Setter method for tx_257_512, mapped from YANG variable /access_points/access_point/ssids/ssid/bssids/bssid/state/counters/tx_data_dist/tx_257_512 (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tx_257_512 is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tx_257_512() directly.

    YANG Description: Transmitted AMPDU or MPDUs from 257 to 512 Bytes.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="tx-257-512", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tx_257_512 must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="tx-257-512", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__tx_257_512 = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tx_257_512(self):
    self.__tx_257_512 = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="tx-257-512", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)


  def _get_tx_513_1024(self):
    """
    Getter method for tx_513_1024, mapped from YANG variable /access_points/access_point/ssids/ssid/bssids/bssid/state/counters/tx_data_dist/tx_513_1024 (oc-yang:counter64)

    YANG Description: Transmitted AMPDU or MPDUs from 513 to 1024 Bytes.
    """
    return self.__tx_513_1024
      
  def _set_tx_513_1024(self, v, load=False):
    """
    Setter method for tx_513_1024, mapped from YANG variable /access_points/access_point/ssids/ssid/bssids/bssid/state/counters/tx_data_dist/tx_513_1024 (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tx_513_1024 is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tx_513_1024() directly.

    YANG Description: Transmitted AMPDU or MPDUs from 513 to 1024 Bytes.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="tx-513-1024", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tx_513_1024 must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="tx-513-1024", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__tx_513_1024 = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tx_513_1024(self):
    self.__tx_513_1024 = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="tx-513-1024", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)


  def _get_tx_1025_2048(self):
    """
    Getter method for tx_1025_2048, mapped from YANG variable /access_points/access_point/ssids/ssid/bssids/bssid/state/counters/tx_data_dist/tx_1025_2048 (oc-yang:counter64)

    YANG Description: Transmitted AMPDU or MPDUs from 1025 to 2048 Bytes.
    """
    return self.__tx_1025_2048
      
  def _set_tx_1025_2048(self, v, load=False):
    """
    Setter method for tx_1025_2048, mapped from YANG variable /access_points/access_point/ssids/ssid/bssids/bssid/state/counters/tx_data_dist/tx_1025_2048 (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tx_1025_2048 is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tx_1025_2048() directly.

    YANG Description: Transmitted AMPDU or MPDUs from 1025 to 2048 Bytes.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="tx-1025-2048", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tx_1025_2048 must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="tx-1025-2048", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__tx_1025_2048 = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tx_1025_2048(self):
    self.__tx_1025_2048 = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="tx-1025-2048", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)


  def _get_tx_2049_4096(self):
    """
    Getter method for tx_2049_4096, mapped from YANG variable /access_points/access_point/ssids/ssid/bssids/bssid/state/counters/tx_data_dist/tx_2049_4096 (oc-yang:counter64)

    YANG Description: Transmitted AMPDU or MPDUs from 2049 to 4096 Bytes.
    """
    return self.__tx_2049_4096
      
  def _set_tx_2049_4096(self, v, load=False):
    """
    Setter method for tx_2049_4096, mapped from YANG variable /access_points/access_point/ssids/ssid/bssids/bssid/state/counters/tx_data_dist/tx_2049_4096 (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tx_2049_4096 is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tx_2049_4096() directly.

    YANG Description: Transmitted AMPDU or MPDUs from 2049 to 4096 Bytes.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="tx-2049-4096", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tx_2049_4096 must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="tx-2049-4096", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__tx_2049_4096 = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tx_2049_4096(self):
    self.__tx_2049_4096 = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="tx-2049-4096", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)


  def _get_tx_4097_8192(self):
    """
    Getter method for tx_4097_8192, mapped from YANG variable /access_points/access_point/ssids/ssid/bssids/bssid/state/counters/tx_data_dist/tx_4097_8192 (oc-yang:counter64)

    YANG Description: Transmitted AMPDU or MPDUs from 4097 to 8192 Bytes.
    """
    return self.__tx_4097_8192
      
  def _set_tx_4097_8192(self, v, load=False):
    """
    Setter method for tx_4097_8192, mapped from YANG variable /access_points/access_point/ssids/ssid/bssids/bssid/state/counters/tx_data_dist/tx_4097_8192 (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tx_4097_8192 is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tx_4097_8192() directly.

    YANG Description: Transmitted AMPDU or MPDUs from 4097 to 8192 Bytes.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="tx-4097-8192", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tx_4097_8192 must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="tx-4097-8192", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__tx_4097_8192 = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tx_4097_8192(self):
    self.__tx_4097_8192 = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="tx-4097-8192", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)


  def _get_tx_8193_16384(self):
    """
    Getter method for tx_8193_16384, mapped from YANG variable /access_points/access_point/ssids/ssid/bssids/bssid/state/counters/tx_data_dist/tx_8193_16384 (oc-yang:counter64)

    YANG Description: Transmitted AMPDU or MPDUs from 8193 to 16384 Bytes.
    """
    return self.__tx_8193_16384
      
  def _set_tx_8193_16384(self, v, load=False):
    """
    Setter method for tx_8193_16384, mapped from YANG variable /access_points/access_point/ssids/ssid/bssids/bssid/state/counters/tx_data_dist/tx_8193_16384 (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tx_8193_16384 is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tx_8193_16384() directly.

    YANG Description: Transmitted AMPDU or MPDUs from 8193 to 16384 Bytes.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="tx-8193-16384", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tx_8193_16384 must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="tx-8193-16384", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__tx_8193_16384 = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tx_8193_16384(self):
    self.__tx_8193_16384 = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="tx-8193-16384", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)


  def _get_tx_16385_32768(self):
    """
    Getter method for tx_16385_32768, mapped from YANG variable /access_points/access_point/ssids/ssid/bssids/bssid/state/counters/tx_data_dist/tx_16385_32768 (oc-yang:counter64)

    YANG Description: Transmitted AMPDU or MPDUs from 16385 to 32768 Bytes.
    """
    return self.__tx_16385_32768
      
  def _set_tx_16385_32768(self, v, load=False):
    """
    Setter method for tx_16385_32768, mapped from YANG variable /access_points/access_point/ssids/ssid/bssids/bssid/state/counters/tx_data_dist/tx_16385_32768 (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tx_16385_32768 is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tx_16385_32768() directly.

    YANG Description: Transmitted AMPDU or MPDUs from 16385 to 32768 Bytes.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="tx-16385-32768", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tx_16385_32768 must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="tx-16385-32768", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__tx_16385_32768 = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tx_16385_32768(self):
    self.__tx_16385_32768 = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="tx-16385-32768", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)


  def _get_tx_32769_65536(self):
    """
    Getter method for tx_32769_65536, mapped from YANG variable /access_points/access_point/ssids/ssid/bssids/bssid/state/counters/tx_data_dist/tx_32769_65536 (oc-yang:counter64)

    YANG Description: Transmitted AMPDU or MPDUs from 32769 to 65536 Bytes.
    """
    return self.__tx_32769_65536
      
  def _set_tx_32769_65536(self, v, load=False):
    """
    Setter method for tx_32769_65536, mapped from YANG variable /access_points/access_point/ssids/ssid/bssids/bssid/state/counters/tx_data_dist/tx_32769_65536 (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tx_32769_65536 is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tx_32769_65536() directly.

    YANG Description: Transmitted AMPDU or MPDUs from 32769 to 65536 Bytes.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="tx-32769-65536", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tx_32769_65536 must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="tx-32769-65536", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__tx_32769_65536 = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tx_32769_65536(self):
    self.__tx_32769_65536 = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="tx-32769-65536", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)


  def _get_tx_65537_131072(self):
    """
    Getter method for tx_65537_131072, mapped from YANG variable /access_points/access_point/ssids/ssid/bssids/bssid/state/counters/tx_data_dist/tx_65537_131072 (oc-yang:counter64)

    YANG Description: Transmitted AMPDU from 65537 to 131072 Bytes.
    """
    return self.__tx_65537_131072
      
  def _set_tx_65537_131072(self, v, load=False):
    """
    Setter method for tx_65537_131072, mapped from YANG variable /access_points/access_point/ssids/ssid/bssids/bssid/state/counters/tx_data_dist/tx_65537_131072 (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tx_65537_131072 is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tx_65537_131072() directly.

    YANG Description: Transmitted AMPDU from 65537 to 131072 Bytes.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="tx-65537-131072", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tx_65537_131072 must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="tx-65537-131072", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__tx_65537_131072 = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tx_65537_131072(self):
    self.__tx_65537_131072 = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="tx-65537-131072", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)


  def _get_tx_131073_262144(self):
    """
    Getter method for tx_131073_262144, mapped from YANG variable /access_points/access_point/ssids/ssid/bssids/bssid/state/counters/tx_data_dist/tx_131073_262144 (oc-yang:counter64)

    YANG Description: Transmitted AMPDU from 131073 to 262144 Bytes.
    """
    return self.__tx_131073_262144
      
  def _set_tx_131073_262144(self, v, load=False):
    """
    Setter method for tx_131073_262144, mapped from YANG variable /access_points/access_point/ssids/ssid/bssids/bssid/state/counters/tx_data_dist/tx_131073_262144 (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tx_131073_262144 is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tx_131073_262144() directly.

    YANG Description: Transmitted AMPDU from 131073 to 262144 Bytes.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="tx-131073-262144", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tx_131073_262144 must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="tx-131073-262144", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__tx_131073_262144 = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tx_131073_262144(self):
    self.__tx_131073_262144 = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="tx-131073-262144", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)


  def _get_tx_262145_524288(self):
    """
    Getter method for tx_262145_524288, mapped from YANG variable /access_points/access_point/ssids/ssid/bssids/bssid/state/counters/tx_data_dist/tx_262145_524288 (oc-yang:counter64)

    YANG Description: Transmitted AMPDU from 262145 to 524288 Bytes.
    """
    return self.__tx_262145_524288
      
  def _set_tx_262145_524288(self, v, load=False):
    """
    Setter method for tx_262145_524288, mapped from YANG variable /access_points/access_point/ssids/ssid/bssids/bssid/state/counters/tx_data_dist/tx_262145_524288 (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tx_262145_524288 is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tx_262145_524288() directly.

    YANG Description: Transmitted AMPDU from 262145 to 524288 Bytes.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="tx-262145-524288", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tx_262145_524288 must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="tx-262145-524288", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__tx_262145_524288 = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tx_262145_524288(self):
    self.__tx_262145_524288 = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="tx-262145-524288", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)


  def _get_tx_524289_1048576(self):
    """
    Getter method for tx_524289_1048576, mapped from YANG variable /access_points/access_point/ssids/ssid/bssids/bssid/state/counters/tx_data_dist/tx_524289_1048576 (oc-yang:counter64)

    YANG Description: Transmitted AMPDU from 524289 to 1048576 Bytes.
    """
    return self.__tx_524289_1048576
      
  def _set_tx_524289_1048576(self, v, load=False):
    """
    Setter method for tx_524289_1048576, mapped from YANG variable /access_points/access_point/ssids/ssid/bssids/bssid/state/counters/tx_data_dist/tx_524289_1048576 (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tx_524289_1048576 is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tx_524289_1048576() directly.

    YANG Description: Transmitted AMPDU from 524289 to 1048576 Bytes.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="tx-524289-1048576", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tx_524289_1048576 must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="tx-524289-1048576", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__tx_524289_1048576 = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tx_524289_1048576(self):
    self.__tx_524289_1048576 = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="tx-524289-1048576", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)

  tx_0_64 = __builtin__.property(_get_tx_0_64)
  tx_65_128 = __builtin__.property(_get_tx_65_128)
  tx_129_256 = __builtin__.property(_get_tx_129_256)
  tx_257_512 = __builtin__.property(_get_tx_257_512)
  tx_513_1024 = __builtin__.property(_get_tx_513_1024)
  tx_1025_2048 = __builtin__.property(_get_tx_1025_2048)
  tx_2049_4096 = __builtin__.property(_get_tx_2049_4096)
  tx_4097_8192 = __builtin__.property(_get_tx_4097_8192)
  tx_8193_16384 = __builtin__.property(_get_tx_8193_16384)
  tx_16385_32768 = __builtin__.property(_get_tx_16385_32768)
  tx_32769_65536 = __builtin__.property(_get_tx_32769_65536)
  tx_65537_131072 = __builtin__.property(_get_tx_65537_131072)
  tx_131073_262144 = __builtin__.property(_get_tx_131073_262144)
  tx_262145_524288 = __builtin__.property(_get_tx_262145_524288)
  tx_524289_1048576 = __builtin__.property(_get_tx_524289_1048576)


  _pyangbind_elements = OrderedDict([('tx_0_64', tx_0_64), ('tx_65_128', tx_65_128), ('tx_129_256', tx_129_256), ('tx_257_512', tx_257_512), ('tx_513_1024', tx_513_1024), ('tx_1025_2048', tx_1025_2048), ('tx_2049_4096', tx_2049_4096), ('tx_4097_8192', tx_4097_8192), ('tx_8193_16384', tx_8193_16384), ('tx_16385_32768', tx_16385_32768), ('tx_32769_65536', tx_32769_65536), ('tx_65537_131072', tx_65537_131072), ('tx_131073_262144', tx_131073_262144), ('tx_262145_524288', tx_262145_524288), ('tx_524289_1048576', tx_524289_1048576), ])


class yc_tx_data_wmm_openconfig_access_points__access_points_access_point_ssids_ssid_bssids_bssid_state_counters_tx_data_wmm(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-access-points - based on the path /access-points/access-point/ssids/ssid/bssids/bssid/state/counters/tx-data-wmm. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Transmitted QoS Data frames, per WMM AC.
  """
  __slots__ = ('_path_helper', '_extmethods', '__vi','__vo','__bk','__be',)

  _yang_name = 'tx-data-wmm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__vi = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="vi", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)
    self.__be = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="be", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)
    self.__bk = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="bk", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)
    self.__vo = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="vo", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'access-points', u'access-point', u'ssids', u'ssid', u'bssids', u'bssid', u'state', u'counters', u'tx-data-wmm']

  def _get_vi(self):
    """
    Getter method for vi, mapped from YANG variable /access_points/access_point/ssids/ssid/bssids/bssid/state/counters/tx_data_wmm/vi (oc-yang:counter64)

    YANG Description: Tx Data frames marked as Access Category Video.
    """
    return self.__vi
      
  def _set_vi(self, v, load=False):
    """
    Setter method for vi, mapped from YANG variable /access_points/access_point/ssids/ssid/bssids/bssid/state/counters/tx_data_wmm/vi (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vi is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vi() directly.

    YANG Description: Tx Data frames marked as Access Category Video.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="vi", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vi must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="vi", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__vi = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vi(self):
    self.__vi = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="vi", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)


  def _get_vo(self):
    """
    Getter method for vo, mapped from YANG variable /access_points/access_point/ssids/ssid/bssids/bssid/state/counters/tx_data_wmm/vo (oc-yang:counter64)

    YANG Description: Tx Data frames marked as Access Category Voice.
    """
    return self.__vo
      
  def _set_vo(self, v, load=False):
    """
    Setter method for vo, mapped from YANG variable /access_points/access_point/ssids/ssid/bssids/bssid/state/counters/tx_data_wmm/vo (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vo is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vo() directly.

    YANG Description: Tx Data frames marked as Access Category Voice.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="vo", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vo must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="vo", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__vo = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vo(self):
    self.__vo = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="vo", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)


  def _get_bk(self):
    """
    Getter method for bk, mapped from YANG variable /access_points/access_point/ssids/ssid/bssids/bssid/state/counters/tx_data_wmm/bk (oc-yang:counter64)

    YANG Description: Tx Data frames marked as Access Category Background.
    """
    return self.__bk
      
  def _set_bk(self, v, load=False):
    """
    Setter method for bk, mapped from YANG variable /access_points/access_point/ssids/ssid/bssids/bssid/state/counters/tx_data_wmm/bk (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bk is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bk() directly.

    YANG Description: Tx Data frames marked as Access Category Background.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="bk", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bk must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="bk", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__bk = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bk(self):
    self.__bk = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="bk", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)


  def _get_be(self):
    """
    Getter method for be, mapped from YANG variable /access_points/access_point/ssids/ssid/bssids/bssid/state/counters/tx_data_wmm/be (oc-yang:counter64)

    YANG Description: Tx Data frames marked as Access Category Best Effort.
    """
    return self.__be
      
  def _set_be(self, v, load=False):
    """
    Setter method for be, mapped from YANG variable /access_points/access_point/ssids/ssid/bssids/bssid/state/counters/tx_data_wmm/be (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_be is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_be() directly.

    YANG Description: Tx Data frames marked as Access Category Best Effort.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="be", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """be must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="be", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__be = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_be(self):
    self.__be = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="be", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)

  vi = __builtin__.property(_get_vi)
  vo = __builtin__.property(_get_vo)
  bk = __builtin__.property(_get_bk)
  be = __builtin__.property(_get_be)


  _pyangbind_elements = OrderedDict([('vi', vi), ('vo', vo), ('bk', bk), ('be', be), ])


class yc_tx_mcs_openconfig_access_points__access_points_access_point_ssids_ssid_bssids_bssid_state_counters_tx_mcs(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-access-points - based on the path /access-points/access-point/ssids/ssid/bssids/bssid/state/counters/tx-mcs. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Transmitted Data frames, per MCS Index. It is expected that
vendors bucketize 802.11n MCS frames in their matching
802.11ac buckets.

Example, 802.11n MCS 15 = 802.11ac MCS 7.
802.11n MCS 20 = 802.11ac MCS 4.
  """
  __slots__ = ('_path_helper', '_extmethods', '__mcs0','__mcs1','__mcs2','__mcs3','__mcs4','__mcs5','__mcs6','__mcs7','__mcs8','__mcs9',)

  _yang_name = 'tx-mcs'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__mcs9 = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="mcs9", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)
    self.__mcs8 = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="mcs8", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)
    self.__mcs1 = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="mcs1", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)
    self.__mcs0 = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="mcs0", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)
    self.__mcs3 = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="mcs3", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)
    self.__mcs2 = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="mcs2", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)
    self.__mcs5 = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="mcs5", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)
    self.__mcs4 = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="mcs4", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)
    self.__mcs7 = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="mcs7", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)
    self.__mcs6 = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="mcs6", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'access-points', u'access-point', u'ssids', u'ssid', u'bssids', u'bssid', u'state', u'counters', u'tx-mcs']

  def _get_mcs0(self):
    """
    Getter method for mcs0, mapped from YANG variable /access_points/access_point/ssids/ssid/bssids/bssid/state/counters/tx_mcs/mcs0 (oc-yang:counter64)

    YANG Description: Tx Data frames at MCS 0.
    """
    return self.__mcs0
      
  def _set_mcs0(self, v, load=False):
    """
    Setter method for mcs0, mapped from YANG variable /access_points/access_point/ssids/ssid/bssids/bssid/state/counters/tx_mcs/mcs0 (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mcs0 is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mcs0() directly.

    YANG Description: Tx Data frames at MCS 0.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="mcs0", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mcs0 must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="mcs0", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__mcs0 = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mcs0(self):
    self.__mcs0 = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="mcs0", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)


  def _get_mcs1(self):
    """
    Getter method for mcs1, mapped from YANG variable /access_points/access_point/ssids/ssid/bssids/bssid/state/counters/tx_mcs/mcs1 (oc-yang:counter64)

    YANG Description: Tx Data frames at MCS 1.
    """
    return self.__mcs1
      
  def _set_mcs1(self, v, load=False):
    """
    Setter method for mcs1, mapped from YANG variable /access_points/access_point/ssids/ssid/bssids/bssid/state/counters/tx_mcs/mcs1 (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mcs1 is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mcs1() directly.

    YANG Description: Tx Data frames at MCS 1.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="mcs1", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mcs1 must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="mcs1", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__mcs1 = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mcs1(self):
    self.__mcs1 = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="mcs1", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)


  def _get_mcs2(self):
    """
    Getter method for mcs2, mapped from YANG variable /access_points/access_point/ssids/ssid/bssids/bssid/state/counters/tx_mcs/mcs2 (oc-yang:counter64)

    YANG Description: Tx Data frames at MCS 2.
    """
    return self.__mcs2
      
  def _set_mcs2(self, v, load=False):
    """
    Setter method for mcs2, mapped from YANG variable /access_points/access_point/ssids/ssid/bssids/bssid/state/counters/tx_mcs/mcs2 (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mcs2 is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mcs2() directly.

    YANG Description: Tx Data frames at MCS 2.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="mcs2", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mcs2 must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="mcs2", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__mcs2 = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mcs2(self):
    self.__mcs2 = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="mcs2", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)


  def _get_mcs3(self):
    """
    Getter method for mcs3, mapped from YANG variable /access_points/access_point/ssids/ssid/bssids/bssid/state/counters/tx_mcs/mcs3 (oc-yang:counter64)

    YANG Description: Tx Data frames at MCS 3.
    """
    return self.__mcs3
      
  def _set_mcs3(self, v, load=False):
    """
    Setter method for mcs3, mapped from YANG variable /access_points/access_point/ssids/ssid/bssids/bssid/state/counters/tx_mcs/mcs3 (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mcs3 is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mcs3() directly.

    YANG Description: Tx Data frames at MCS 3.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="mcs3", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mcs3 must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="mcs3", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__mcs3 = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mcs3(self):
    self.__mcs3 = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="mcs3", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)


  def _get_mcs4(self):
    """
    Getter method for mcs4, mapped from YANG variable /access_points/access_point/ssids/ssid/bssids/bssid/state/counters/tx_mcs/mcs4 (oc-yang:counter64)

    YANG Description: Tx Data frames at MCS 4.
    """
    return self.__mcs4
      
  def _set_mcs4(self, v, load=False):
    """
    Setter method for mcs4, mapped from YANG variable /access_points/access_point/ssids/ssid/bssids/bssid/state/counters/tx_mcs/mcs4 (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mcs4 is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mcs4() directly.

    YANG Description: Tx Data frames at MCS 4.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="mcs4", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mcs4 must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="mcs4", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__mcs4 = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mcs4(self):
    self.__mcs4 = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="mcs4", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)


  def _get_mcs5(self):
    """
    Getter method for mcs5, mapped from YANG variable /access_points/access_point/ssids/ssid/bssids/bssid/state/counters/tx_mcs/mcs5 (oc-yang:counter64)

    YANG Description: Tx Data frames at MCS 5.
    """
    return self.__mcs5
      
  def _set_mcs5(self, v, load=False):
    """
    Setter method for mcs5, mapped from YANG variable /access_points/access_point/ssids/ssid/bssids/bssid/state/counters/tx_mcs/mcs5 (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mcs5 is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mcs5() directly.

    YANG Description: Tx Data frames at MCS 5.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="mcs5", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mcs5 must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="mcs5", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__mcs5 = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mcs5(self):
    self.__mcs5 = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="mcs5", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)


  def _get_mcs6(self):
    """
    Getter method for mcs6, mapped from YANG variable /access_points/access_point/ssids/ssid/bssids/bssid/state/counters/tx_mcs/mcs6 (oc-yang:counter64)

    YANG Description: Tx Data frames at MCS 6.
    """
    return self.__mcs6
      
  def _set_mcs6(self, v, load=False):
    """
    Setter method for mcs6, mapped from YANG variable /access_points/access_point/ssids/ssid/bssids/bssid/state/counters/tx_mcs/mcs6 (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mcs6 is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mcs6() directly.

    YANG Description: Tx Data frames at MCS 6.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="mcs6", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mcs6 must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="mcs6", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__mcs6 = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mcs6(self):
    self.__mcs6 = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="mcs6", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)


  def _get_mcs7(self):
    """
    Getter method for mcs7, mapped from YANG variable /access_points/access_point/ssids/ssid/bssids/bssid/state/counters/tx_mcs/mcs7 (oc-yang:counter64)

    YANG Description: Tx Data frames at MCS 7.
    """
    return self.__mcs7
      
  def _set_mcs7(self, v, load=False):
    """
    Setter method for mcs7, mapped from YANG variable /access_points/access_point/ssids/ssid/bssids/bssid/state/counters/tx_mcs/mcs7 (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mcs7 is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mcs7() directly.

    YANG Description: Tx Data frames at MCS 7.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="mcs7", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mcs7 must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="mcs7", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__mcs7 = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mcs7(self):
    self.__mcs7 = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="mcs7", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)


  def _get_mcs8(self):
    """
    Getter method for mcs8, mapped from YANG variable /access_points/access_point/ssids/ssid/bssids/bssid/state/counters/tx_mcs/mcs8 (oc-yang:counter64)

    YANG Description: Tx Data frames at MCS 8.
    """
    return self.__mcs8
      
  def _set_mcs8(self, v, load=False):
    """
    Setter method for mcs8, mapped from YANG variable /access_points/access_point/ssids/ssid/bssids/bssid/state/counters/tx_mcs/mcs8 (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mcs8 is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mcs8() directly.

    YANG Description: Tx Data frames at MCS 8.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="mcs8", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mcs8 must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="mcs8", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__mcs8 = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mcs8(self):
    self.__mcs8 = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="mcs8", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)


  def _get_mcs9(self):
    """
    Getter method for mcs9, mapped from YANG variable /access_points/access_point/ssids/ssid/bssids/bssid/state/counters/tx_mcs/mcs9 (oc-yang:counter64)

    YANG Description: Tx Data frames at MCS 9.
    """
    return self.__mcs9
      
  def _set_mcs9(self, v, load=False):
    """
    Setter method for mcs9, mapped from YANG variable /access_points/access_point/ssids/ssid/bssids/bssid/state/counters/tx_mcs/mcs9 (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mcs9 is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mcs9() directly.

    YANG Description: Tx Data frames at MCS 9.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="mcs9", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mcs9 must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="mcs9", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__mcs9 = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mcs9(self):
    self.__mcs9 = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="mcs9", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)

  mcs0 = __builtin__.property(_get_mcs0)
  mcs1 = __builtin__.property(_get_mcs1)
  mcs2 = __builtin__.property(_get_mcs2)
  mcs3 = __builtin__.property(_get_mcs3)
  mcs4 = __builtin__.property(_get_mcs4)
  mcs5 = __builtin__.property(_get_mcs5)
  mcs6 = __builtin__.property(_get_mcs6)
  mcs7 = __builtin__.property(_get_mcs7)
  mcs8 = __builtin__.property(_get_mcs8)
  mcs9 = __builtin__.property(_get_mcs9)


  _pyangbind_elements = OrderedDict([('mcs0', mcs0), ('mcs1', mcs1), ('mcs2', mcs2), ('mcs3', mcs3), ('mcs4', mcs4), ('mcs5', mcs5), ('mcs6', mcs6), ('mcs7', mcs7), ('mcs8', mcs8), ('mcs9', mcs9), ])


class yc_counters_openconfig_access_points__access_points_access_point_ssids_ssid_bssids_bssid_state_counters(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-access-points - based on the path /access-points/access-point/ssids/ssid/bssids/bssid/state/counters. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: BSS Counters.
  """
  __slots__ = ('_path_helper', '_extmethods', '__rx_bss_dot11_channel_utilization','__rx_mgmt','__rx_control','__rx_data_dist','__rx_data_wmm','__rx_mcs','__rx_retries','__rx_retries_data','__rx_retries_subframe','__rx_bytes_data','__tx_bss_dot11_channel_utilization','__tx_mgmt','__tx_control','__tx_data_dist','__tx_data_wmm','__tx_mcs','__tx_retries','__tx_retries_data','__tx_retries_subframe','__tx_bytes_data','__bss_channel_utilization',)

  _yang_name = 'counters'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__rx_bytes_data = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="rx-bytes-data", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)
    self.__tx_bytes_data = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="tx-bytes-data", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)
    self.__tx_retries_subframe = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="tx-retries-subframe", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)
    self.__rx_data_dist = YANGDynClass(base=yc_rx_data_dist_openconfig_access_points__access_points_access_point_ssids_ssid_bssids_bssid_state_counters_rx_data_dist, is_container='container', yang_name="rx-data-dist", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=False)
    self.__tx_bss_dot11_channel_utilization = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={u'range': [u'0..100']}), is_leaf=True, yang_name="tx-bss-dot11-channel-utilization", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:percentage', is_config=False)
    self.__rx_retries = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="rx-retries", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)
    self.__rx_bss_dot11_channel_utilization = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={u'range': [u'0..100']}), is_leaf=True, yang_name="rx-bss-dot11-channel-utilization", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:percentage', is_config=False)
    self.__rx_mgmt = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="rx-mgmt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)
    self.__rx_mcs = YANGDynClass(base=yc_rx_mcs_openconfig_access_points__access_points_access_point_ssids_ssid_bssids_bssid_state_counters_rx_mcs, is_container='container', yang_name="rx-mcs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=False)
    self.__tx_mgmt = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="tx-mgmt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)
    self.__tx_control = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="tx-control", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)
    self.__bss_channel_utilization = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={u'range': [u'0..100']}), is_leaf=True, yang_name="bss-channel-utilization", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:percentage', is_config=False)
    self.__tx_retries_data = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="tx-retries-data", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)
    self.__tx_data_wmm = YANGDynClass(base=yc_tx_data_wmm_openconfig_access_points__access_points_access_point_ssids_ssid_bssids_bssid_state_counters_tx_data_wmm, is_container='container', yang_name="tx-data-wmm", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=False)
    self.__tx_mcs = YANGDynClass(base=yc_tx_mcs_openconfig_access_points__access_points_access_point_ssids_ssid_bssids_bssid_state_counters_tx_mcs, is_container='container', yang_name="tx-mcs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=False)
    self.__rx_data_wmm = YANGDynClass(base=yc_rx_data_wmm_openconfig_access_points__access_points_access_point_ssids_ssid_bssids_bssid_state_counters_rx_data_wmm, is_container='container', yang_name="rx-data-wmm", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=False)
    self.__tx_retries = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="tx-retries", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)
    self.__rx_control = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="rx-control", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)
    self.__rx_retries_subframe = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="rx-retries-subframe", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)
    self.__tx_data_dist = YANGDynClass(base=yc_tx_data_dist_openconfig_access_points__access_points_access_point_ssids_ssid_bssids_bssid_state_counters_tx_data_dist, is_container='container', yang_name="tx-data-dist", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=False)
    self.__rx_retries_data = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="rx-retries-data", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'access-points', u'access-point', u'ssids', u'ssid', u'bssids', u'bssid', u'state', u'counters']

  def _get_rx_bss_dot11_channel_utilization(self):
    """
    Getter method for rx_bss_dot11_channel_utilization, mapped from YANG variable /access_points/access_point/ssids/ssid/bssids/bssid/state/counters/rx_bss_dot11_channel_utilization (oc-types:percentage)

    YANG Description: Recieve channel utilization percent caused by reception of
any 802.11 frame within this BSS.
    """
    return self.__rx_bss_dot11_channel_utilization
      
  def _set_rx_bss_dot11_channel_utilization(self, v, load=False):
    """
    Setter method for rx_bss_dot11_channel_utilization, mapped from YANG variable /access_points/access_point/ssids/ssid/bssids/bssid/state/counters/rx_bss_dot11_channel_utilization (oc-types:percentage)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_rx_bss_dot11_channel_utilization is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_rx_bss_dot11_channel_utilization() directly.

    YANG Description: Recieve channel utilization percent caused by reception of
any 802.11 frame within this BSS.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={u'range': [u'0..100']}), is_leaf=True, yang_name="rx-bss-dot11-channel-utilization", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:percentage', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """rx_bss_dot11_channel_utilization must be of a type compatible with oc-types:percentage""",
          'defined-type': "oc-types:percentage",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={u'range': [u'0..100']}), is_leaf=True, yang_name="rx-bss-dot11-channel-utilization", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:percentage', is_config=False)""",
        })

    self.__rx_bss_dot11_channel_utilization = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_rx_bss_dot11_channel_utilization(self):
    self.__rx_bss_dot11_channel_utilization = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={u'range': [u'0..100']}), is_leaf=True, yang_name="rx-bss-dot11-channel-utilization", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:percentage', is_config=False)


  def _get_rx_mgmt(self):
    """
    Getter method for rx_mgmt, mapped from YANG variable /access_points/access_point/ssids/ssid/bssids/bssid/state/counters/rx_mgmt (oc-yang:counter64)

    YANG Description: Received 802.11 Management frames.
    """
    return self.__rx_mgmt
      
  def _set_rx_mgmt(self, v, load=False):
    """
    Setter method for rx_mgmt, mapped from YANG variable /access_points/access_point/ssids/ssid/bssids/bssid/state/counters/rx_mgmt (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_rx_mgmt is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_rx_mgmt() directly.

    YANG Description: Received 802.11 Management frames.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="rx-mgmt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """rx_mgmt must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="rx-mgmt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__rx_mgmt = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_rx_mgmt(self):
    self.__rx_mgmt = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="rx-mgmt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)


  def _get_rx_control(self):
    """
    Getter method for rx_control, mapped from YANG variable /access_points/access_point/ssids/ssid/bssids/bssid/state/counters/rx_control (oc-yang:counter64)

    YANG Description: Received 802.11 Control frames.
    """
    return self.__rx_control
      
  def _set_rx_control(self, v, load=False):
    """
    Setter method for rx_control, mapped from YANG variable /access_points/access_point/ssids/ssid/bssids/bssid/state/counters/rx_control (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_rx_control is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_rx_control() directly.

    YANG Description: Received 802.11 Control frames.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="rx-control", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """rx_control must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="rx-control", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__rx_control = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_rx_control(self):
    self.__rx_control = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="rx-control", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)


  def _get_rx_data_dist(self):
    """
    Getter method for rx_data_dist, mapped from YANG variable /access_points/access_point/ssids/ssid/bssids/bssid/state/counters/rx_data_dist (container)

    YANG Description: The distribution of Data frame sizes in bytes of
successfully recieved AMPDU, or MPDU for non-aggregated,
frames. The distribution should characterize frame sizes
starting at 64 bytes or less with the bin size doubling for
each successive bin to a maximum of 1MB or larger, as
represented in the following table:

Lower Bound Upper Bound
  0          64
  65         128
  129        256
  257        512
  513        1024
  1025       2048
  2049       4096
  4097       8192
  8193       16384
  16385      32768
  32769      65536
  65537      131072
  131073     262144
  262145     524288
  524289     1048576
    """
    return self.__rx_data_dist
      
  def _set_rx_data_dist(self, v, load=False):
    """
    Setter method for rx_data_dist, mapped from YANG variable /access_points/access_point/ssids/ssid/bssids/bssid/state/counters/rx_data_dist (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_rx_data_dist is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_rx_data_dist() directly.

    YANG Description: The distribution of Data frame sizes in bytes of
successfully recieved AMPDU, or MPDU for non-aggregated,
frames. The distribution should characterize frame sizes
starting at 64 bytes or less with the bin size doubling for
each successive bin to a maximum of 1MB or larger, as
represented in the following table:

Lower Bound Upper Bound
  0          64
  65         128
  129        256
  257        512
  513        1024
  1025       2048
  2049       4096
  4097       8192
  8193       16384
  16385      32768
  32769      65536
  65537      131072
  131073     262144
  262145     524288
  524289     1048576
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_rx_data_dist_openconfig_access_points__access_points_access_point_ssids_ssid_bssids_bssid_state_counters_rx_data_dist, is_container='container', yang_name="rx-data-dist", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """rx_data_dist must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_rx_data_dist_openconfig_access_points__access_points_access_point_ssids_ssid_bssids_bssid_state_counters_rx_data_dist, is_container='container', yang_name="rx-data-dist", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=False)""",
        })

    self.__rx_data_dist = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_rx_data_dist(self):
    self.__rx_data_dist = YANGDynClass(base=yc_rx_data_dist_openconfig_access_points__access_points_access_point_ssids_ssid_bssids_bssid_state_counters_rx_data_dist, is_container='container', yang_name="rx-data-dist", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=False)


  def _get_rx_data_wmm(self):
    """
    Getter method for rx_data_wmm, mapped from YANG variable /access_points/access_point/ssids/ssid/bssids/bssid/state/counters/rx_data_wmm (container)

    YANG Description: Received 802.11 Data frames, per WMM Access Category.
    """
    return self.__rx_data_wmm
      
  def _set_rx_data_wmm(self, v, load=False):
    """
    Setter method for rx_data_wmm, mapped from YANG variable /access_points/access_point/ssids/ssid/bssids/bssid/state/counters/rx_data_wmm (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_rx_data_wmm is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_rx_data_wmm() directly.

    YANG Description: Received 802.11 Data frames, per WMM Access Category.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_rx_data_wmm_openconfig_access_points__access_points_access_point_ssids_ssid_bssids_bssid_state_counters_rx_data_wmm, is_container='container', yang_name="rx-data-wmm", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """rx_data_wmm must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_rx_data_wmm_openconfig_access_points__access_points_access_point_ssids_ssid_bssids_bssid_state_counters_rx_data_wmm, is_container='container', yang_name="rx-data-wmm", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=False)""",
        })

    self.__rx_data_wmm = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_rx_data_wmm(self):
    self.__rx_data_wmm = YANGDynClass(base=yc_rx_data_wmm_openconfig_access_points__access_points_access_point_ssids_ssid_bssids_bssid_state_counters_rx_data_wmm, is_container='container', yang_name="rx-data-wmm", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=False)


  def _get_rx_mcs(self):
    """
    Getter method for rx_mcs, mapped from YANG variable /access_points/access_point/ssids/ssid/bssids/bssid/state/counters/rx_mcs (container)

    YANG Description: Received Data frames, per MCS Index. It is expected that
vendors bucketize 802.11n MCS frames in their matching
802.11ac buckets.

Example, 802.11n MCS 15 = 802.11ac MCS 7.
802.11n MCS 20 = 802.11ac MCS 4.
    """
    return self.__rx_mcs
      
  def _set_rx_mcs(self, v, load=False):
    """
    Setter method for rx_mcs, mapped from YANG variable /access_points/access_point/ssids/ssid/bssids/bssid/state/counters/rx_mcs (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_rx_mcs is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_rx_mcs() directly.

    YANG Description: Received Data frames, per MCS Index. It is expected that
vendors bucketize 802.11n MCS frames in their matching
802.11ac buckets.

Example, 802.11n MCS 15 = 802.11ac MCS 7.
802.11n MCS 20 = 802.11ac MCS 4.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_rx_mcs_openconfig_access_points__access_points_access_point_ssids_ssid_bssids_bssid_state_counters_rx_mcs, is_container='container', yang_name="rx-mcs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """rx_mcs must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_rx_mcs_openconfig_access_points__access_points_access_point_ssids_ssid_bssids_bssid_state_counters_rx_mcs, is_container='container', yang_name="rx-mcs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=False)""",
        })

    self.__rx_mcs = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_rx_mcs(self):
    self.__rx_mcs = YANGDynClass(base=yc_rx_mcs_openconfig_access_points__access_points_access_point_ssids_ssid_bssids_bssid_state_counters_rx_mcs, is_container='container', yang_name="rx-mcs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=False)


  def _get_rx_retries(self):
    """
    Getter method for rx_retries, mapped from YANG variable /access_points/access_point/ssids/ssid/bssids/bssid/state/counters/rx_retries (oc-yang:counter64)

    YANG Description: Total number of received frames with the Retry bit set,
within this BSS.
    """
    return self.__rx_retries
      
  def _set_rx_retries(self, v, load=False):
    """
    Setter method for rx_retries, mapped from YANG variable /access_points/access_point/ssids/ssid/bssids/bssid/state/counters/rx_retries (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_rx_retries is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_rx_retries() directly.

    YANG Description: Total number of received frames with the Retry bit set,
within this BSS.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="rx-retries", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """rx_retries must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="rx-retries", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__rx_retries = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_rx_retries(self):
    self.__rx_retries = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="rx-retries", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)


  def _get_rx_retries_data(self):
    """
    Getter method for rx_retries_data, mapped from YANG variable /access_points/access_point/ssids/ssid/bssids/bssid/state/counters/rx_retries_data (oc-yang:counter64)

    YANG Description: Number of received QoS Data frames with the Retry bit set
    """
    return self.__rx_retries_data
      
  def _set_rx_retries_data(self, v, load=False):
    """
    Setter method for rx_retries_data, mapped from YANG variable /access_points/access_point/ssids/ssid/bssids/bssid/state/counters/rx_retries_data (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_rx_retries_data is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_rx_retries_data() directly.

    YANG Description: Number of received QoS Data frames with the Retry bit set
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="rx-retries-data", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """rx_retries_data must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="rx-retries-data", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__rx_retries_data = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_rx_retries_data(self):
    self.__rx_retries_data = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="rx-retries-data", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)


  def _get_rx_retries_subframe(self):
    """
    Getter method for rx_retries_subframe, mapped from YANG variable /access_points/access_point/ssids/ssid/bssids/bssid/state/counters/rx_retries_subframe (oc-yang:counter64)

    YANG Description: Aggregated MPDUs which had individual subframes that fail
and require retransmission.
    """
    return self.__rx_retries_subframe
      
  def _set_rx_retries_subframe(self, v, load=False):
    """
    Setter method for rx_retries_subframe, mapped from YANG variable /access_points/access_point/ssids/ssid/bssids/bssid/state/counters/rx_retries_subframe (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_rx_retries_subframe is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_rx_retries_subframe() directly.

    YANG Description: Aggregated MPDUs which had individual subframes that fail
and require retransmission.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="rx-retries-subframe", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """rx_retries_subframe must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="rx-retries-subframe", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__rx_retries_subframe = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_rx_retries_subframe(self):
    self.__rx_retries_subframe = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="rx-retries-subframe", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)


  def _get_rx_bytes_data(self):
    """
    Getter method for rx_bytes_data, mapped from YANG variable /access_points/access_point/ssids/ssid/bssids/bssid/state/counters/rx_bytes_data (oc-yang:counter64)

    YANG Description: Bytes received from QoS Data frames
    """
    return self.__rx_bytes_data
      
  def _set_rx_bytes_data(self, v, load=False):
    """
    Setter method for rx_bytes_data, mapped from YANG variable /access_points/access_point/ssids/ssid/bssids/bssid/state/counters/rx_bytes_data (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_rx_bytes_data is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_rx_bytes_data() directly.

    YANG Description: Bytes received from QoS Data frames
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="rx-bytes-data", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """rx_bytes_data must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="rx-bytes-data", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__rx_bytes_data = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_rx_bytes_data(self):
    self.__rx_bytes_data = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="rx-bytes-data", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)


  def _get_tx_bss_dot11_channel_utilization(self):
    """
    Getter method for tx_bss_dot11_channel_utilization, mapped from YANG variable /access_points/access_point/ssids/ssid/bssids/bssid/state/counters/tx_bss_dot11_channel_utilization (oc-types:percentage)

    YANG Description: Channel utilization percent caused by transmission of any
802.11 frame within this BSS.
    """
    return self.__tx_bss_dot11_channel_utilization
      
  def _set_tx_bss_dot11_channel_utilization(self, v, load=False):
    """
    Setter method for tx_bss_dot11_channel_utilization, mapped from YANG variable /access_points/access_point/ssids/ssid/bssids/bssid/state/counters/tx_bss_dot11_channel_utilization (oc-types:percentage)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tx_bss_dot11_channel_utilization is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tx_bss_dot11_channel_utilization() directly.

    YANG Description: Channel utilization percent caused by transmission of any
802.11 frame within this BSS.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={u'range': [u'0..100']}), is_leaf=True, yang_name="tx-bss-dot11-channel-utilization", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:percentage', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tx_bss_dot11_channel_utilization must be of a type compatible with oc-types:percentage""",
          'defined-type': "oc-types:percentage",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={u'range': [u'0..100']}), is_leaf=True, yang_name="tx-bss-dot11-channel-utilization", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:percentage', is_config=False)""",
        })

    self.__tx_bss_dot11_channel_utilization = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tx_bss_dot11_channel_utilization(self):
    self.__tx_bss_dot11_channel_utilization = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={u'range': [u'0..100']}), is_leaf=True, yang_name="tx-bss-dot11-channel-utilization", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:percentage', is_config=False)


  def _get_tx_mgmt(self):
    """
    Getter method for tx_mgmt, mapped from YANG variable /access_points/access_point/ssids/ssid/bssids/bssid/state/counters/tx_mgmt (oc-yang:counter64)

    YANG Description: Transmitted 802.11 Management frames.
    """
    return self.__tx_mgmt
      
  def _set_tx_mgmt(self, v, load=False):
    """
    Setter method for tx_mgmt, mapped from YANG variable /access_points/access_point/ssids/ssid/bssids/bssid/state/counters/tx_mgmt (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tx_mgmt is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tx_mgmt() directly.

    YANG Description: Transmitted 802.11 Management frames.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="tx-mgmt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tx_mgmt must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="tx-mgmt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__tx_mgmt = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tx_mgmt(self):
    self.__tx_mgmt = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="tx-mgmt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)


  def _get_tx_control(self):
    """
    Getter method for tx_control, mapped from YANG variable /access_points/access_point/ssids/ssid/bssids/bssid/state/counters/tx_control (oc-yang:counter64)

    YANG Description: Transmitted 802.11 Control frames.
    """
    return self.__tx_control
      
  def _set_tx_control(self, v, load=False):
    """
    Setter method for tx_control, mapped from YANG variable /access_points/access_point/ssids/ssid/bssids/bssid/state/counters/tx_control (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tx_control is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tx_control() directly.

    YANG Description: Transmitted 802.11 Control frames.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="tx-control", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tx_control must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="tx-control", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__tx_control = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tx_control(self):
    self.__tx_control = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="tx-control", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)


  def _get_tx_data_dist(self):
    """
    Getter method for tx_data_dist, mapped from YANG variable /access_points/access_point/ssids/ssid/bssids/bssid/state/counters/tx_data_dist (container)

    YANG Description: The distribution of Data frame sizes in bytes of
successfully transmitted AMPDU, or MPDU for non-aggregated,
frames. The distribution should characterize frame sizes
starting at 64 bytes or less with the bin size doubling for
each successive bin to a maximum of 1MB or larger, as
represented in the following table:

Lower Bound Upper Bound
  0          64
  65         128
  129        256
  257        512
  513        1024
  1025       2048
  2049       4096
  4097       8192
  8193       16384
  16385      32768
  32769      65536
  65537      131072
  131073     262144
  262145     524288
  524289     1048576
    """
    return self.__tx_data_dist
      
  def _set_tx_data_dist(self, v, load=False):
    """
    Setter method for tx_data_dist, mapped from YANG variable /access_points/access_point/ssids/ssid/bssids/bssid/state/counters/tx_data_dist (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tx_data_dist is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tx_data_dist() directly.

    YANG Description: The distribution of Data frame sizes in bytes of
successfully transmitted AMPDU, or MPDU for non-aggregated,
frames. The distribution should characterize frame sizes
starting at 64 bytes or less with the bin size doubling for
each successive bin to a maximum of 1MB or larger, as
represented in the following table:

Lower Bound Upper Bound
  0          64
  65         128
  129        256
  257        512
  513        1024
  1025       2048
  2049       4096
  4097       8192
  8193       16384
  16385      32768
  32769      65536
  65537      131072
  131073     262144
  262145     524288
  524289     1048576
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_tx_data_dist_openconfig_access_points__access_points_access_point_ssids_ssid_bssids_bssid_state_counters_tx_data_dist, is_container='container', yang_name="tx-data-dist", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tx_data_dist must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_tx_data_dist_openconfig_access_points__access_points_access_point_ssids_ssid_bssids_bssid_state_counters_tx_data_dist, is_container='container', yang_name="tx-data-dist", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=False)""",
        })

    self.__tx_data_dist = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tx_data_dist(self):
    self.__tx_data_dist = YANGDynClass(base=yc_tx_data_dist_openconfig_access_points__access_points_access_point_ssids_ssid_bssids_bssid_state_counters_tx_data_dist, is_container='container', yang_name="tx-data-dist", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=False)


  def _get_tx_data_wmm(self):
    """
    Getter method for tx_data_wmm, mapped from YANG variable /access_points/access_point/ssids/ssid/bssids/bssid/state/counters/tx_data_wmm (container)

    YANG Description: Transmitted QoS Data frames, per WMM AC.
    """
    return self.__tx_data_wmm
      
  def _set_tx_data_wmm(self, v, load=False):
    """
    Setter method for tx_data_wmm, mapped from YANG variable /access_points/access_point/ssids/ssid/bssids/bssid/state/counters/tx_data_wmm (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tx_data_wmm is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tx_data_wmm() directly.

    YANG Description: Transmitted QoS Data frames, per WMM AC.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_tx_data_wmm_openconfig_access_points__access_points_access_point_ssids_ssid_bssids_bssid_state_counters_tx_data_wmm, is_container='container', yang_name="tx-data-wmm", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tx_data_wmm must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_tx_data_wmm_openconfig_access_points__access_points_access_point_ssids_ssid_bssids_bssid_state_counters_tx_data_wmm, is_container='container', yang_name="tx-data-wmm", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=False)""",
        })

    self.__tx_data_wmm = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tx_data_wmm(self):
    self.__tx_data_wmm = YANGDynClass(base=yc_tx_data_wmm_openconfig_access_points__access_points_access_point_ssids_ssid_bssids_bssid_state_counters_tx_data_wmm, is_container='container', yang_name="tx-data-wmm", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=False)


  def _get_tx_mcs(self):
    """
    Getter method for tx_mcs, mapped from YANG variable /access_points/access_point/ssids/ssid/bssids/bssid/state/counters/tx_mcs (container)

    YANG Description: Transmitted Data frames, per MCS Index. It is expected that
vendors bucketize 802.11n MCS frames in their matching
802.11ac buckets.

Example, 802.11n MCS 15 = 802.11ac MCS 7.
802.11n MCS 20 = 802.11ac MCS 4.
    """
    return self.__tx_mcs
      
  def _set_tx_mcs(self, v, load=False):
    """
    Setter method for tx_mcs, mapped from YANG variable /access_points/access_point/ssids/ssid/bssids/bssid/state/counters/tx_mcs (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tx_mcs is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tx_mcs() directly.

    YANG Description: Transmitted Data frames, per MCS Index. It is expected that
vendors bucketize 802.11n MCS frames in their matching
802.11ac buckets.

Example, 802.11n MCS 15 = 802.11ac MCS 7.
802.11n MCS 20 = 802.11ac MCS 4.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_tx_mcs_openconfig_access_points__access_points_access_point_ssids_ssid_bssids_bssid_state_counters_tx_mcs, is_container='container', yang_name="tx-mcs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tx_mcs must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_tx_mcs_openconfig_access_points__access_points_access_point_ssids_ssid_bssids_bssid_state_counters_tx_mcs, is_container='container', yang_name="tx-mcs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=False)""",
        })

    self.__tx_mcs = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tx_mcs(self):
    self.__tx_mcs = YANGDynClass(base=yc_tx_mcs_openconfig_access_points__access_points_access_point_ssids_ssid_bssids_bssid_state_counters_tx_mcs, is_container='container', yang_name="tx-mcs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=False)


  def _get_tx_retries(self):
    """
    Getter method for tx_retries, mapped from YANG variable /access_points/access_point/ssids/ssid/bssids/bssid/state/counters/tx_retries (oc-yang:counter64)

    YANG Description: Number of frames transmitted with the Retry bit set
    """
    return self.__tx_retries
      
  def _set_tx_retries(self, v, load=False):
    """
    Setter method for tx_retries, mapped from YANG variable /access_points/access_point/ssids/ssid/bssids/bssid/state/counters/tx_retries (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tx_retries is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tx_retries() directly.

    YANG Description: Number of frames transmitted with the Retry bit set
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="tx-retries", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tx_retries must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="tx-retries", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__tx_retries = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tx_retries(self):
    self.__tx_retries = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="tx-retries", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)


  def _get_tx_retries_data(self):
    """
    Getter method for tx_retries_data, mapped from YANG variable /access_points/access_point/ssids/ssid/bssids/bssid/state/counters/tx_retries_data (oc-yang:counter64)

    YANG Description: Number of transmitted QoS Data frames with the Retry bit
set
    """
    return self.__tx_retries_data
      
  def _set_tx_retries_data(self, v, load=False):
    """
    Setter method for tx_retries_data, mapped from YANG variable /access_points/access_point/ssids/ssid/bssids/bssid/state/counters/tx_retries_data (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tx_retries_data is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tx_retries_data() directly.

    YANG Description: Number of transmitted QoS Data frames with the Retry bit
set
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="tx-retries-data", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tx_retries_data must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="tx-retries-data", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__tx_retries_data = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tx_retries_data(self):
    self.__tx_retries_data = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="tx-retries-data", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)


  def _get_tx_retries_subframe(self):
    """
    Getter method for tx_retries_subframe, mapped from YANG variable /access_points/access_point/ssids/ssid/bssids/bssid/state/counters/tx_retries_subframe (oc-yang:counter64)

    YANG Description: Aggregated MPDUs which had individual subframes that fail
and require retransmission.
    """
    return self.__tx_retries_subframe
      
  def _set_tx_retries_subframe(self, v, load=False):
    """
    Setter method for tx_retries_subframe, mapped from YANG variable /access_points/access_point/ssids/ssid/bssids/bssid/state/counters/tx_retries_subframe (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tx_retries_subframe is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tx_retries_subframe() directly.

    YANG Description: Aggregated MPDUs which had individual subframes that fail
and require retransmission.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="tx-retries-subframe", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tx_retries_subframe must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="tx-retries-subframe", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__tx_retries_subframe = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tx_retries_subframe(self):
    self.__tx_retries_subframe = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="tx-retries-subframe", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)


  def _get_tx_bytes_data(self):
    """
    Getter method for tx_bytes_data, mapped from YANG variable /access_points/access_point/ssids/ssid/bssids/bssid/state/counters/tx_bytes_data (oc-yang:counter64)

    YANG Description: Bytes transmitted from QoS Data frames
    """
    return self.__tx_bytes_data
      
  def _set_tx_bytes_data(self, v, load=False):
    """
    Setter method for tx_bytes_data, mapped from YANG variable /access_points/access_point/ssids/ssid/bssids/bssid/state/counters/tx_bytes_data (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tx_bytes_data is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tx_bytes_data() directly.

    YANG Description: Bytes transmitted from QoS Data frames
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="tx-bytes-data", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tx_bytes_data must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="tx-bytes-data", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__tx_bytes_data = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tx_bytes_data(self):
    self.__tx_bytes_data = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="tx-bytes-data", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)


  def _get_bss_channel_utilization(self):
    """
    Getter method for bss_channel_utilization, mapped from YANG variable /access_points/access_point/ssids/ssid/bssids/bssid/state/counters/bss_channel_utilization (oc-types:percentage)

    YANG Description: Total 802.11 channel utilization in this BSS. The total
channel utilization should include all time periods the AP
spent actively receiving and transmitting 802.11 frames in
this BSS.
    """
    return self.__bss_channel_utilization
      
  def _set_bss_channel_utilization(self, v, load=False):
    """
    Setter method for bss_channel_utilization, mapped from YANG variable /access_points/access_point/ssids/ssid/bssids/bssid/state/counters/bss_channel_utilization (oc-types:percentage)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bss_channel_utilization is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bss_channel_utilization() directly.

    YANG Description: Total 802.11 channel utilization in this BSS. The total
channel utilization should include all time periods the AP
spent actively receiving and transmitting 802.11 frames in
this BSS.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={u'range': [u'0..100']}), is_leaf=True, yang_name="bss-channel-utilization", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:percentage', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bss_channel_utilization must be of a type compatible with oc-types:percentage""",
          'defined-type': "oc-types:percentage",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={u'range': [u'0..100']}), is_leaf=True, yang_name="bss-channel-utilization", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:percentage', is_config=False)""",
        })

    self.__bss_channel_utilization = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bss_channel_utilization(self):
    self.__bss_channel_utilization = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={u'range': [u'0..100']}), is_leaf=True, yang_name="bss-channel-utilization", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:percentage', is_config=False)

  rx_bss_dot11_channel_utilization = __builtin__.property(_get_rx_bss_dot11_channel_utilization)
  rx_mgmt = __builtin__.property(_get_rx_mgmt)
  rx_control = __builtin__.property(_get_rx_control)
  rx_data_dist = __builtin__.property(_get_rx_data_dist)
  rx_data_wmm = __builtin__.property(_get_rx_data_wmm)
  rx_mcs = __builtin__.property(_get_rx_mcs)
  rx_retries = __builtin__.property(_get_rx_retries)
  rx_retries_data = __builtin__.property(_get_rx_retries_data)
  rx_retries_subframe = __builtin__.property(_get_rx_retries_subframe)
  rx_bytes_data = __builtin__.property(_get_rx_bytes_data)
  tx_bss_dot11_channel_utilization = __builtin__.property(_get_tx_bss_dot11_channel_utilization)
  tx_mgmt = __builtin__.property(_get_tx_mgmt)
  tx_control = __builtin__.property(_get_tx_control)
  tx_data_dist = __builtin__.property(_get_tx_data_dist)
  tx_data_wmm = __builtin__.property(_get_tx_data_wmm)
  tx_mcs = __builtin__.property(_get_tx_mcs)
  tx_retries = __builtin__.property(_get_tx_retries)
  tx_retries_data = __builtin__.property(_get_tx_retries_data)
  tx_retries_subframe = __builtin__.property(_get_tx_retries_subframe)
  tx_bytes_data = __builtin__.property(_get_tx_bytes_data)
  bss_channel_utilization = __builtin__.property(_get_bss_channel_utilization)


  _pyangbind_elements = OrderedDict([('rx_bss_dot11_channel_utilization', rx_bss_dot11_channel_utilization), ('rx_mgmt', rx_mgmt), ('rx_control', rx_control), ('rx_data_dist', rx_data_dist), ('rx_data_wmm', rx_data_wmm), ('rx_mcs', rx_mcs), ('rx_retries', rx_retries), ('rx_retries_data', rx_retries_data), ('rx_retries_subframe', rx_retries_subframe), ('rx_bytes_data', rx_bytes_data), ('tx_bss_dot11_channel_utilization', tx_bss_dot11_channel_utilization), ('tx_mgmt', tx_mgmt), ('tx_control', tx_control), ('tx_data_dist', tx_data_dist), ('tx_data_wmm', tx_data_wmm), ('tx_mcs', tx_mcs), ('tx_retries', tx_retries), ('tx_retries_data', tx_retries_data), ('tx_retries_subframe', tx_retries_subframe), ('tx_bytes_data', tx_bytes_data), ('bss_channel_utilization', bss_channel_utilization), ])


class yc_state_openconfig_access_points__access_points_access_point_ssids_ssid_bssids_bssid_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-access-points - based on the path /access-points/access-point/ssids/ssid/bssids/bssid/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: BSSID state data.
  """
  __slots__ = ('_path_helper', '_extmethods', '__bssid','__radio_id','__num_associated_clients','__counters',)

  _yang_name = 'state'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__radio_id = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="radio-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint8', is_config=False)
    self.__num_associated_clients = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="num-associated-clients", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint8', is_config=False)
    self.__bssid = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}$'}), is_leaf=True, yang_name="bssid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:mac-address', is_config=False)
    self.__counters = YANGDynClass(base=yc_counters_openconfig_access_points__access_points_access_point_ssids_ssid_bssids_bssid_state_counters, is_container='container', yang_name="counters", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'access-points', u'access-point', u'ssids', u'ssid', u'bssids', u'bssid', u'state']

  def _get_bssid(self):
    """
    Getter method for bssid, mapped from YANG variable /access_points/access_point/ssids/ssid/bssids/bssid/state/bssid (oc-yang:mac-address)

    YANG Description: MAC of the BSS.
    """
    return self.__bssid
      
  def _set_bssid(self, v, load=False):
    """
    Setter method for bssid, mapped from YANG variable /access_points/access_point/ssids/ssid/bssids/bssid/state/bssid (oc-yang:mac-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bssid is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bssid() directly.

    YANG Description: MAC of the BSS.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}$'}), is_leaf=True, yang_name="bssid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:mac-address', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bssid must be of a type compatible with oc-yang:mac-address""",
          'defined-type': "oc-yang:mac-address",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}$'}), is_leaf=True, yang_name="bssid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:mac-address', is_config=False)""",
        })

    self.__bssid = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bssid(self):
    self.__bssid = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}$'}), is_leaf=True, yang_name="bssid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:mac-address', is_config=False)


  def _get_radio_id(self):
    """
    Getter method for radio_id, mapped from YANG variable /access_points/access_point/ssids/ssid/bssids/bssid/state/radio_id (uint8)

    YANG Description: The configured id of the radio
    """
    return self.__radio_id
      
  def _set_radio_id(self, v, load=False):
    """
    Setter method for radio_id, mapped from YANG variable /access_points/access_point/ssids/ssid/bssids/bssid/state/radio_id (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_radio_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_radio_id() directly.

    YANG Description: The configured id of the radio
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="radio-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint8', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """radio_id must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="radio-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint8', is_config=False)""",
        })

    self.__radio_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_radio_id(self):
    self.__radio_id = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="radio-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint8', is_config=False)


  def _get_num_associated_clients(self):
    """
    Getter method for num_associated_clients, mapped from YANG variable /access_points/access_point/ssids/ssid/bssids/bssid/state/num_associated_clients (uint8)

    YANG Description: Number of associated STAs to this BSS.
    """
    return self.__num_associated_clients
      
  def _set_num_associated_clients(self, v, load=False):
    """
    Setter method for num_associated_clients, mapped from YANG variable /access_points/access_point/ssids/ssid/bssids/bssid/state/num_associated_clients (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_num_associated_clients is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_num_associated_clients() directly.

    YANG Description: Number of associated STAs to this BSS.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="num-associated-clients", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint8', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """num_associated_clients must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="num-associated-clients", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint8', is_config=False)""",
        })

    self.__num_associated_clients = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_num_associated_clients(self):
    self.__num_associated_clients = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="num-associated-clients", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint8', is_config=False)


  def _get_counters(self):
    """
    Getter method for counters, mapped from YANG variable /access_points/access_point/ssids/ssid/bssids/bssid/state/counters (container)

    YANG Description: BSS Counters.
    """
    return self.__counters
      
  def _set_counters(self, v, load=False):
    """
    Setter method for counters, mapped from YANG variable /access_points/access_point/ssids/ssid/bssids/bssid/state/counters (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_counters is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_counters() directly.

    YANG Description: BSS Counters.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_counters_openconfig_access_points__access_points_access_point_ssids_ssid_bssids_bssid_state_counters, is_container='container', yang_name="counters", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """counters must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_counters_openconfig_access_points__access_points_access_point_ssids_ssid_bssids_bssid_state_counters, is_container='container', yang_name="counters", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=False)""",
        })

    self.__counters = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_counters(self):
    self.__counters = YANGDynClass(base=yc_counters_openconfig_access_points__access_points_access_point_ssids_ssid_bssids_bssid_state_counters, is_container='container', yang_name="counters", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=False)

  bssid = __builtin__.property(_get_bssid)
  radio_id = __builtin__.property(_get_radio_id)
  num_associated_clients = __builtin__.property(_get_num_associated_clients)
  counters = __builtin__.property(_get_counters)


  _pyangbind_elements = OrderedDict([('bssid', bssid), ('radio_id', radio_id), ('num_associated_clients', num_associated_clients), ('counters', counters), ])


class yc_bssid_openconfig_access_points__access_points_access_point_ssids_ssid_bssids_bssid(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-access-points - based on the path /access-points/access-point/ssids/ssid/bssids/bssid. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of BSSIDs and what radio-id they utilize. Radio-id
included here to allocate for APs with dual 5GHz radios.
Usage of paths allows for discovery and subscription of
State data per BSSID, regardless of radio.
  """
  __slots__ = ('_path_helper', '_extmethods', '__bssid','__radio_id','__state',)

  _yang_name = 'bssid'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__state = YANGDynClass(base=yc_state_openconfig_access_points__access_points_access_point_ssids_ssid_bssids_bssid_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=False)
    self.__radio_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="radio-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='leafref', is_config=False)
    self.__bssid = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="bssid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='leafref', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'access-points', u'access-point', u'ssids', u'ssid', u'bssids', u'bssid']

  def _get_bssid(self):
    """
    Getter method for bssid, mapped from YANG variable /access_points/access_point/ssids/ssid/bssids/bssid/bssid (leafref)

    YANG Description: The BSSID MAC address.
    """
    return self.__bssid
      
  def _set_bssid(self, v, load=False):
    """
    Setter method for bssid, mapped from YANG variable /access_points/access_point/ssids/ssid/bssids/bssid/bssid (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bssid is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bssid() directly.

    YANG Description: The BSSID MAC address.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="bssid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='leafref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bssid must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="bssid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='leafref', is_config=False)""",
        })

    self.__bssid = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bssid(self):
    self.__bssid = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="bssid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='leafref', is_config=False)


  def _get_radio_id(self):
    """
    Getter method for radio_id, mapped from YANG variable /access_points/access_point/ssids/ssid/bssids/bssid/radio_id (leafref)

    YANG Description: References the configured id of the radio
    """
    return self.__radio_id
      
  def _set_radio_id(self, v, load=False):
    """
    Setter method for radio_id, mapped from YANG variable /access_points/access_point/ssids/ssid/bssids/bssid/radio_id (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_radio_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_radio_id() directly.

    YANG Description: References the configured id of the radio
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="radio-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='leafref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """radio_id must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="radio-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='leafref', is_config=False)""",
        })

    self.__radio_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_radio_id(self):
    self.__radio_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="radio-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='leafref', is_config=False)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /access_points/access_point/ssids/ssid/bssids/bssid/state (container)

    YANG Description: BSSID state data.
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /access_points/access_point/ssids/ssid/bssids/bssid/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: BSSID state data.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_access_points__access_points_access_point_ssids_ssid_bssids_bssid_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_access_points__access_points_access_point_ssids_ssid_bssids_bssid_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=False)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_access_points__access_points_access_point_ssids_ssid_bssids_bssid_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=False)

  bssid = __builtin__.property(_get_bssid)
  radio_id = __builtin__.property(_get_radio_id)
  state = __builtin__.property(_get_state)


  _pyangbind_elements = OrderedDict([('bssid', bssid), ('radio_id', radio_id), ('state', state), ])


class yc_bssids_openconfig_access_points__access_points_access_point_ssids_ssid_bssids(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-access-points - based on the path /access-points/access-point/ssids/ssid/bssids. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Top-level container for BSSIDs operational state data.
  """
  __slots__ = ('_path_helper', '_extmethods', '__bssid',)

  _yang_name = 'bssids'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__bssid = YANGDynClass(base=YANGListType("radio_id bssid",yc_bssid_openconfig_access_points__access_points_access_point_ssids_ssid_bssids_bssid, yang_name="bssid", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='radio-id bssid', extensions=None), is_container='list', yang_name="bssid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'access-points', u'access-point', u'ssids', u'ssid', u'bssids']

  def _get_bssid(self):
    """
    Getter method for bssid, mapped from YANG variable /access_points/access_point/ssids/ssid/bssids/bssid (list)

    YANG Description: List of BSSIDs and what radio-id they utilize. Radio-id
included here to allocate for APs with dual 5GHz radios.
Usage of paths allows for discovery and subscription of
State data per BSSID, regardless of radio.
    """
    return self.__bssid
      
  def _set_bssid(self, v, load=False):
    """
    Setter method for bssid, mapped from YANG variable /access_points/access_point/ssids/ssid/bssids/bssid (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bssid is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bssid() directly.

    YANG Description: List of BSSIDs and what radio-id they utilize. Radio-id
included here to allocate for APs with dual 5GHz radios.
Usage of paths allows for discovery and subscription of
State data per BSSID, regardless of radio.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("radio_id bssid",yc_bssid_openconfig_access_points__access_points_access_point_ssids_ssid_bssids_bssid, yang_name="bssid", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='radio-id bssid', extensions=None), is_container='list', yang_name="bssid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bssid must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("radio_id bssid",yc_bssid_openconfig_access_points__access_points_access_point_ssids_ssid_bssids_bssid, yang_name="bssid", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='radio-id bssid', extensions=None), is_container='list', yang_name="bssid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='list', is_config=True)""",
        })

    self.__bssid = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bssid(self):
    self.__bssid = YANGDynClass(base=YANGListType("radio_id bssid",yc_bssid_openconfig_access_points__access_points_access_point_ssids_ssid_bssids_bssid, yang_name="bssid", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='radio-id bssid', extensions=None), is_container='list', yang_name="bssid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='list', is_config=True)

  bssid = __builtin__.property(_get_bssid, _set_bssid)


  _pyangbind_elements = OrderedDict([('bssid', bssid), ])


class yc_config_openconfig_access_points__access_points_access_point_ssids_ssid_wmm_config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-access-points - based on the path /access-points/access-point/ssids/ssid/wmm/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Container for WMM configuration elements.
  """
  __slots__ = ('_path_helper', '_extmethods', '__trust_dscp','__wmm_vo_remark','__wmm_vi_remark','__wmm_be_remark','__wmm_bk_remark',)

  _yang_name = 'config'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__wmm_vo_remark = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)), is_leaf=False, yang_name="wmm-vo-remark", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint8', is_config=True)
    self.__wmm_vi_remark = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)), is_leaf=False, yang_name="wmm-vi-remark", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint8', is_config=True)
    self.__trust_dscp = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="trust-dscp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=True)
    self.__wmm_be_remark = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)), is_leaf=False, yang_name="wmm-be-remark", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint8', is_config=True)
    self.__wmm_bk_remark = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)), is_leaf=False, yang_name="wmm-bk-remark", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint8', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'access-points', u'access-point', u'ssids', u'ssid', u'wmm', u'config']

  def _get_trust_dscp(self):
    """
    Getter method for trust_dscp, mapped from YANG variable /access_points/access_point/ssids/ssid/wmm/config/trust_dscp (boolean)

    YANG Description: The AP should trust DSCP on 802.11 frames received
in this BSS.
    """
    return self.__trust_dscp
      
  def _set_trust_dscp(self, v, load=False):
    """
    Setter method for trust_dscp, mapped from YANG variable /access_points/access_point/ssids/ssid/wmm/config/trust_dscp (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_trust_dscp is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_trust_dscp() directly.

    YANG Description: The AP should trust DSCP on 802.11 frames received
in this BSS.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="trust-dscp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """trust_dscp must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="trust-dscp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=True)""",
        })

    self.__trust_dscp = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_trust_dscp(self):
    self.__trust_dscp = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="trust-dscp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=True)


  def _get_wmm_vo_remark(self):
    """
    Getter method for wmm_vo_remark, mapped from YANG variable /access_points/access_point/ssids/ssid/wmm/config/wmm_vo_remark (uint8)

    YANG Description: Allowed DSCP markings for WMM AC_VO. Remark to lowest in this
list if DSCP marking falls outside of these allowed markings.

From 1 (min) to 8 (max) integers.
    """
    return self.__wmm_vo_remark
      
  def _set_wmm_vo_remark(self, v, load=False):
    """
    Setter method for wmm_vo_remark, mapped from YANG variable /access_points/access_point/ssids/ssid/wmm/config/wmm_vo_remark (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_wmm_vo_remark is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_wmm_vo_remark() directly.

    YANG Description: Allowed DSCP markings for WMM AC_VO. Remark to lowest in this
list if DSCP marking falls outside of these allowed markings.

From 1 (min) to 8 (max) integers.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)), is_leaf=False, yang_name="wmm-vo-remark", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """wmm_vo_remark must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)), is_leaf=False, yang_name="wmm-vo-remark", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint8', is_config=True)""",
        })

    self.__wmm_vo_remark = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_wmm_vo_remark(self):
    self.__wmm_vo_remark = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)), is_leaf=False, yang_name="wmm-vo-remark", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint8', is_config=True)


  def _get_wmm_vi_remark(self):
    """
    Getter method for wmm_vi_remark, mapped from YANG variable /access_points/access_point/ssids/ssid/wmm/config/wmm_vi_remark (uint8)

    YANG Description: Allowed DSCP markings for WMM AC_VI. Remark to lowest in this
list if DSCP marking falls outside of these allowed markings.

From 1 (min) to 8 (max) integers.
    """
    return self.__wmm_vi_remark
      
  def _set_wmm_vi_remark(self, v, load=False):
    """
    Setter method for wmm_vi_remark, mapped from YANG variable /access_points/access_point/ssids/ssid/wmm/config/wmm_vi_remark (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_wmm_vi_remark is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_wmm_vi_remark() directly.

    YANG Description: Allowed DSCP markings for WMM AC_VI. Remark to lowest in this
list if DSCP marking falls outside of these allowed markings.

From 1 (min) to 8 (max) integers.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)), is_leaf=False, yang_name="wmm-vi-remark", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """wmm_vi_remark must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)), is_leaf=False, yang_name="wmm-vi-remark", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint8', is_config=True)""",
        })

    self.__wmm_vi_remark = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_wmm_vi_remark(self):
    self.__wmm_vi_remark = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)), is_leaf=False, yang_name="wmm-vi-remark", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint8', is_config=True)


  def _get_wmm_be_remark(self):
    """
    Getter method for wmm_be_remark, mapped from YANG variable /access_points/access_point/ssids/ssid/wmm/config/wmm_be_remark (uint8)

    YANG Description: Allowed DSCP markings for WMM AC_BE. Remark to lowest in this
list if DSCP marking falls outside of these allowed markings.

From 1 (min) to 8 (max) integers.
    """
    return self.__wmm_be_remark
      
  def _set_wmm_be_remark(self, v, load=False):
    """
    Setter method for wmm_be_remark, mapped from YANG variable /access_points/access_point/ssids/ssid/wmm/config/wmm_be_remark (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_wmm_be_remark is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_wmm_be_remark() directly.

    YANG Description: Allowed DSCP markings for WMM AC_BE. Remark to lowest in this
list if DSCP marking falls outside of these allowed markings.

From 1 (min) to 8 (max) integers.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)), is_leaf=False, yang_name="wmm-be-remark", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """wmm_be_remark must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)), is_leaf=False, yang_name="wmm-be-remark", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint8', is_config=True)""",
        })

    self.__wmm_be_remark = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_wmm_be_remark(self):
    self.__wmm_be_remark = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)), is_leaf=False, yang_name="wmm-be-remark", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint8', is_config=True)


  def _get_wmm_bk_remark(self):
    """
    Getter method for wmm_bk_remark, mapped from YANG variable /access_points/access_point/ssids/ssid/wmm/config/wmm_bk_remark (uint8)

    YANG Description: Allowed DSCP markings for WMM AC_BK. Remark to lowest in this
list if DSCP marking falls outside of these allowed markings.

From 1 (min) to 8 (max) integers.
    """
    return self.__wmm_bk_remark
      
  def _set_wmm_bk_remark(self, v, load=False):
    """
    Setter method for wmm_bk_remark, mapped from YANG variable /access_points/access_point/ssids/ssid/wmm/config/wmm_bk_remark (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_wmm_bk_remark is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_wmm_bk_remark() directly.

    YANG Description: Allowed DSCP markings for WMM AC_BK. Remark to lowest in this
list if DSCP marking falls outside of these allowed markings.

From 1 (min) to 8 (max) integers.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)), is_leaf=False, yang_name="wmm-bk-remark", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """wmm_bk_remark must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)), is_leaf=False, yang_name="wmm-bk-remark", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint8', is_config=True)""",
        })

    self.__wmm_bk_remark = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_wmm_bk_remark(self):
    self.__wmm_bk_remark = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)), is_leaf=False, yang_name="wmm-bk-remark", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint8', is_config=True)

  trust_dscp = __builtin__.property(_get_trust_dscp, _set_trust_dscp)
  wmm_vo_remark = __builtin__.property(_get_wmm_vo_remark, _set_wmm_vo_remark)
  wmm_vi_remark = __builtin__.property(_get_wmm_vi_remark, _set_wmm_vi_remark)
  wmm_be_remark = __builtin__.property(_get_wmm_be_remark, _set_wmm_be_remark)
  wmm_bk_remark = __builtin__.property(_get_wmm_bk_remark, _set_wmm_bk_remark)


  _pyangbind_elements = OrderedDict([('trust_dscp', trust_dscp), ('wmm_vo_remark', wmm_vo_remark), ('wmm_vi_remark', wmm_vi_remark), ('wmm_be_remark', wmm_be_remark), ('wmm_bk_remark', wmm_bk_remark), ])


class yc_state_openconfig_access_points__access_points_access_point_ssids_ssid_wmm_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-access-points - based on the path /access-points/access-point/ssids/ssid/wmm/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Container for WMM state elements.
  """
  __slots__ = ('_path_helper', '_extmethods', '__trust_dscp','__wmm_vo_remark','__wmm_vi_remark','__wmm_be_remark','__wmm_bk_remark',)

  _yang_name = 'state'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__wmm_vo_remark = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)), is_leaf=False, yang_name="wmm-vo-remark", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint8', is_config=False)
    self.__wmm_vi_remark = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)), is_leaf=False, yang_name="wmm-vi-remark", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint8', is_config=False)
    self.__trust_dscp = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="trust-dscp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=False)
    self.__wmm_be_remark = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)), is_leaf=False, yang_name="wmm-be-remark", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint8', is_config=False)
    self.__wmm_bk_remark = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)), is_leaf=False, yang_name="wmm-bk-remark", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint8', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'access-points', u'access-point', u'ssids', u'ssid', u'wmm', u'state']

  def _get_trust_dscp(self):
    """
    Getter method for trust_dscp, mapped from YANG variable /access_points/access_point/ssids/ssid/wmm/state/trust_dscp (boolean)

    YANG Description: The AP should trust DSCP on 802.11 frames received
in this BSS.
    """
    return self.__trust_dscp
      
  def _set_trust_dscp(self, v, load=False):
    """
    Setter method for trust_dscp, mapped from YANG variable /access_points/access_point/ssids/ssid/wmm/state/trust_dscp (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_trust_dscp is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_trust_dscp() directly.

    YANG Description: The AP should trust DSCP on 802.11 frames received
in this BSS.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="trust-dscp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """trust_dscp must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="trust-dscp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=False)""",
        })

    self.__trust_dscp = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_trust_dscp(self):
    self.__trust_dscp = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="trust-dscp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=False)


  def _get_wmm_vo_remark(self):
    """
    Getter method for wmm_vo_remark, mapped from YANG variable /access_points/access_point/ssids/ssid/wmm/state/wmm_vo_remark (uint8)

    YANG Description: Allowed DSCP markings for WMM AC_VO. Remark to lowest in this
list if DSCP marking falls outside of these allowed markings.

From 1 (min) to 8 (max) integers.
    """
    return self.__wmm_vo_remark
      
  def _set_wmm_vo_remark(self, v, load=False):
    """
    Setter method for wmm_vo_remark, mapped from YANG variable /access_points/access_point/ssids/ssid/wmm/state/wmm_vo_remark (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_wmm_vo_remark is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_wmm_vo_remark() directly.

    YANG Description: Allowed DSCP markings for WMM AC_VO. Remark to lowest in this
list if DSCP marking falls outside of these allowed markings.

From 1 (min) to 8 (max) integers.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)), is_leaf=False, yang_name="wmm-vo-remark", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint8', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """wmm_vo_remark must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)), is_leaf=False, yang_name="wmm-vo-remark", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint8', is_config=False)""",
        })

    self.__wmm_vo_remark = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_wmm_vo_remark(self):
    self.__wmm_vo_remark = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)), is_leaf=False, yang_name="wmm-vo-remark", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint8', is_config=False)


  def _get_wmm_vi_remark(self):
    """
    Getter method for wmm_vi_remark, mapped from YANG variable /access_points/access_point/ssids/ssid/wmm/state/wmm_vi_remark (uint8)

    YANG Description: Allowed DSCP markings for WMM AC_VI. Remark to lowest in this
list if DSCP marking falls outside of these allowed markings.

From 1 (min) to 8 (max) integers.
    """
    return self.__wmm_vi_remark
      
  def _set_wmm_vi_remark(self, v, load=False):
    """
    Setter method for wmm_vi_remark, mapped from YANG variable /access_points/access_point/ssids/ssid/wmm/state/wmm_vi_remark (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_wmm_vi_remark is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_wmm_vi_remark() directly.

    YANG Description: Allowed DSCP markings for WMM AC_VI. Remark to lowest in this
list if DSCP marking falls outside of these allowed markings.

From 1 (min) to 8 (max) integers.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)), is_leaf=False, yang_name="wmm-vi-remark", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint8', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """wmm_vi_remark must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)), is_leaf=False, yang_name="wmm-vi-remark", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint8', is_config=False)""",
        })

    self.__wmm_vi_remark = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_wmm_vi_remark(self):
    self.__wmm_vi_remark = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)), is_leaf=False, yang_name="wmm-vi-remark", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint8', is_config=False)


  def _get_wmm_be_remark(self):
    """
    Getter method for wmm_be_remark, mapped from YANG variable /access_points/access_point/ssids/ssid/wmm/state/wmm_be_remark (uint8)

    YANG Description: Allowed DSCP markings for WMM AC_BE. Remark to lowest in this
list if DSCP marking falls outside of these allowed markings.

From 1 (min) to 8 (max) integers.
    """
    return self.__wmm_be_remark
      
  def _set_wmm_be_remark(self, v, load=False):
    """
    Setter method for wmm_be_remark, mapped from YANG variable /access_points/access_point/ssids/ssid/wmm/state/wmm_be_remark (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_wmm_be_remark is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_wmm_be_remark() directly.

    YANG Description: Allowed DSCP markings for WMM AC_BE. Remark to lowest in this
list if DSCP marking falls outside of these allowed markings.

From 1 (min) to 8 (max) integers.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)), is_leaf=False, yang_name="wmm-be-remark", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint8', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """wmm_be_remark must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)), is_leaf=False, yang_name="wmm-be-remark", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint8', is_config=False)""",
        })

    self.__wmm_be_remark = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_wmm_be_remark(self):
    self.__wmm_be_remark = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)), is_leaf=False, yang_name="wmm-be-remark", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint8', is_config=False)


  def _get_wmm_bk_remark(self):
    """
    Getter method for wmm_bk_remark, mapped from YANG variable /access_points/access_point/ssids/ssid/wmm/state/wmm_bk_remark (uint8)

    YANG Description: Allowed DSCP markings for WMM AC_BK. Remark to lowest in this
list if DSCP marking falls outside of these allowed markings.

From 1 (min) to 8 (max) integers.
    """
    return self.__wmm_bk_remark
      
  def _set_wmm_bk_remark(self, v, load=False):
    """
    Setter method for wmm_bk_remark, mapped from YANG variable /access_points/access_point/ssids/ssid/wmm/state/wmm_bk_remark (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_wmm_bk_remark is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_wmm_bk_remark() directly.

    YANG Description: Allowed DSCP markings for WMM AC_BK. Remark to lowest in this
list if DSCP marking falls outside of these allowed markings.

From 1 (min) to 8 (max) integers.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)), is_leaf=False, yang_name="wmm-bk-remark", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint8', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """wmm_bk_remark must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)), is_leaf=False, yang_name="wmm-bk-remark", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint8', is_config=False)""",
        })

    self.__wmm_bk_remark = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_wmm_bk_remark(self):
    self.__wmm_bk_remark = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)), is_leaf=False, yang_name="wmm-bk-remark", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint8', is_config=False)

  trust_dscp = __builtin__.property(_get_trust_dscp)
  wmm_vo_remark = __builtin__.property(_get_wmm_vo_remark)
  wmm_vi_remark = __builtin__.property(_get_wmm_vi_remark)
  wmm_be_remark = __builtin__.property(_get_wmm_be_remark)
  wmm_bk_remark = __builtin__.property(_get_wmm_bk_remark)


  _pyangbind_elements = OrderedDict([('trust_dscp', trust_dscp), ('wmm_vo_remark', wmm_vo_remark), ('wmm_vi_remark', wmm_vi_remark), ('wmm_be_remark', wmm_be_remark), ('wmm_bk_remark', wmm_bk_remark), ])


class yc_wmm_openconfig_access_points__access_points_access_point_ssids_ssid_wmm(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-access-points - based on the path /access-points/access-point/ssids/ssid/wmm. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Top-level container for WMM configuration and
state container.
  """
  __slots__ = ('_path_helper', '_extmethods', '__config','__state',)

  _yang_name = 'wmm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__state = YANGDynClass(base=yc_state_openconfig_access_points__access_points_access_point_ssids_ssid_wmm_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)
    self.__config = YANGDynClass(base=yc_config_openconfig_access_points__access_points_access_point_ssids_ssid_wmm_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'access-points', u'access-point', u'ssids', u'ssid', u'wmm']

  def _get_config(self):
    """
    Getter method for config, mapped from YANG variable /access_points/access_point/ssids/ssid/wmm/config (container)

    YANG Description: Container for WMM configuration elements.
    """
    return self.__config
      
  def _set_config(self, v, load=False):
    """
    Setter method for config, mapped from YANG variable /access_points/access_point/ssids/ssid/wmm/config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config() directly.

    YANG Description: Container for WMM configuration elements.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_config_openconfig_access_points__access_points_access_point_ssids_ssid_wmm_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_config_openconfig_access_points__access_points_access_point_ssids_ssid_wmm_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)""",
        })

    self.__config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config(self):
    self.__config = YANGDynClass(base=yc_config_openconfig_access_points__access_points_access_point_ssids_ssid_wmm_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /access_points/access_point/ssids/ssid/wmm/state (container)

    YANG Description: Container for WMM state elements.
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /access_points/access_point/ssids/ssid/wmm/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: Container for WMM state elements.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_access_points__access_points_access_point_ssids_ssid_wmm_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_access_points__access_points_access_point_ssids_ssid_wmm_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_access_points__access_points_access_point_ssids_ssid_wmm_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)

  config = __builtin__.property(_get_config, _set_config)
  state = __builtin__.property(_get_state, _set_state)


  _pyangbind_elements = OrderedDict([('config', config), ('state', state), ])


class yc_config_openconfig_access_points__access_points_access_point_ssids_ssid_dot11r_config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-access-points - based on the path /access-points/access-point/ssids/ssid/dot11r/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Container for 802.11r configuration elements.
  """
  __slots__ = ('_path_helper', '_extmethods', '__dot11r','__dot11r_domainid','__dot11r_method','__dot11r_r1key_timeout',)

  _yang_name = 'config'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__dot11r_method = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'ODS': {}, u'OVA': {}},), default=six.text_type("OVA"), is_leaf=True, yang_name="dot11r-method", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='enumeration', is_config=True)
    self.__dot11r_r1key_timeout = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="dot11r-r1key-timeout", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint16', is_config=True)
    self.__dot11r = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="dot11r", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=True)
    self.__dot11r_domainid = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="dot11r-domainid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint16', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'access-points', u'access-point', u'ssids', u'ssid', u'dot11r', u'config']

  def _get_dot11r(self):
    """
    Getter method for dot11r, mapped from YANG variable /access_points/access_point/ssids/ssid/dot11r/config/dot11r (boolean)

    YANG Description: Enable/disable 802.11r FT.
    """
    return self.__dot11r
      
  def _set_dot11r(self, v, load=False):
    """
    Setter method for dot11r, mapped from YANG variable /access_points/access_point/ssids/ssid/dot11r/config/dot11r (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dot11r is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dot11r() directly.

    YANG Description: Enable/disable 802.11r FT.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="dot11r", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dot11r must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="dot11r", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=True)""",
        })

    self.__dot11r = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dot11r(self):
    self.__dot11r = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="dot11r", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=True)


  def _get_dot11r_domainid(self):
    """
    Getter method for dot11r_domainid, mapped from YANG variable /access_points/access_point/ssids/ssid/dot11r/config/dot11r_domainid (uint16)

    YANG Description: Mobility Domain ID.
    """
    return self.__dot11r_domainid
      
  def _set_dot11r_domainid(self, v, load=False):
    """
    Setter method for dot11r_domainid, mapped from YANG variable /access_points/access_point/ssids/ssid/dot11r/config/dot11r_domainid (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dot11r_domainid is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dot11r_domainid() directly.

    YANG Description: Mobility Domain ID.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="dot11r-domainid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dot11r_domainid must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="dot11r-domainid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint16', is_config=True)""",
        })

    self.__dot11r_domainid = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dot11r_domainid(self):
    self.__dot11r_domainid = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="dot11r-domainid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint16', is_config=True)


  def _get_dot11r_method(self):
    """
    Getter method for dot11r_method, mapped from YANG variable /access_points/access_point/ssids/ssid/dot11r/config/dot11r_method (enumeration)

    YANG Description: The type of 802.11r FT in use.
    """
    return self.__dot11r_method
      
  def _set_dot11r_method(self, v, load=False):
    """
    Setter method for dot11r_method, mapped from YANG variable /access_points/access_point/ssids/ssid/dot11r/config/dot11r_method (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dot11r_method is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dot11r_method() directly.

    YANG Description: The type of 802.11r FT in use.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'ODS': {}, u'OVA': {}},), default=six.text_type("OVA"), is_leaf=True, yang_name="dot11r-method", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dot11r_method must be of a type compatible with enumeration""",
          'defined-type': "openconfig-access-points:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'ODS': {}, u'OVA': {}},), default=six.text_type("OVA"), is_leaf=True, yang_name="dot11r-method", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='enumeration', is_config=True)""",
        })

    self.__dot11r_method = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dot11r_method(self):
    self.__dot11r_method = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'ODS': {}, u'OVA': {}},), default=six.text_type("OVA"), is_leaf=True, yang_name="dot11r-method", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='enumeration', is_config=True)


  def _get_dot11r_r1key_timeout(self):
    """
    Getter method for dot11r_r1key_timeout, mapped from YANG variable /access_points/access_point/ssids/ssid/dot11r/config/dot11r_r1key_timeout (uint16)

    YANG Description: TTL for the Pairwise Master Key R1.
    """
    return self.__dot11r_r1key_timeout
      
  def _set_dot11r_r1key_timeout(self, v, load=False):
    """
    Setter method for dot11r_r1key_timeout, mapped from YANG variable /access_points/access_point/ssids/ssid/dot11r/config/dot11r_r1key_timeout (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dot11r_r1key_timeout is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dot11r_r1key_timeout() directly.

    YANG Description: TTL for the Pairwise Master Key R1.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="dot11r-r1key-timeout", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dot11r_r1key_timeout must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="dot11r-r1key-timeout", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint16', is_config=True)""",
        })

    self.__dot11r_r1key_timeout = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dot11r_r1key_timeout(self):
    self.__dot11r_r1key_timeout = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="dot11r-r1key-timeout", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint16', is_config=True)

  dot11r = __builtin__.property(_get_dot11r, _set_dot11r)
  dot11r_domainid = __builtin__.property(_get_dot11r_domainid, _set_dot11r_domainid)
  dot11r_method = __builtin__.property(_get_dot11r_method, _set_dot11r_method)
  dot11r_r1key_timeout = __builtin__.property(_get_dot11r_r1key_timeout, _set_dot11r_r1key_timeout)


  _pyangbind_elements = OrderedDict([('dot11r', dot11r), ('dot11r_domainid', dot11r_domainid), ('dot11r_method', dot11r_method), ('dot11r_r1key_timeout', dot11r_r1key_timeout), ])


class yc_state_openconfig_access_points__access_points_access_point_ssids_ssid_dot11r_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-access-points - based on the path /access-points/access-point/ssids/ssid/dot11r/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Container for 802.11r state elements.
  """
  __slots__ = ('_path_helper', '_extmethods', '__dot11r','__dot11r_domainid','__dot11r_method','__dot11r_r1key_timeout',)

  _yang_name = 'state'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__dot11r_method = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'ODS': {}, u'OVA': {}},), default=six.text_type("OVA"), is_leaf=True, yang_name="dot11r-method", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='enumeration', is_config=False)
    self.__dot11r_r1key_timeout = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="dot11r-r1key-timeout", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint16', is_config=False)
    self.__dot11r = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="dot11r", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=False)
    self.__dot11r_domainid = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="dot11r-domainid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint16', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'access-points', u'access-point', u'ssids', u'ssid', u'dot11r', u'state']

  def _get_dot11r(self):
    """
    Getter method for dot11r, mapped from YANG variable /access_points/access_point/ssids/ssid/dot11r/state/dot11r (boolean)

    YANG Description: Enable/disable 802.11r FT.
    """
    return self.__dot11r
      
  def _set_dot11r(self, v, load=False):
    """
    Setter method for dot11r, mapped from YANG variable /access_points/access_point/ssids/ssid/dot11r/state/dot11r (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dot11r is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dot11r() directly.

    YANG Description: Enable/disable 802.11r FT.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="dot11r", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dot11r must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="dot11r", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=False)""",
        })

    self.__dot11r = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dot11r(self):
    self.__dot11r = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="dot11r", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=False)


  def _get_dot11r_domainid(self):
    """
    Getter method for dot11r_domainid, mapped from YANG variable /access_points/access_point/ssids/ssid/dot11r/state/dot11r_domainid (uint16)

    YANG Description: Mobility Domain ID.
    """
    return self.__dot11r_domainid
      
  def _set_dot11r_domainid(self, v, load=False):
    """
    Setter method for dot11r_domainid, mapped from YANG variable /access_points/access_point/ssids/ssid/dot11r/state/dot11r_domainid (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dot11r_domainid is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dot11r_domainid() directly.

    YANG Description: Mobility Domain ID.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="dot11r-domainid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint16', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dot11r_domainid must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="dot11r-domainid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint16', is_config=False)""",
        })

    self.__dot11r_domainid = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dot11r_domainid(self):
    self.__dot11r_domainid = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="dot11r-domainid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint16', is_config=False)


  def _get_dot11r_method(self):
    """
    Getter method for dot11r_method, mapped from YANG variable /access_points/access_point/ssids/ssid/dot11r/state/dot11r_method (enumeration)

    YANG Description: The type of 802.11r FT in use.
    """
    return self.__dot11r_method
      
  def _set_dot11r_method(self, v, load=False):
    """
    Setter method for dot11r_method, mapped from YANG variable /access_points/access_point/ssids/ssid/dot11r/state/dot11r_method (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dot11r_method is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dot11r_method() directly.

    YANG Description: The type of 802.11r FT in use.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'ODS': {}, u'OVA': {}},), default=six.text_type("OVA"), is_leaf=True, yang_name="dot11r-method", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='enumeration', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dot11r_method must be of a type compatible with enumeration""",
          'defined-type': "openconfig-access-points:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'ODS': {}, u'OVA': {}},), default=six.text_type("OVA"), is_leaf=True, yang_name="dot11r-method", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='enumeration', is_config=False)""",
        })

    self.__dot11r_method = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dot11r_method(self):
    self.__dot11r_method = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'ODS': {}, u'OVA': {}},), default=six.text_type("OVA"), is_leaf=True, yang_name="dot11r-method", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='enumeration', is_config=False)


  def _get_dot11r_r1key_timeout(self):
    """
    Getter method for dot11r_r1key_timeout, mapped from YANG variable /access_points/access_point/ssids/ssid/dot11r/state/dot11r_r1key_timeout (uint16)

    YANG Description: TTL for the Pairwise Master Key R1.
    """
    return self.__dot11r_r1key_timeout
      
  def _set_dot11r_r1key_timeout(self, v, load=False):
    """
    Setter method for dot11r_r1key_timeout, mapped from YANG variable /access_points/access_point/ssids/ssid/dot11r/state/dot11r_r1key_timeout (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dot11r_r1key_timeout is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dot11r_r1key_timeout() directly.

    YANG Description: TTL for the Pairwise Master Key R1.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="dot11r-r1key-timeout", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint16', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dot11r_r1key_timeout must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="dot11r-r1key-timeout", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint16', is_config=False)""",
        })

    self.__dot11r_r1key_timeout = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dot11r_r1key_timeout(self):
    self.__dot11r_r1key_timeout = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="dot11r-r1key-timeout", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint16', is_config=False)

  dot11r = __builtin__.property(_get_dot11r)
  dot11r_domainid = __builtin__.property(_get_dot11r_domainid)
  dot11r_method = __builtin__.property(_get_dot11r_method)
  dot11r_r1key_timeout = __builtin__.property(_get_dot11r_r1key_timeout)


  _pyangbind_elements = OrderedDict([('dot11r', dot11r), ('dot11r_domainid', dot11r_domainid), ('dot11r_method', dot11r_method), ('dot11r_r1key_timeout', dot11r_r1key_timeout), ])


class yc_dot11r_openconfig_access_points__access_points_access_point_ssids_ssid_dot11r(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-access-points - based on the path /access-points/access-point/ssids/ssid/dot11r. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Top-level container for 802.11r configuration and
state container.
  """
  __slots__ = ('_path_helper', '_extmethods', '__config','__state',)

  _yang_name = 'dot11r'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__state = YANGDynClass(base=yc_state_openconfig_access_points__access_points_access_point_ssids_ssid_dot11r_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)
    self.__config = YANGDynClass(base=yc_config_openconfig_access_points__access_points_access_point_ssids_ssid_dot11r_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'access-points', u'access-point', u'ssids', u'ssid', u'dot11r']

  def _get_config(self):
    """
    Getter method for config, mapped from YANG variable /access_points/access_point/ssids/ssid/dot11r/config (container)

    YANG Description: Container for 802.11r configuration elements.
    """
    return self.__config
      
  def _set_config(self, v, load=False):
    """
    Setter method for config, mapped from YANG variable /access_points/access_point/ssids/ssid/dot11r/config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config() directly.

    YANG Description: Container for 802.11r configuration elements.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_config_openconfig_access_points__access_points_access_point_ssids_ssid_dot11r_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_config_openconfig_access_points__access_points_access_point_ssids_ssid_dot11r_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)""",
        })

    self.__config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config(self):
    self.__config = YANGDynClass(base=yc_config_openconfig_access_points__access_points_access_point_ssids_ssid_dot11r_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /access_points/access_point/ssids/ssid/dot11r/state (container)

    YANG Description: Container for 802.11r state elements.
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /access_points/access_point/ssids/ssid/dot11r/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: Container for 802.11r state elements.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_access_points__access_points_access_point_ssids_ssid_dot11r_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_access_points__access_points_access_point_ssids_ssid_dot11r_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_access_points__access_points_access_point_ssids_ssid_dot11r_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)

  config = __builtin__.property(_get_config, _set_config)
  state = __builtin__.property(_get_state, _set_state)


  _pyangbind_elements = OrderedDict([('config', config), ('state', state), ])


class yc_config_openconfig_access_points__access_points_access_point_ssids_ssid_dot11v_config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-access-points - based on the path /access-points/access-point/ssids/ssid/dot11v/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Container for 802.11v configuration elements.
  """
  __slots__ = ('_path_helper', '_extmethods', '__dot11v_dms','__dot11v_bssidle','__dot11v_bssidle_timeout','__dot11v_bsstransition',)

  _yang_name = 'config'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__dot11v_dms = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="dot11v-dms", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=True)
    self.__dot11v_bssidle = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="dot11v-bssidle", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=True)
    self.__dot11v_bssidle_timeout = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="dot11v-bssidle-timeout", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint16', is_config=True)
    self.__dot11v_bsstransition = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="dot11v-bsstransition", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'access-points', u'access-point', u'ssids', u'ssid', u'dot11v', u'config']

  def _get_dot11v_dms(self):
    """
    Getter method for dot11v_dms, mapped from YANG variable /access_points/access_point/ssids/ssid/dot11v/config/dot11v_dms (boolean)

    YANG Description: 802.11v Directed Multicast Service enabled/disabled.
    """
    return self.__dot11v_dms
      
  def _set_dot11v_dms(self, v, load=False):
    """
    Setter method for dot11v_dms, mapped from YANG variable /access_points/access_point/ssids/ssid/dot11v/config/dot11v_dms (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dot11v_dms is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dot11v_dms() directly.

    YANG Description: 802.11v Directed Multicast Service enabled/disabled.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="dot11v-dms", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dot11v_dms must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="dot11v-dms", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=True)""",
        })

    self.__dot11v_dms = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dot11v_dms(self):
    self.__dot11v_dms = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="dot11v-dms", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=True)


  def _get_dot11v_bssidle(self):
    """
    Getter method for dot11v_bssidle, mapped from YANG variable /access_points/access_point/ssids/ssid/dot11v/config/dot11v_bssidle (boolean)

    YANG Description: 802.11v BSS Max Idle enabled/disabled.
    """
    return self.__dot11v_bssidle
      
  def _set_dot11v_bssidle(self, v, load=False):
    """
    Setter method for dot11v_bssidle, mapped from YANG variable /access_points/access_point/ssids/ssid/dot11v/config/dot11v_bssidle (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dot11v_bssidle is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dot11v_bssidle() directly.

    YANG Description: 802.11v BSS Max Idle enabled/disabled.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="dot11v-bssidle", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dot11v_bssidle must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="dot11v-bssidle", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=True)""",
        })

    self.__dot11v_bssidle = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dot11v_bssidle(self):
    self.__dot11v_bssidle = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="dot11v-bssidle", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=True)


  def _get_dot11v_bssidle_timeout(self):
    """
    Getter method for dot11v_bssidle_timeout, mapped from YANG variable /access_points/access_point/ssids/ssid/dot11v/config/dot11v_bssidle_timeout (uint16)

    YANG Description: 802.11v BSS Max Idle timeout.
    """
    return self.__dot11v_bssidle_timeout
      
  def _set_dot11v_bssidle_timeout(self, v, load=False):
    """
    Setter method for dot11v_bssidle_timeout, mapped from YANG variable /access_points/access_point/ssids/ssid/dot11v/config/dot11v_bssidle_timeout (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dot11v_bssidle_timeout is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dot11v_bssidle_timeout() directly.

    YANG Description: 802.11v BSS Max Idle timeout.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="dot11v-bssidle-timeout", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dot11v_bssidle_timeout must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="dot11v-bssidle-timeout", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint16', is_config=True)""",
        })

    self.__dot11v_bssidle_timeout = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dot11v_bssidle_timeout(self):
    self.__dot11v_bssidle_timeout = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="dot11v-bssidle-timeout", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint16', is_config=True)


  def _get_dot11v_bsstransition(self):
    """
    Getter method for dot11v_bsstransition, mapped from YANG variable /access_points/access_point/ssids/ssid/dot11v/config/dot11v_bsstransition (boolean)

    YANG Description: 802.11v BSS Transition enabled/disabled.
    """
    return self.__dot11v_bsstransition
      
  def _set_dot11v_bsstransition(self, v, load=False):
    """
    Setter method for dot11v_bsstransition, mapped from YANG variable /access_points/access_point/ssids/ssid/dot11v/config/dot11v_bsstransition (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dot11v_bsstransition is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dot11v_bsstransition() directly.

    YANG Description: 802.11v BSS Transition enabled/disabled.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="dot11v-bsstransition", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dot11v_bsstransition must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="dot11v-bsstransition", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=True)""",
        })

    self.__dot11v_bsstransition = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dot11v_bsstransition(self):
    self.__dot11v_bsstransition = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="dot11v-bsstransition", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=True)

  dot11v_dms = __builtin__.property(_get_dot11v_dms, _set_dot11v_dms)
  dot11v_bssidle = __builtin__.property(_get_dot11v_bssidle, _set_dot11v_bssidle)
  dot11v_bssidle_timeout = __builtin__.property(_get_dot11v_bssidle_timeout, _set_dot11v_bssidle_timeout)
  dot11v_bsstransition = __builtin__.property(_get_dot11v_bsstransition, _set_dot11v_bsstransition)


  _pyangbind_elements = OrderedDict([('dot11v_dms', dot11v_dms), ('dot11v_bssidle', dot11v_bssidle), ('dot11v_bssidle_timeout', dot11v_bssidle_timeout), ('dot11v_bsstransition', dot11v_bsstransition), ])


class yc_state_openconfig_access_points__access_points_access_point_ssids_ssid_dot11v_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-access-points - based on the path /access-points/access-point/ssids/ssid/dot11v/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Container for 802.11r state elements.
  """
  __slots__ = ('_path_helper', '_extmethods', '__dot11v_dms','__dot11v_bssidle','__dot11v_bssidle_timeout','__dot11v_bsstransition',)

  _yang_name = 'state'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__dot11v_dms = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="dot11v-dms", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=False)
    self.__dot11v_bssidle = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="dot11v-bssidle", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=False)
    self.__dot11v_bssidle_timeout = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="dot11v-bssidle-timeout", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint16', is_config=False)
    self.__dot11v_bsstransition = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="dot11v-bsstransition", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'access-points', u'access-point', u'ssids', u'ssid', u'dot11v', u'state']

  def _get_dot11v_dms(self):
    """
    Getter method for dot11v_dms, mapped from YANG variable /access_points/access_point/ssids/ssid/dot11v/state/dot11v_dms (boolean)

    YANG Description: 802.11v Directed Multicast Service enabled/disabled.
    """
    return self.__dot11v_dms
      
  def _set_dot11v_dms(self, v, load=False):
    """
    Setter method for dot11v_dms, mapped from YANG variable /access_points/access_point/ssids/ssid/dot11v/state/dot11v_dms (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dot11v_dms is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dot11v_dms() directly.

    YANG Description: 802.11v Directed Multicast Service enabled/disabled.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="dot11v-dms", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dot11v_dms must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="dot11v-dms", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=False)""",
        })

    self.__dot11v_dms = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dot11v_dms(self):
    self.__dot11v_dms = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="dot11v-dms", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=False)


  def _get_dot11v_bssidle(self):
    """
    Getter method for dot11v_bssidle, mapped from YANG variable /access_points/access_point/ssids/ssid/dot11v/state/dot11v_bssidle (boolean)

    YANG Description: 802.11v BSS Max Idle enabled/disabled.
    """
    return self.__dot11v_bssidle
      
  def _set_dot11v_bssidle(self, v, load=False):
    """
    Setter method for dot11v_bssidle, mapped from YANG variable /access_points/access_point/ssids/ssid/dot11v/state/dot11v_bssidle (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dot11v_bssidle is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dot11v_bssidle() directly.

    YANG Description: 802.11v BSS Max Idle enabled/disabled.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="dot11v-bssidle", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dot11v_bssidle must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="dot11v-bssidle", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=False)""",
        })

    self.__dot11v_bssidle = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dot11v_bssidle(self):
    self.__dot11v_bssidle = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="dot11v-bssidle", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=False)


  def _get_dot11v_bssidle_timeout(self):
    """
    Getter method for dot11v_bssidle_timeout, mapped from YANG variable /access_points/access_point/ssids/ssid/dot11v/state/dot11v_bssidle_timeout (uint16)

    YANG Description: 802.11v BSS Max Idle timeout.
    """
    return self.__dot11v_bssidle_timeout
      
  def _set_dot11v_bssidle_timeout(self, v, load=False):
    """
    Setter method for dot11v_bssidle_timeout, mapped from YANG variable /access_points/access_point/ssids/ssid/dot11v/state/dot11v_bssidle_timeout (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dot11v_bssidle_timeout is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dot11v_bssidle_timeout() directly.

    YANG Description: 802.11v BSS Max Idle timeout.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="dot11v-bssidle-timeout", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint16', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dot11v_bssidle_timeout must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="dot11v-bssidle-timeout", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint16', is_config=False)""",
        })

    self.__dot11v_bssidle_timeout = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dot11v_bssidle_timeout(self):
    self.__dot11v_bssidle_timeout = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="dot11v-bssidle-timeout", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint16', is_config=False)


  def _get_dot11v_bsstransition(self):
    """
    Getter method for dot11v_bsstransition, mapped from YANG variable /access_points/access_point/ssids/ssid/dot11v/state/dot11v_bsstransition (boolean)

    YANG Description: 802.11v BSS Transition enabled/disabled.
    """
    return self.__dot11v_bsstransition
      
  def _set_dot11v_bsstransition(self, v, load=False):
    """
    Setter method for dot11v_bsstransition, mapped from YANG variable /access_points/access_point/ssids/ssid/dot11v/state/dot11v_bsstransition (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dot11v_bsstransition is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dot11v_bsstransition() directly.

    YANG Description: 802.11v BSS Transition enabled/disabled.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="dot11v-bsstransition", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dot11v_bsstransition must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="dot11v-bsstransition", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=False)""",
        })

    self.__dot11v_bsstransition = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dot11v_bsstransition(self):
    self.__dot11v_bsstransition = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="dot11v-bsstransition", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=False)

  dot11v_dms = __builtin__.property(_get_dot11v_dms)
  dot11v_bssidle = __builtin__.property(_get_dot11v_bssidle)
  dot11v_bssidle_timeout = __builtin__.property(_get_dot11v_bssidle_timeout)
  dot11v_bsstransition = __builtin__.property(_get_dot11v_bsstransition)


  _pyangbind_elements = OrderedDict([('dot11v_dms', dot11v_dms), ('dot11v_bssidle', dot11v_bssidle), ('dot11v_bssidle_timeout', dot11v_bssidle_timeout), ('dot11v_bsstransition', dot11v_bsstransition), ])


class yc_dot11v_openconfig_access_points__access_points_access_point_ssids_ssid_dot11v(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-access-points - based on the path /access-points/access-point/ssids/ssid/dot11v. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Top-level container for 802.11v configuration and
operational state data.
  """
  __slots__ = ('_path_helper', '_extmethods', '__config','__state',)

  _yang_name = 'dot11v'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__state = YANGDynClass(base=yc_state_openconfig_access_points__access_points_access_point_ssids_ssid_dot11v_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)
    self.__config = YANGDynClass(base=yc_config_openconfig_access_points__access_points_access_point_ssids_ssid_dot11v_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'access-points', u'access-point', u'ssids', u'ssid', u'dot11v']

  def _get_config(self):
    """
    Getter method for config, mapped from YANG variable /access_points/access_point/ssids/ssid/dot11v/config (container)

    YANG Description: Container for 802.11v configuration elements.
    """
    return self.__config
      
  def _set_config(self, v, load=False):
    """
    Setter method for config, mapped from YANG variable /access_points/access_point/ssids/ssid/dot11v/config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config() directly.

    YANG Description: Container for 802.11v configuration elements.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_config_openconfig_access_points__access_points_access_point_ssids_ssid_dot11v_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_config_openconfig_access_points__access_points_access_point_ssids_ssid_dot11v_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)""",
        })

    self.__config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config(self):
    self.__config = YANGDynClass(base=yc_config_openconfig_access_points__access_points_access_point_ssids_ssid_dot11v_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /access_points/access_point/ssids/ssid/dot11v/state (container)

    YANG Description: Container for 802.11r state elements.
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /access_points/access_point/ssids/ssid/dot11v/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: Container for 802.11r state elements.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_access_points__access_points_access_point_ssids_ssid_dot11v_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_access_points__access_points_access_point_ssids_ssid_dot11v_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_access_points__access_points_access_point_ssids_ssid_dot11v_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)

  config = __builtin__.property(_get_config, _set_config)
  state = __builtin__.property(_get_state, _set_state)


  _pyangbind_elements = OrderedDict([('config', config), ('state', state), ])


class yc_counters_openconfig_access_points__access_points_access_point_ssids_ssid_clients_client_state_counters(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-access-points - based on the path /access-points/access-point/ssids/ssid/clients/client/state/counters. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Per-client counters.
  """
  __slots__ = ('_path_helper', '_extmethods', '__tx_bytes','__rx_bytes','__rx_retries','__tx_retries',)

  _yang_name = 'counters'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__tx_bytes = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="tx-bytes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)
    self.__tx_retries = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="tx-retries", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)
    self.__rx_bytes = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="rx-bytes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)
    self.__rx_retries = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="rx-retries", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'access-points', u'access-point', u'ssids', u'ssid', u'clients', u'client', u'state', u'counters']

  def _get_tx_bytes(self):
    """
    Getter method for tx_bytes, mapped from YANG variable /access_points/access_point/ssids/ssid/clients/client/state/counters/tx_bytes (oc-yang:counter64)

    YANG Description: Tx Bytes to this client.
    """
    return self.__tx_bytes
      
  def _set_tx_bytes(self, v, load=False):
    """
    Setter method for tx_bytes, mapped from YANG variable /access_points/access_point/ssids/ssid/clients/client/state/counters/tx_bytes (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tx_bytes is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tx_bytes() directly.

    YANG Description: Tx Bytes to this client.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="tx-bytes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tx_bytes must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="tx-bytes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__tx_bytes = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tx_bytes(self):
    self.__tx_bytes = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="tx-bytes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)


  def _get_rx_bytes(self):
    """
    Getter method for rx_bytes, mapped from YANG variable /access_points/access_point/ssids/ssid/clients/client/state/counters/rx_bytes (oc-yang:counter64)

    YANG Description: Rx Bytes from this client.
    """
    return self.__rx_bytes
      
  def _set_rx_bytes(self, v, load=False):
    """
    Setter method for rx_bytes, mapped from YANG variable /access_points/access_point/ssids/ssid/clients/client/state/counters/rx_bytes (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_rx_bytes is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_rx_bytes() directly.

    YANG Description: Rx Bytes from this client.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="rx-bytes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """rx_bytes must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="rx-bytes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__rx_bytes = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_rx_bytes(self):
    self.__rx_bytes = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="rx-bytes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)


  def _get_rx_retries(self):
    """
    Getter method for rx_retries, mapped from YANG variable /access_points/access_point/ssids/ssid/clients/client/state/counters/rx_retries (oc-yang:counter64)

    YANG Description: Rx retried frames from this client.
    """
    return self.__rx_retries
      
  def _set_rx_retries(self, v, load=False):
    """
    Setter method for rx_retries, mapped from YANG variable /access_points/access_point/ssids/ssid/clients/client/state/counters/rx_retries (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_rx_retries is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_rx_retries() directly.

    YANG Description: Rx retried frames from this client.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="rx-retries", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """rx_retries must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="rx-retries", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__rx_retries = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_rx_retries(self):
    self.__rx_retries = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="rx-retries", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)


  def _get_tx_retries(self):
    """
    Getter method for tx_retries, mapped from YANG variable /access_points/access_point/ssids/ssid/clients/client/state/counters/tx_retries (oc-yang:counter64)

    YANG Description: Tx retried frames to this client.
    """
    return self.__tx_retries
      
  def _set_tx_retries(self, v, load=False):
    """
    Setter method for tx_retries, mapped from YANG variable /access_points/access_point/ssids/ssid/clients/client/state/counters/tx_retries (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tx_retries is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tx_retries() directly.

    YANG Description: Tx retried frames to this client.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="tx-retries", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tx_retries must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="tx-retries", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__tx_retries = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tx_retries(self):
    self.__tx_retries = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="tx-retries", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)

  tx_bytes = __builtin__.property(_get_tx_bytes)
  rx_bytes = __builtin__.property(_get_rx_bytes)
  rx_retries = __builtin__.property(_get_rx_retries)
  tx_retries = __builtin__.property(_get_tx_retries)


  _pyangbind_elements = OrderedDict([('tx_bytes', tx_bytes), ('rx_bytes', rx_bytes), ('rx_retries', rx_retries), ('tx_retries', tx_retries), ])


class yc_state_openconfig_access_points__access_points_access_point_ssids_ssid_clients_client_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-access-points - based on the path /access-points/access-point/ssids/ssid/clients/client/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Client state data.
  """
  __slots__ = ('_path_helper', '_extmethods', '__mac','__counters',)

  _yang_name = 'state'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__mac = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}$'}), is_leaf=True, yang_name="mac", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:mac-address', is_config=False)
    self.__counters = YANGDynClass(base=yc_counters_openconfig_access_points__access_points_access_point_ssids_ssid_clients_client_state_counters, is_container='container', yang_name="counters", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'access-points', u'access-point', u'ssids', u'ssid', u'clients', u'client', u'state']

  def _get_mac(self):
    """
    Getter method for mac, mapped from YANG variable /access_points/access_point/ssids/ssid/clients/client/state/mac (oc-yang:mac-address)

    YANG Description: MAC address of the client.
    """
    return self.__mac
      
  def _set_mac(self, v, load=False):
    """
    Setter method for mac, mapped from YANG variable /access_points/access_point/ssids/ssid/clients/client/state/mac (oc-yang:mac-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mac is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mac() directly.

    YANG Description: MAC address of the client.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}$'}), is_leaf=True, yang_name="mac", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:mac-address', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mac must be of a type compatible with oc-yang:mac-address""",
          'defined-type': "oc-yang:mac-address",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}$'}), is_leaf=True, yang_name="mac", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:mac-address', is_config=False)""",
        })

    self.__mac = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mac(self):
    self.__mac = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}$'}), is_leaf=True, yang_name="mac", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:mac-address', is_config=False)


  def _get_counters(self):
    """
    Getter method for counters, mapped from YANG variable /access_points/access_point/ssids/ssid/clients/client/state/counters (container)

    YANG Description: Per-client counters.
    """
    return self.__counters
      
  def _set_counters(self, v, load=False):
    """
    Setter method for counters, mapped from YANG variable /access_points/access_point/ssids/ssid/clients/client/state/counters (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_counters is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_counters() directly.

    YANG Description: Per-client counters.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_counters_openconfig_access_points__access_points_access_point_ssids_ssid_clients_client_state_counters, is_container='container', yang_name="counters", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """counters must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_counters_openconfig_access_points__access_points_access_point_ssids_ssid_clients_client_state_counters, is_container='container', yang_name="counters", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=False)""",
        })

    self.__counters = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_counters(self):
    self.__counters = YANGDynClass(base=yc_counters_openconfig_access_points__access_points_access_point_ssids_ssid_clients_client_state_counters, is_container='container', yang_name="counters", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=False)

  mac = __builtin__.property(_get_mac)
  counters = __builtin__.property(_get_counters)


  _pyangbind_elements = OrderedDict([('mac', mac), ('counters', counters), ])


class yc_state_openconfig_access_points__access_points_access_point_ssids_ssid_clients_client_client_rf_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-access-points - based on the path /access-points/access-point/ssids/ssid/clients/client/client-rf/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Container for RF related client state data.
  """
  __slots__ = ('_path_helper', '_extmethods', '__rssi','__snr','__ss','__phy_rate','__connection_mode','__frequency',)

  _yang_name = 'state'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__ss = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="ss", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint8', is_config=False)
    self.__connection_mode = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'A': {}, u'AC': {}, u'B': {}, u'G': {}, u'N': {}},), is_leaf=True, yang_name="connection-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='enumeration', is_config=False)
    self.__frequency = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="frequency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint8', is_config=False)
    self.__snr = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="snr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint8', is_config=False)
    self.__rssi = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['-128..127']}, int_size=8), is_leaf=True, yang_name="rssi", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='int8', is_config=False)
    self.__phy_rate = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="phy-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint16', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'access-points', u'access-point', u'ssids', u'ssid', u'clients', u'client', u'client-rf', u'state']

  def _get_rssi(self):
    """
    Getter method for rssi, mapped from YANG variable /access_points/access_point/ssids/ssid/clients/client/client_rf/state/rssi (int8)

    YANG Description: The RSSI of this client in dBm. Expressed as negative
number
    """
    return self.__rssi
      
  def _set_rssi(self, v, load=False):
    """
    Setter method for rssi, mapped from YANG variable /access_points/access_point/ssids/ssid/clients/client/client_rf/state/rssi (int8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_rssi is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_rssi() directly.

    YANG Description: The RSSI of this client in dBm. Expressed as negative
number
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['-128..127']}, int_size=8), is_leaf=True, yang_name="rssi", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='int8', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """rssi must be of a type compatible with int8""",
          'defined-type': "int8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['-128..127']}, int_size=8), is_leaf=True, yang_name="rssi", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='int8', is_config=False)""",
        })

    self.__rssi = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_rssi(self):
    self.__rssi = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['-128..127']}, int_size=8), is_leaf=True, yang_name="rssi", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='int8', is_config=False)


  def _get_snr(self):
    """
    Getter method for snr, mapped from YANG variable /access_points/access_point/ssids/ssid/clients/client/client_rf/state/snr (uint8)

    YANG Description: The SNR of AP to Client, in dB.
    """
    return self.__snr
      
  def _set_snr(self, v, load=False):
    """
    Setter method for snr, mapped from YANG variable /access_points/access_point/ssids/ssid/clients/client/client_rf/state/snr (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_snr is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_snr() directly.

    YANG Description: The SNR of AP to Client, in dB.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="snr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint8', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """snr must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="snr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint8', is_config=False)""",
        })

    self.__snr = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_snr(self):
    self.__snr = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="snr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint8', is_config=False)


  def _get_ss(self):
    """
    Getter method for ss, mapped from YANG variable /access_points/access_point/ssids/ssid/clients/client/client_rf/state/ss (uint8)

    YANG Description: Number of Spatial Streams supported by the client.
    """
    return self.__ss
      
  def _set_ss(self, v, load=False):
    """
    Setter method for ss, mapped from YANG variable /access_points/access_point/ssids/ssid/clients/client/client_rf/state/ss (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ss is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ss() directly.

    YANG Description: Number of Spatial Streams supported by the client.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="ss", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint8', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ss must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="ss", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint8', is_config=False)""",
        })

    self.__ss = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ss(self):
    self.__ss = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="ss", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint8', is_config=False)


  def _get_phy_rate(self):
    """
    Getter method for phy_rate, mapped from YANG variable /access_points/access_point/ssids/ssid/clients/client/client_rf/state/phy_rate (uint16)

    YANG Description: Last used PHY rate of connected client.
    """
    return self.__phy_rate
      
  def _set_phy_rate(self, v, load=False):
    """
    Setter method for phy_rate, mapped from YANG variable /access_points/access_point/ssids/ssid/clients/client/client_rf/state/phy_rate (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_phy_rate is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_phy_rate() directly.

    YANG Description: Last used PHY rate of connected client.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="phy-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint16', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """phy_rate must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="phy-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint16', is_config=False)""",
        })

    self.__phy_rate = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_phy_rate(self):
    self.__phy_rate = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="phy-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint16', is_config=False)


  def _get_connection_mode(self):
    """
    Getter method for connection_mode, mapped from YANG variable /access_points/access_point/ssids/ssid/clients/client/client_rf/state/connection_mode (enumeration)

    YANG Description: 802.11 protocol used for the client's connection.
    """
    return self.__connection_mode
      
  def _set_connection_mode(self, v, load=False):
    """
    Setter method for connection_mode, mapped from YANG variable /access_points/access_point/ssids/ssid/clients/client/client_rf/state/connection_mode (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_connection_mode is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_connection_mode() directly.

    YANG Description: 802.11 protocol used for the client's connection.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'A': {}, u'AC': {}, u'B': {}, u'G': {}, u'N': {}},), is_leaf=True, yang_name="connection-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='enumeration', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """connection_mode must be of a type compatible with enumeration""",
          'defined-type': "openconfig-access-points:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'A': {}, u'AC': {}, u'B': {}, u'G': {}, u'N': {}},), is_leaf=True, yang_name="connection-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='enumeration', is_config=False)""",
        })

    self.__connection_mode = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_connection_mode(self):
    self.__connection_mode = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'A': {}, u'AC': {}, u'B': {}, u'G': {}, u'N': {}},), is_leaf=True, yang_name="connection-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='enumeration', is_config=False)


  def _get_frequency(self):
    """
    Getter method for frequency, mapped from YANG variable /access_points/access_point/ssids/ssid/clients/client/client_rf/state/frequency (uint8)

    YANG Description: Frequency the client is utilizing. Typically, 2.4 or
5[GHz].
    """
    return self.__frequency
      
  def _set_frequency(self, v, load=False):
    """
    Setter method for frequency, mapped from YANG variable /access_points/access_point/ssids/ssid/clients/client/client_rf/state/frequency (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_frequency is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_frequency() directly.

    YANG Description: Frequency the client is utilizing. Typically, 2.4 or
5[GHz].
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="frequency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint8', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """frequency must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="frequency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint8', is_config=False)""",
        })

    self.__frequency = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_frequency(self):
    self.__frequency = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="frequency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint8', is_config=False)

  rssi = __builtin__.property(_get_rssi)
  snr = __builtin__.property(_get_snr)
  ss = __builtin__.property(_get_ss)
  phy_rate = __builtin__.property(_get_phy_rate)
  connection_mode = __builtin__.property(_get_connection_mode)
  frequency = __builtin__.property(_get_frequency)


  _pyangbind_elements = OrderedDict([('rssi', rssi), ('snr', snr), ('ss', ss), ('phy_rate', phy_rate), ('connection_mode', connection_mode), ('frequency', frequency), ])


class yc_client_rf_openconfig_access_points__access_points_access_point_ssids_ssid_clients_client_client_rf(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-access-points - based on the path /access-points/access-point/ssids/ssid/clients/client/client-rf. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: RF radio-data per non-AP STA.
  """
  __slots__ = ('_path_helper', '_extmethods', '__state',)

  _yang_name = 'client-rf'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__state = YANGDynClass(base=yc_state_openconfig_access_points__access_points_access_point_ssids_ssid_clients_client_client_rf_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'access-points', u'access-point', u'ssids', u'ssid', u'clients', u'client', u'client-rf']

  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /access_points/access_point/ssids/ssid/clients/client/client_rf/state (container)

    YANG Description: Container for RF related client state data.
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /access_points/access_point/ssids/ssid/clients/client/client_rf/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: Container for RF related client state data.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_access_points__access_points_access_point_ssids_ssid_clients_client_client_rf_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_access_points__access_points_access_point_ssids_ssid_clients_client_client_rf_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=False)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_access_points__access_points_access_point_ssids_ssid_clients_client_client_rf_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=False)

  state = __builtin__.property(_get_state)


  _pyangbind_elements = OrderedDict([('state', state), ])


class yc_state_openconfig_access_points__access_points_access_point_ssids_ssid_clients_client_client_capabilities_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-access-points - based on the path /access-points/access-point/ssids/ssid/clients/client/client-capabilities/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Container for Client capabilities, as reported by Assoc. Req.
or Probe Req. frames. Capability is supported, if present.
  """
  __slots__ = ('_path_helper', '_extmethods', '__client_capabilities','__channel_support',)

  _yang_name = 'state'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__client_capabilities = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'oc-wifi-types:MU_BEAMFORMER': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'DOT_11R': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'MU_BEAMFORMER': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:DOT_11V': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'DOT_11V': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:MU_BEAMFORMEE': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:DOT_11R': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'MU_BEAMFORMEE': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}},)), is_leaf=False, yang_name="client-capabilities", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='identityref', is_config=False)
    self.__channel_support = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)), is_leaf=False, yang_name="channel-support", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint8', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'access-points', u'access-point', u'ssids', u'ssid', u'clients', u'client', u'client-capabilities', u'state']

  def _get_client_capabilities(self):
    """
    Getter method for client_capabilities, mapped from YANG variable /access_points/access_point/ssids/ssid/clients/client/client_capabilities/state/client_capabilities (identityref)

    YANG Description: Features supported by client that are Optional
within the 802.11 specifications.
    """
    return self.__client_capabilities
      
  def _set_client_capabilities(self, v, load=False):
    """
    Setter method for client_capabilities, mapped from YANG variable /access_points/access_point/ssids/ssid/clients/client/client_capabilities/state/client_capabilities (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_client_capabilities is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_client_capabilities() directly.

    YANG Description: Features supported by client that are Optional
within the 802.11 specifications.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'oc-wifi-types:MU_BEAMFORMER': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'DOT_11R': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'MU_BEAMFORMER': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:DOT_11V': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'DOT_11V': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:MU_BEAMFORMEE': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:DOT_11R': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'MU_BEAMFORMEE': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}},)), is_leaf=False, yang_name="client-capabilities", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='identityref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """client_capabilities must be of a type compatible with identityref""",
          'defined-type': "openconfig-access-points:identityref",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'oc-wifi-types:MU_BEAMFORMER': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'DOT_11R': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'MU_BEAMFORMER': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:DOT_11V': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'DOT_11V': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:MU_BEAMFORMEE': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:DOT_11R': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'MU_BEAMFORMEE': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}},)), is_leaf=False, yang_name="client-capabilities", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='identityref', is_config=False)""",
        })

    self.__client_capabilities = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_client_capabilities(self):
    self.__client_capabilities = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'oc-wifi-types:MU_BEAMFORMER': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'DOT_11R': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'MU_BEAMFORMER': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:DOT_11V': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'DOT_11V': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:MU_BEAMFORMEE': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:DOT_11R': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'MU_BEAMFORMEE': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}},)), is_leaf=False, yang_name="client-capabilities", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='identityref', is_config=False)


  def _get_channel_support(self):
    """
    Getter method for channel_support, mapped from YANG variable /access_points/access_point/ssids/ssid/clients/client/client_capabilities/state/channel_support (uint8)

    YANG Description: List of supported channels.
    """
    return self.__channel_support
      
  def _set_channel_support(self, v, load=False):
    """
    Setter method for channel_support, mapped from YANG variable /access_points/access_point/ssids/ssid/clients/client/client_capabilities/state/channel_support (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_channel_support is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_channel_support() directly.

    YANG Description: List of supported channels.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)), is_leaf=False, yang_name="channel-support", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint8', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """channel_support must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)), is_leaf=False, yang_name="channel-support", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint8', is_config=False)""",
        })

    self.__channel_support = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_channel_support(self):
    self.__channel_support = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)), is_leaf=False, yang_name="channel-support", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint8', is_config=False)

  client_capabilities = __builtin__.property(_get_client_capabilities)
  channel_support = __builtin__.property(_get_channel_support)


  _pyangbind_elements = OrderedDict([('client_capabilities', client_capabilities), ('channel_support', channel_support), ])


class yc_client_capabilities_openconfig_access_points__access_points_access_point_ssids_ssid_clients_client_client_capabilities(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-access-points - based on the path /access-points/access-point/ssids/ssid/clients/client/client-capabilities. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Capabilites as advertised by the Client.
  """
  __slots__ = ('_path_helper', '_extmethods', '__state',)

  _yang_name = 'client-capabilities'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__state = YANGDynClass(base=yc_state_openconfig_access_points__access_points_access_point_ssids_ssid_clients_client_client_capabilities_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'access-points', u'access-point', u'ssids', u'ssid', u'clients', u'client', u'client-capabilities']

  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /access_points/access_point/ssids/ssid/clients/client/client_capabilities/state (container)

    YANG Description: Container for Client capabilities, as reported by Assoc. Req.
or Probe Req. frames. Capability is supported, if present.
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /access_points/access_point/ssids/ssid/clients/client/client_capabilities/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: Container for Client capabilities, as reported by Assoc. Req.
or Probe Req. frames. Capability is supported, if present.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_access_points__access_points_access_point_ssids_ssid_clients_client_client_capabilities_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_access_points__access_points_access_point_ssids_ssid_clients_client_client_capabilities_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=False)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_access_points__access_points_access_point_ssids_ssid_clients_client_client_capabilities_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=False)

  state = __builtin__.property(_get_state)


  _pyangbind_elements = OrderedDict([('state', state), ])


class yc_state_openconfig_access_points__access_points_access_point_ssids_ssid_clients_client_dot11k_neighbors_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-access-points - based on the path /access-points/access-point/ssids/ssid/clients/client/dot11k-neighbors/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Container for Client beacon reports. Requires 802.11k
enabled. See Sec. 5.2.7.1 of 802.11k-2008 Standard.
  """
  __slots__ = ('_path_helper', '_extmethods', '__neighbor_bssid','__neighbor_channel','__neighbor_rssi','__neighbor_antenna','__channel_load_report',)

  _yang_name = 'state'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__neighbor_rssi = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['-128..127']}, int_size=8), is_leaf=True, yang_name="neighbor-rssi", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='int8', is_config=False)
    self.__neighbor_channel = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="neighbor-channel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint8', is_config=False)
    self.__neighbor_antenna = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="neighbor-antenna", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint8', is_config=False)
    self.__neighbor_bssid = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}$'}), is_leaf=True, yang_name="neighbor-bssid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:mac-address', is_config=False)
    self.__channel_load_report = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="channel-load-report", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint8', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'access-points', u'access-point', u'ssids', u'ssid', u'clients', u'client', u'dot11k-neighbors', u'state']

  def _get_neighbor_bssid(self):
    """
    Getter method for neighbor_bssid, mapped from YANG variable /access_points/access_point/ssids/ssid/clients/client/dot11k_neighbors/state/neighbor_bssid (oc-yang:mac-address)

    YANG Description: The BSSID of this neighbor.
    """
    return self.__neighbor_bssid
      
  def _set_neighbor_bssid(self, v, load=False):
    """
    Setter method for neighbor_bssid, mapped from YANG variable /access_points/access_point/ssids/ssid/clients/client/dot11k_neighbors/state/neighbor_bssid (oc-yang:mac-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_neighbor_bssid is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_neighbor_bssid() directly.

    YANG Description: The BSSID of this neighbor.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}$'}), is_leaf=True, yang_name="neighbor-bssid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:mac-address', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """neighbor_bssid must be of a type compatible with oc-yang:mac-address""",
          'defined-type': "oc-yang:mac-address",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}$'}), is_leaf=True, yang_name="neighbor-bssid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:mac-address', is_config=False)""",
        })

    self.__neighbor_bssid = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_neighbor_bssid(self):
    self.__neighbor_bssid = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}$'}), is_leaf=True, yang_name="neighbor-bssid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:mac-address', is_config=False)


  def _get_neighbor_channel(self):
    """
    Getter method for neighbor_channel, mapped from YANG variable /access_points/access_point/ssids/ssid/clients/client/dot11k_neighbors/state/neighbor_channel (uint8)

    YANG Description: The channel of this neighbor.
    """
    return self.__neighbor_channel
      
  def _set_neighbor_channel(self, v, load=False):
    """
    Setter method for neighbor_channel, mapped from YANG variable /access_points/access_point/ssids/ssid/clients/client/dot11k_neighbors/state/neighbor_channel (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_neighbor_channel is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_neighbor_channel() directly.

    YANG Description: The channel of this neighbor.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="neighbor-channel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint8', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """neighbor_channel must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="neighbor-channel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint8', is_config=False)""",
        })

    self.__neighbor_channel = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_neighbor_channel(self):
    self.__neighbor_channel = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="neighbor-channel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint8', is_config=False)


  def _get_neighbor_rssi(self):
    """
    Getter method for neighbor_rssi, mapped from YANG variable /access_points/access_point/ssids/ssid/clients/client/dot11k_neighbors/state/neighbor_rssi (int8)

    YANG Description: The RSSI of this neighbor in dBm, expressed as a negative
number.
    """
    return self.__neighbor_rssi
      
  def _set_neighbor_rssi(self, v, load=False):
    """
    Setter method for neighbor_rssi, mapped from YANG variable /access_points/access_point/ssids/ssid/clients/client/dot11k_neighbors/state/neighbor_rssi (int8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_neighbor_rssi is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_neighbor_rssi() directly.

    YANG Description: The RSSI of this neighbor in dBm, expressed as a negative
number.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['-128..127']}, int_size=8), is_leaf=True, yang_name="neighbor-rssi", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='int8', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """neighbor_rssi must be of a type compatible with int8""",
          'defined-type': "int8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['-128..127']}, int_size=8), is_leaf=True, yang_name="neighbor-rssi", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='int8', is_config=False)""",
        })

    self.__neighbor_rssi = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_neighbor_rssi(self):
    self.__neighbor_rssi = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['-128..127']}, int_size=8), is_leaf=True, yang_name="neighbor-rssi", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='int8', is_config=False)


  def _get_neighbor_antenna(self):
    """
    Getter method for neighbor_antenna, mapped from YANG variable /access_points/access_point/ssids/ssid/clients/client/dot11k_neighbors/state/neighbor_antenna (uint8)

    YANG Description: Antenna details for this neighbor.
    """
    return self.__neighbor_antenna
      
  def _set_neighbor_antenna(self, v, load=False):
    """
    Setter method for neighbor_antenna, mapped from YANG variable /access_points/access_point/ssids/ssid/clients/client/dot11k_neighbors/state/neighbor_antenna (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_neighbor_antenna is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_neighbor_antenna() directly.

    YANG Description: Antenna details for this neighbor.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="neighbor-antenna", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint8', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """neighbor_antenna must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="neighbor-antenna", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint8', is_config=False)""",
        })

    self.__neighbor_antenna = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_neighbor_antenna(self):
    self.__neighbor_antenna = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="neighbor-antenna", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint8', is_config=False)


  def _get_channel_load_report(self):
    """
    Getter method for channel_load_report, mapped from YANG variable /access_points/access_point/ssids/ssid/clients/client/dot11k_neighbors/state/channel_load_report (uint8)

    YANG Description: Channel load, as reported by Client to AP
normalized to 255. See Sec. 10.11.9.3 of 802.11ac-2013
Spec.
    """
    return self.__channel_load_report
      
  def _set_channel_load_report(self, v, load=False):
    """
    Setter method for channel_load_report, mapped from YANG variable /access_points/access_point/ssids/ssid/clients/client/dot11k_neighbors/state/channel_load_report (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_channel_load_report is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_channel_load_report() directly.

    YANG Description: Channel load, as reported by Client to AP
normalized to 255. See Sec. 10.11.9.3 of 802.11ac-2013
Spec.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="channel-load-report", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint8', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """channel_load_report must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="channel-load-report", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint8', is_config=False)""",
        })

    self.__channel_load_report = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_channel_load_report(self):
    self.__channel_load_report = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="channel-load-report", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint8', is_config=False)

  neighbor_bssid = __builtin__.property(_get_neighbor_bssid)
  neighbor_channel = __builtin__.property(_get_neighbor_channel)
  neighbor_rssi = __builtin__.property(_get_neighbor_rssi)
  neighbor_antenna = __builtin__.property(_get_neighbor_antenna)
  channel_load_report = __builtin__.property(_get_channel_load_report)


  _pyangbind_elements = OrderedDict([('neighbor_bssid', neighbor_bssid), ('neighbor_channel', neighbor_channel), ('neighbor_rssi', neighbor_rssi), ('neighbor_antenna', neighbor_antenna), ('channel_load_report', channel_load_report), ])


class yc_dot11k_neighbors_openconfig_access_points__access_points_access_point_ssids_ssid_clients_client_dot11k_neighbors(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-access-points - based on the path /access-points/access-point/ssids/ssid/clients/client/dot11k-neighbors. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: 80211.k nieghbor information given from the Client to
the infrastructure.
  """
  __slots__ = ('_path_helper', '_extmethods', '__state',)

  _yang_name = 'dot11k-neighbors'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__state = YANGDynClass(base=yc_state_openconfig_access_points__access_points_access_point_ssids_ssid_clients_client_dot11k_neighbors_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'access-points', u'access-point', u'ssids', u'ssid', u'clients', u'client', u'dot11k-neighbors']

  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /access_points/access_point/ssids/ssid/clients/client/dot11k_neighbors/state (container)

    YANG Description: Container for Client beacon reports. Requires 802.11k
enabled. See Sec. 5.2.7.1 of 802.11k-2008 Standard.
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /access_points/access_point/ssids/ssid/clients/client/dot11k_neighbors/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: Container for Client beacon reports. Requires 802.11k
enabled. See Sec. 5.2.7.1 of 802.11k-2008 Standard.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_access_points__access_points_access_point_ssids_ssid_clients_client_dot11k_neighbors_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_access_points__access_points_access_point_ssids_ssid_clients_client_dot11k_neighbors_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=False)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_access_points__access_points_access_point_ssids_ssid_clients_client_dot11k_neighbors_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=False)

  state = __builtin__.property(_get_state)


  _pyangbind_elements = OrderedDict([('state', state), ])


class yc_state_openconfig_access_points__access_points_access_point_ssids_ssid_clients_client_client_connection_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-access-points - based on the path /access-points/access-point/ssids/ssid/clients/client/client-connection/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Container for connection state related data, per client.
  """
  __slots__ = ('_path_helper', '_extmethods', '__client_state','__connection_time','__username','__hostname','__ipv4_address','__ipv6_address','__operating_system',)

  _yang_name = 'state'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__username = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="username", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='string', is_config=False)
    self.__ipv6_address = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))$'}), is_leaf=True, yang_name="ipv6-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-inet:ipv6-address', is_config=False)
    self.__connection_time = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="connection-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint16', is_config=False)
    self.__hostname = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="hostname", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='string', is_config=False)
    self.__ipv4_address = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])$'}), is_leaf=True, yang_name="ipv4-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-inet:ipv4-address', is_config=False)
    self.__operating_system = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="operating-system", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='string', is_config=False)
    self.__client_state = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'ASSOCIATED': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'BLACKLISTED': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'L2AUTH_REQD': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:BLACKLISTED': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'L3AUTH_FAILURE': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'AUTHENTICATED': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:DHCP_REQD': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:ASSOCIATED': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:POWERSAVE': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:DHCP_FAILURE': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'L3AUTH_REQD': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'L2AUTH_FAILURE_TIMEOUT': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:L2AUTH_FAILURE_REJECT': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:L3AUTH_FAILURE': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:L2AUTH_FAILURE_TIMEOUT': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'POWERSAVE': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:AUTHENTICATED': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'DHCP_FAILURE': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:L3AUTH_REQD': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:L2AUTH_REQD': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'DHCP_REQD': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'L2AUTH_FAILURE_REJECT': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}},), is_leaf=True, yang_name="client-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='identityref', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'access-points', u'access-point', u'ssids', u'ssid', u'clients', u'client', u'client-connection', u'state']

  def _get_client_state(self):
    """
    Getter method for client_state, mapped from YANG variable /access_points/access_point/ssids/ssid/clients/client/client_connection/state/client_state (identityref)

    YANG Description: Various states a Client STA may be in.
    """
    return self.__client_state
      
  def _set_client_state(self, v, load=False):
    """
    Setter method for client_state, mapped from YANG variable /access_points/access_point/ssids/ssid/clients/client/client_connection/state/client_state (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_client_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_client_state() directly.

    YANG Description: Various states a Client STA may be in.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'ASSOCIATED': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'BLACKLISTED': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'L2AUTH_REQD': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:BLACKLISTED': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'L3AUTH_FAILURE': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'AUTHENTICATED': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:DHCP_REQD': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:ASSOCIATED': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:POWERSAVE': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:DHCP_FAILURE': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'L3AUTH_REQD': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'L2AUTH_FAILURE_TIMEOUT': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:L2AUTH_FAILURE_REJECT': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:L3AUTH_FAILURE': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:L2AUTH_FAILURE_TIMEOUT': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'POWERSAVE': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:AUTHENTICATED': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'DHCP_FAILURE': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:L3AUTH_REQD': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:L2AUTH_REQD': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'DHCP_REQD': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'L2AUTH_FAILURE_REJECT': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}},), is_leaf=True, yang_name="client-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='identityref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """client_state must be of a type compatible with identityref""",
          'defined-type': "openconfig-access-points:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'ASSOCIATED': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'BLACKLISTED': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'L2AUTH_REQD': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:BLACKLISTED': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'L3AUTH_FAILURE': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'AUTHENTICATED': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:DHCP_REQD': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:ASSOCIATED': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:POWERSAVE': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:DHCP_FAILURE': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'L3AUTH_REQD': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'L2AUTH_FAILURE_TIMEOUT': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:L2AUTH_FAILURE_REJECT': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:L3AUTH_FAILURE': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:L2AUTH_FAILURE_TIMEOUT': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'POWERSAVE': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:AUTHENTICATED': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'DHCP_FAILURE': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:L3AUTH_REQD': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:L2AUTH_REQD': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'DHCP_REQD': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'L2AUTH_FAILURE_REJECT': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}},), is_leaf=True, yang_name="client-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='identityref', is_config=False)""",
        })

    self.__client_state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_client_state(self):
    self.__client_state = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'ASSOCIATED': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'BLACKLISTED': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'L2AUTH_REQD': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:BLACKLISTED': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'L3AUTH_FAILURE': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'AUTHENTICATED': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:DHCP_REQD': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:ASSOCIATED': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:POWERSAVE': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:DHCP_FAILURE': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'L3AUTH_REQD': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'L2AUTH_FAILURE_TIMEOUT': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:L2AUTH_FAILURE_REJECT': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:L3AUTH_FAILURE': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:L2AUTH_FAILURE_TIMEOUT': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'POWERSAVE': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:AUTHENTICATED': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'DHCP_FAILURE': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:L3AUTH_REQD': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:L2AUTH_REQD': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'DHCP_REQD': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'L2AUTH_FAILURE_REJECT': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}},), is_leaf=True, yang_name="client-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='identityref', is_config=False)


  def _get_connection_time(self):
    """
    Getter method for connection_time, mapped from YANG variable /access_points/access_point/ssids/ssid/clients/client/client_connection/state/connection_time (uint16)

    YANG Description: Time, in seconds, since Client Association.
    """
    return self.__connection_time
      
  def _set_connection_time(self, v, load=False):
    """
    Setter method for connection_time, mapped from YANG variable /access_points/access_point/ssids/ssid/clients/client/client_connection/state/connection_time (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_connection_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_connection_time() directly.

    YANG Description: Time, in seconds, since Client Association.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="connection-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint16', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """connection_time must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="connection-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint16', is_config=False)""",
        })

    self.__connection_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_connection_time(self):
    self.__connection_time = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="connection-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint16', is_config=False)


  def _get_username(self):
    """
    Getter method for username, mapped from YANG variable /access_points/access_point/ssids/ssid/clients/client/client_connection/state/username (string)

    YANG Description: Username of Client; can be outer-identity (if PEAP),
CN of certificate (if EAP-TLS) etc.
    """
    return self.__username
      
  def _set_username(self, v, load=False):
    """
    Setter method for username, mapped from YANG variable /access_points/access_point/ssids/ssid/clients/client/client_connection/state/username (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_username is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_username() directly.

    YANG Description: Username of Client; can be outer-identity (if PEAP),
CN of certificate (if EAP-TLS) etc.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="username", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """username must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="username", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='string', is_config=False)""",
        })

    self.__username = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_username(self):
    self.__username = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="username", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='string', is_config=False)


  def _get_hostname(self):
    """
    Getter method for hostname, mapped from YANG variable /access_points/access_point/ssids/ssid/clients/client/client_connection/state/hostname (string)

    YANG Description: Hostname of the client, as discovered via DHCP, mDNS
or otherwise.
    """
    return self.__hostname
      
  def _set_hostname(self, v, load=False):
    """
    Setter method for hostname, mapped from YANG variable /access_points/access_point/ssids/ssid/clients/client/client_connection/state/hostname (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_hostname is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_hostname() directly.

    YANG Description: Hostname of the client, as discovered via DHCP, mDNS
or otherwise.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="hostname", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """hostname must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="hostname", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='string', is_config=False)""",
        })

    self.__hostname = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_hostname(self):
    self.__hostname = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="hostname", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='string', is_config=False)


  def _get_ipv4_address(self):
    """
    Getter method for ipv4_address, mapped from YANG variable /access_points/access_point/ssids/ssid/clients/client/client_connection/state/ipv4_address (oc-inet:ipv4-address)

    YANG Description: IPv4 address of the client.
    """
    return self.__ipv4_address
      
  def _set_ipv4_address(self, v, load=False):
    """
    Setter method for ipv4_address, mapped from YANG variable /access_points/access_point/ssids/ssid/clients/client/client_connection/state/ipv4_address (oc-inet:ipv4-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ipv4_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ipv4_address() directly.

    YANG Description: IPv4 address of the client.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])$'}), is_leaf=True, yang_name="ipv4-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-inet:ipv4-address', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ipv4_address must be of a type compatible with oc-inet:ipv4-address""",
          'defined-type': "oc-inet:ipv4-address",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])$'}), is_leaf=True, yang_name="ipv4-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-inet:ipv4-address', is_config=False)""",
        })

    self.__ipv4_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ipv4_address(self):
    self.__ipv4_address = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])$'}), is_leaf=True, yang_name="ipv4-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-inet:ipv4-address', is_config=False)


  def _get_ipv6_address(self):
    """
    Getter method for ipv6_address, mapped from YANG variable /access_points/access_point/ssids/ssid/clients/client/client_connection/state/ipv6_address (oc-inet:ipv6-address)

    YANG Description: IPv6 address of the client.
    """
    return self.__ipv6_address
      
  def _set_ipv6_address(self, v, load=False):
    """
    Setter method for ipv6_address, mapped from YANG variable /access_points/access_point/ssids/ssid/clients/client/client_connection/state/ipv6_address (oc-inet:ipv6-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ipv6_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ipv6_address() directly.

    YANG Description: IPv6 address of the client.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))$'}), is_leaf=True, yang_name="ipv6-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-inet:ipv6-address', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ipv6_address must be of a type compatible with oc-inet:ipv6-address""",
          'defined-type': "oc-inet:ipv6-address",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))$'}), is_leaf=True, yang_name="ipv6-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-inet:ipv6-address', is_config=False)""",
        })

    self.__ipv6_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ipv6_address(self):
    self.__ipv6_address = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))$'}), is_leaf=True, yang_name="ipv6-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-inet:ipv6-address', is_config=False)


  def _get_operating_system(self):
    """
    Getter method for operating_system, mapped from YANG variable /access_points/access_point/ssids/ssid/clients/client/client_connection/state/operating_system (string)

    YANG Description: Optional/if known; the OS of the client.
    """
    return self.__operating_system
      
  def _set_operating_system(self, v, load=False):
    """
    Setter method for operating_system, mapped from YANG variable /access_points/access_point/ssids/ssid/clients/client/client_connection/state/operating_system (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_operating_system is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_operating_system() directly.

    YANG Description: Optional/if known; the OS of the client.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="operating-system", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """operating_system must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="operating-system", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='string', is_config=False)""",
        })

    self.__operating_system = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_operating_system(self):
    self.__operating_system = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="operating-system", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='string', is_config=False)

  client_state = __builtin__.property(_get_client_state)
  connection_time = __builtin__.property(_get_connection_time)
  username = __builtin__.property(_get_username)
  hostname = __builtin__.property(_get_hostname)
  ipv4_address = __builtin__.property(_get_ipv4_address)
  ipv6_address = __builtin__.property(_get_ipv6_address)
  operating_system = __builtin__.property(_get_operating_system)


  _pyangbind_elements = OrderedDict([('client_state', client_state), ('connection_time', connection_time), ('username', username), ('hostname', hostname), ('ipv4_address', ipv4_address), ('ipv6_address', ipv6_address), ('operating_system', operating_system), ])


class yc_client_connection_openconfig_access_points__access_points_access_point_ssids_ssid_clients_client_client_connection(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-access-points - based on the path /access-points/access-point/ssids/ssid/clients/client/client-connection. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Connection-state and meta-data associated with the
Client.
  """
  __slots__ = ('_path_helper', '_extmethods', '__state',)

  _yang_name = 'client-connection'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__state = YANGDynClass(base=yc_state_openconfig_access_points__access_points_access_point_ssids_ssid_clients_client_client_connection_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'access-points', u'access-point', u'ssids', u'ssid', u'clients', u'client', u'client-connection']

  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /access_points/access_point/ssids/ssid/clients/client/client_connection/state (container)

    YANG Description: Container for connection state related data, per client.
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /access_points/access_point/ssids/ssid/clients/client/client_connection/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: Container for connection state related data, per client.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_access_points__access_points_access_point_ssids_ssid_clients_client_client_connection_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_access_points__access_points_access_point_ssids_ssid_clients_client_client_connection_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=False)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_access_points__access_points_access_point_ssids_ssid_clients_client_client_connection_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=False)

  state = __builtin__.property(_get_state)


  _pyangbind_elements = OrderedDict([('state', state), ])


class yc_client_openconfig_access_points__access_points_access_point_ssids_ssid_clients_client(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-access-points - based on the path /access-points/access-point/ssids/ssid/clients/client. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of clients per BSS.
  """
  __slots__ = ('_path_helper', '_extmethods', '__mac','__state','__client_rf','__client_capabilities','__dot11k_neighbors','__client_connection',)

  _yang_name = 'client'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__dot11k_neighbors = YANGDynClass(base=yc_dot11k_neighbors_openconfig_access_points__access_points_access_point_ssids_ssid_clients_client_dot11k_neighbors, is_container='container', yang_name="dot11k-neighbors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=False)
    self.__client_connection = YANGDynClass(base=yc_client_connection_openconfig_access_points__access_points_access_point_ssids_ssid_clients_client_client_connection, is_container='container', yang_name="client-connection", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=False)
    self.__state = YANGDynClass(base=yc_state_openconfig_access_points__access_points_access_point_ssids_ssid_clients_client_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=False)
    self.__client_capabilities = YANGDynClass(base=yc_client_capabilities_openconfig_access_points__access_points_access_point_ssids_ssid_clients_client_client_capabilities, is_container='container', yang_name="client-capabilities", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=False)
    self.__mac = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="mac", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='leafref', is_config=False)
    self.__client_rf = YANGDynClass(base=yc_client_rf_openconfig_access_points__access_points_access_point_ssids_ssid_clients_client_client_rf, is_container='container', yang_name="client-rf", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'access-points', u'access-point', u'ssids', u'ssid', u'clients', u'client']

  def _get_mac(self):
    """
    Getter method for mac, mapped from YANG variable /access_points/access_point/ssids/ssid/clients/client/mac (leafref)

    YANG Description: The clients WiFi MAC address.
    """
    return self.__mac
      
  def _set_mac(self, v, load=False):
    """
    Setter method for mac, mapped from YANG variable /access_points/access_point/ssids/ssid/clients/client/mac (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mac is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mac() directly.

    YANG Description: The clients WiFi MAC address.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="mac", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='leafref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mac must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="mac", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='leafref', is_config=False)""",
        })

    self.__mac = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mac(self):
    self.__mac = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="mac", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='leafref', is_config=False)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /access_points/access_point/ssids/ssid/clients/client/state (container)

    YANG Description: Client state data.
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /access_points/access_point/ssids/ssid/clients/client/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: Client state data.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_access_points__access_points_access_point_ssids_ssid_clients_client_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_access_points__access_points_access_point_ssids_ssid_clients_client_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=False)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_access_points__access_points_access_point_ssids_ssid_clients_client_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=False)


  def _get_client_rf(self):
    """
    Getter method for client_rf, mapped from YANG variable /access_points/access_point/ssids/ssid/clients/client/client_rf (container)

    YANG Description: RF radio-data per non-AP STA.
    """
    return self.__client_rf
      
  def _set_client_rf(self, v, load=False):
    """
    Setter method for client_rf, mapped from YANG variable /access_points/access_point/ssids/ssid/clients/client/client_rf (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_client_rf is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_client_rf() directly.

    YANG Description: RF radio-data per non-AP STA.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_client_rf_openconfig_access_points__access_points_access_point_ssids_ssid_clients_client_client_rf, is_container='container', yang_name="client-rf", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """client_rf must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_client_rf_openconfig_access_points__access_points_access_point_ssids_ssid_clients_client_client_rf, is_container='container', yang_name="client-rf", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=False)""",
        })

    self.__client_rf = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_client_rf(self):
    self.__client_rf = YANGDynClass(base=yc_client_rf_openconfig_access_points__access_points_access_point_ssids_ssid_clients_client_client_rf, is_container='container', yang_name="client-rf", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=False)


  def _get_client_capabilities(self):
    """
    Getter method for client_capabilities, mapped from YANG variable /access_points/access_point/ssids/ssid/clients/client/client_capabilities (container)

    YANG Description: Capabilites as advertised by the Client.
    """
    return self.__client_capabilities
      
  def _set_client_capabilities(self, v, load=False):
    """
    Setter method for client_capabilities, mapped from YANG variable /access_points/access_point/ssids/ssid/clients/client/client_capabilities (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_client_capabilities is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_client_capabilities() directly.

    YANG Description: Capabilites as advertised by the Client.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_client_capabilities_openconfig_access_points__access_points_access_point_ssids_ssid_clients_client_client_capabilities, is_container='container', yang_name="client-capabilities", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """client_capabilities must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_client_capabilities_openconfig_access_points__access_points_access_point_ssids_ssid_clients_client_client_capabilities, is_container='container', yang_name="client-capabilities", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=False)""",
        })

    self.__client_capabilities = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_client_capabilities(self):
    self.__client_capabilities = YANGDynClass(base=yc_client_capabilities_openconfig_access_points__access_points_access_point_ssids_ssid_clients_client_client_capabilities, is_container='container', yang_name="client-capabilities", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=False)


  def _get_dot11k_neighbors(self):
    """
    Getter method for dot11k_neighbors, mapped from YANG variable /access_points/access_point/ssids/ssid/clients/client/dot11k_neighbors (container)

    YANG Description: 80211.k nieghbor information given from the Client to
the infrastructure.
    """
    return self.__dot11k_neighbors
      
  def _set_dot11k_neighbors(self, v, load=False):
    """
    Setter method for dot11k_neighbors, mapped from YANG variable /access_points/access_point/ssids/ssid/clients/client/dot11k_neighbors (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dot11k_neighbors is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dot11k_neighbors() directly.

    YANG Description: 80211.k nieghbor information given from the Client to
the infrastructure.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_dot11k_neighbors_openconfig_access_points__access_points_access_point_ssids_ssid_clients_client_dot11k_neighbors, is_container='container', yang_name="dot11k-neighbors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dot11k_neighbors must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_dot11k_neighbors_openconfig_access_points__access_points_access_point_ssids_ssid_clients_client_dot11k_neighbors, is_container='container', yang_name="dot11k-neighbors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=False)""",
        })

    self.__dot11k_neighbors = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dot11k_neighbors(self):
    self.__dot11k_neighbors = YANGDynClass(base=yc_dot11k_neighbors_openconfig_access_points__access_points_access_point_ssids_ssid_clients_client_dot11k_neighbors, is_container='container', yang_name="dot11k-neighbors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=False)


  def _get_client_connection(self):
    """
    Getter method for client_connection, mapped from YANG variable /access_points/access_point/ssids/ssid/clients/client/client_connection (container)

    YANG Description: Connection-state and meta-data associated with the
Client.
    """
    return self.__client_connection
      
  def _set_client_connection(self, v, load=False):
    """
    Setter method for client_connection, mapped from YANG variable /access_points/access_point/ssids/ssid/clients/client/client_connection (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_client_connection is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_client_connection() directly.

    YANG Description: Connection-state and meta-data associated with the
Client.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_client_connection_openconfig_access_points__access_points_access_point_ssids_ssid_clients_client_client_connection, is_container='container', yang_name="client-connection", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """client_connection must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_client_connection_openconfig_access_points__access_points_access_point_ssids_ssid_clients_client_client_connection, is_container='container', yang_name="client-connection", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=False)""",
        })

    self.__client_connection = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_client_connection(self):
    self.__client_connection = YANGDynClass(base=yc_client_connection_openconfig_access_points__access_points_access_point_ssids_ssid_clients_client_client_connection, is_container='container', yang_name="client-connection", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=False)

  mac = __builtin__.property(_get_mac)
  state = __builtin__.property(_get_state)
  client_rf = __builtin__.property(_get_client_rf)
  client_capabilities = __builtin__.property(_get_client_capabilities)
  dot11k_neighbors = __builtin__.property(_get_dot11k_neighbors)
  client_connection = __builtin__.property(_get_client_connection)


  _pyangbind_elements = OrderedDict([('mac', mac), ('state', state), ('client_rf', client_rf), ('client_capabilities', client_capabilities), ('dot11k_neighbors', dot11k_neighbors), ('client_connection', client_connection), ])


class yc_clients_openconfig_access_points__access_points_access_point_ssids_ssid_clients(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-access-points - based on the path /access-points/access-point/ssids/ssid/clients. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Top-level container for clients operational state data.
  """
  __slots__ = ('_path_helper', '_extmethods', '__client',)

  _yang_name = 'clients'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__client = YANGDynClass(base=YANGListType("mac",yc_client_openconfig_access_points__access_points_access_point_ssids_ssid_clients_client, yang_name="client", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='mac', extensions=None), is_container='list', yang_name="client", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'access-points', u'access-point', u'ssids', u'ssid', u'clients']

  def _get_client(self):
    """
    Getter method for client, mapped from YANG variable /access_points/access_point/ssids/ssid/clients/client (list)

    YANG Description: List of clients per BSS.
    """
    return self.__client
      
  def _set_client(self, v, load=False):
    """
    Setter method for client, mapped from YANG variable /access_points/access_point/ssids/ssid/clients/client (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_client is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_client() directly.

    YANG Description: List of clients per BSS.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("mac",yc_client_openconfig_access_points__access_points_access_point_ssids_ssid_clients_client, yang_name="client", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='mac', extensions=None), is_container='list', yang_name="client", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """client must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("mac",yc_client_openconfig_access_points__access_points_access_point_ssids_ssid_clients_client, yang_name="client", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='mac', extensions=None), is_container='list', yang_name="client", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='list', is_config=True)""",
        })

    self.__client = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_client(self):
    self.__client = YANGDynClass(base=YANGListType("mac",yc_client_openconfig_access_points__access_points_access_point_ssids_ssid_clients_client, yang_name="client", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='mac', extensions=None), is_container='list', yang_name="client", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='list', is_config=True)

  client = __builtin__.property(_get_client, _set_client)


  _pyangbind_elements = OrderedDict([('client', client), ])


class yc_config_openconfig_access_points__access_points_access_point_ssids_ssid_dot1x_timers_config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-access-points - based on the path /access-points/access-point/ssids/ssid/dot1x-timers/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Container for dot1x configuration elements.
  """
  __slots__ = ('_path_helper', '_extmethods', '__max_auth_failures','__blacklist_time',)

  _yang_name = 'config'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__blacklist_time = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="blacklist-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint16', is_config=True)
    self.__max_auth_failures = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="max-auth-failures", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint8', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'access-points', u'access-point', u'ssids', u'ssid', u'dot1x-timers', u'config']

  def _get_max_auth_failures(self):
    """
    Getter method for max_auth_failures, mapped from YANG variable /access_points/access_point/ssids/ssid/dot1x_timers/config/max_auth_failures (uint8)

    YANG Description: Number of consecutive authentication failures,
via RADIUS Access-Reject, before Station
is blacklisted.
    """
    return self.__max_auth_failures
      
  def _set_max_auth_failures(self, v, load=False):
    """
    Setter method for max_auth_failures, mapped from YANG variable /access_points/access_point/ssids/ssid/dot1x_timers/config/max_auth_failures (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_auth_failures is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_auth_failures() directly.

    YANG Description: Number of consecutive authentication failures,
via RADIUS Access-Reject, before Station
is blacklisted.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="max-auth-failures", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_auth_failures must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="max-auth-failures", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint8', is_config=True)""",
        })

    self.__max_auth_failures = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_auth_failures(self):
    self.__max_auth_failures = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="max-auth-failures", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint8', is_config=True)


  def _get_blacklist_time(self):
    """
    Getter method for blacklist_time, mapped from YANG variable /access_points/access_point/ssids/ssid/dot1x_timers/config/blacklist_time (uint16)

    YANG Description: Length of time, in seconds, a Station will be
blacklisted as a result of max-auth-failures.
    """
    return self.__blacklist_time
      
  def _set_blacklist_time(self, v, load=False):
    """
    Setter method for blacklist_time, mapped from YANG variable /access_points/access_point/ssids/ssid/dot1x_timers/config/blacklist_time (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_blacklist_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_blacklist_time() directly.

    YANG Description: Length of time, in seconds, a Station will be
blacklisted as a result of max-auth-failures.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="blacklist-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """blacklist_time must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="blacklist-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint16', is_config=True)""",
        })

    self.__blacklist_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_blacklist_time(self):
    self.__blacklist_time = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="blacklist-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint16', is_config=True)

  max_auth_failures = __builtin__.property(_get_max_auth_failures, _set_max_auth_failures)
  blacklist_time = __builtin__.property(_get_blacklist_time, _set_blacklist_time)


  _pyangbind_elements = OrderedDict([('max_auth_failures', max_auth_failures), ('blacklist_time', blacklist_time), ])


class yc_state_openconfig_access_points__access_points_access_point_ssids_ssid_dot1x_timers_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-access-points - based on the path /access-points/access-point/ssids/ssid/dot1x-timers/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Container for dot1x state elements.
  """
  __slots__ = ('_path_helper', '_extmethods', '__max_auth_failures','__blacklist_time',)

  _yang_name = 'state'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__blacklist_time = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="blacklist-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint16', is_config=False)
    self.__max_auth_failures = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="max-auth-failures", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint8', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'access-points', u'access-point', u'ssids', u'ssid', u'dot1x-timers', u'state']

  def _get_max_auth_failures(self):
    """
    Getter method for max_auth_failures, mapped from YANG variable /access_points/access_point/ssids/ssid/dot1x_timers/state/max_auth_failures (uint8)

    YANG Description: Number of consecutive authentication failures,
via RADIUS Access-Reject, before Station
is blacklisted.
    """
    return self.__max_auth_failures
      
  def _set_max_auth_failures(self, v, load=False):
    """
    Setter method for max_auth_failures, mapped from YANG variable /access_points/access_point/ssids/ssid/dot1x_timers/state/max_auth_failures (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_auth_failures is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_auth_failures() directly.

    YANG Description: Number of consecutive authentication failures,
via RADIUS Access-Reject, before Station
is blacklisted.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="max-auth-failures", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint8', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_auth_failures must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="max-auth-failures", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint8', is_config=False)""",
        })

    self.__max_auth_failures = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_auth_failures(self):
    self.__max_auth_failures = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="max-auth-failures", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint8', is_config=False)


  def _get_blacklist_time(self):
    """
    Getter method for blacklist_time, mapped from YANG variable /access_points/access_point/ssids/ssid/dot1x_timers/state/blacklist_time (uint16)

    YANG Description: Length of time, in seconds, a Station will be
blacklisted as a result of max-auth-failures.
    """
    return self.__blacklist_time
      
  def _set_blacklist_time(self, v, load=False):
    """
    Setter method for blacklist_time, mapped from YANG variable /access_points/access_point/ssids/ssid/dot1x_timers/state/blacklist_time (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_blacklist_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_blacklist_time() directly.

    YANG Description: Length of time, in seconds, a Station will be
blacklisted as a result of max-auth-failures.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="blacklist-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint16', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """blacklist_time must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="blacklist-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint16', is_config=False)""",
        })

    self.__blacklist_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_blacklist_time(self):
    self.__blacklist_time = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="blacklist-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint16', is_config=False)

  max_auth_failures = __builtin__.property(_get_max_auth_failures)
  blacklist_time = __builtin__.property(_get_blacklist_time)


  _pyangbind_elements = OrderedDict([('max_auth_failures', max_auth_failures), ('blacklist_time', blacklist_time), ])


class yc_dot1x_timers_openconfig_access_points__access_points_access_point_ssids_ssid_dot1x_timers(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-access-points - based on the path /access-points/access-point/ssids/ssid/dot1x-timers. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Top-level container for dot1x configuration
and operational state data.
  """
  __slots__ = ('_path_helper', '_extmethods', '__config','__state',)

  _yang_name = 'dot1x-timers'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__state = YANGDynClass(base=yc_state_openconfig_access_points__access_points_access_point_ssids_ssid_dot1x_timers_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)
    self.__config = YANGDynClass(base=yc_config_openconfig_access_points__access_points_access_point_ssids_ssid_dot1x_timers_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'access-points', u'access-point', u'ssids', u'ssid', u'dot1x-timers']

  def _get_config(self):
    """
    Getter method for config, mapped from YANG variable /access_points/access_point/ssids/ssid/dot1x_timers/config (container)

    YANG Description: Container for dot1x configuration elements.
    """
    return self.__config
      
  def _set_config(self, v, load=False):
    """
    Setter method for config, mapped from YANG variable /access_points/access_point/ssids/ssid/dot1x_timers/config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config() directly.

    YANG Description: Container for dot1x configuration elements.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_config_openconfig_access_points__access_points_access_point_ssids_ssid_dot1x_timers_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_config_openconfig_access_points__access_points_access_point_ssids_ssid_dot1x_timers_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)""",
        })

    self.__config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config(self):
    self.__config = YANGDynClass(base=yc_config_openconfig_access_points__access_points_access_point_ssids_ssid_dot1x_timers_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /access_points/access_point/ssids/ssid/dot1x_timers/state (container)

    YANG Description: Container for dot1x state elements.
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /access_points/access_point/ssids/ssid/dot1x_timers/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: Container for dot1x state elements.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_access_points__access_points_access_point_ssids_ssid_dot1x_timers_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_access_points__access_points_access_point_ssids_ssid_dot1x_timers_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_access_points__access_points_access_point_ssids_ssid_dot1x_timers_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)

  config = __builtin__.property(_get_config, _set_config)
  state = __builtin__.property(_get_state, _set_state)


  _pyangbind_elements = OrderedDict([('config', config), ('state', state), ])


class yc_config_openconfig_access_points__access_points_access_point_ssids_ssid_band_steering_config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-access-points - based on the path /access-points/access-point/ssids/ssid/band-steering/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Container for band-steering configuration elements.
  """
  __slots__ = ('_path_helper', '_extmethods', '__band_steering','__steering_rssi',)

  _yang_name = 'config'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__band_steering = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="band-steering", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=True)
    self.__steering_rssi = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['-128..127']}, int_size=8), is_leaf=True, yang_name="steering-rssi", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='int8', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'access-points', u'access-point', u'ssids', u'ssid', u'band-steering', u'config']

  def _get_band_steering(self):
    """
    Getter method for band_steering, mapped from YANG variable /access_points/access_point/ssids/ssid/band_steering/config/band_steering (boolean)

    YANG Description: Enable/disable band-steering.
    """
    return self.__band_steering
      
  def _set_band_steering(self, v, load=False):
    """
    Setter method for band_steering, mapped from YANG variable /access_points/access_point/ssids/ssid/band_steering/config/band_steering (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_band_steering is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_band_steering() directly.

    YANG Description: Enable/disable band-steering.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="band-steering", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """band_steering must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="band-steering", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=True)""",
        })

    self.__band_steering = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_band_steering(self):
    self.__band_steering = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="band-steering", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=True)


  def _get_steering_rssi(self):
    """
    Getter method for steering_rssi, mapped from YANG variable /access_points/access_point/ssids/ssid/band_steering/config/steering_rssi (int8)

    YANG Description: Minimum RSSI a dual-band Station's Probe Request
must be heard at on a 5GHz radio, in order for
band-steering to withhold 2.4GHz Probe Responses.
    """
    return self.__steering_rssi
      
  def _set_steering_rssi(self, v, load=False):
    """
    Setter method for steering_rssi, mapped from YANG variable /access_points/access_point/ssids/ssid/band_steering/config/steering_rssi (int8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_steering_rssi is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_steering_rssi() directly.

    YANG Description: Minimum RSSI a dual-band Station's Probe Request
must be heard at on a 5GHz radio, in order for
band-steering to withhold 2.4GHz Probe Responses.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['-128..127']}, int_size=8), is_leaf=True, yang_name="steering-rssi", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='int8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """steering_rssi must be of a type compatible with int8""",
          'defined-type': "int8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['-128..127']}, int_size=8), is_leaf=True, yang_name="steering-rssi", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='int8', is_config=True)""",
        })

    self.__steering_rssi = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_steering_rssi(self):
    self.__steering_rssi = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['-128..127']}, int_size=8), is_leaf=True, yang_name="steering-rssi", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='int8', is_config=True)

  band_steering = __builtin__.property(_get_band_steering, _set_band_steering)
  steering_rssi = __builtin__.property(_get_steering_rssi, _set_steering_rssi)


  _pyangbind_elements = OrderedDict([('band_steering', band_steering), ('steering_rssi', steering_rssi), ])


class yc_state_openconfig_access_points__access_points_access_point_ssids_ssid_band_steering_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-access-points - based on the path /access-points/access-point/ssids/ssid/band-steering/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Container for band-steering state elements.
  """
  __slots__ = ('_path_helper', '_extmethods', '__band_steering','__steering_rssi',)

  _yang_name = 'state'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__band_steering = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="band-steering", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=False)
    self.__steering_rssi = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['-128..127']}, int_size=8), is_leaf=True, yang_name="steering-rssi", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='int8', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'access-points', u'access-point', u'ssids', u'ssid', u'band-steering', u'state']

  def _get_band_steering(self):
    """
    Getter method for band_steering, mapped from YANG variable /access_points/access_point/ssids/ssid/band_steering/state/band_steering (boolean)

    YANG Description: Enable/disable band-steering.
    """
    return self.__band_steering
      
  def _set_band_steering(self, v, load=False):
    """
    Setter method for band_steering, mapped from YANG variable /access_points/access_point/ssids/ssid/band_steering/state/band_steering (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_band_steering is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_band_steering() directly.

    YANG Description: Enable/disable band-steering.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="band-steering", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """band_steering must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="band-steering", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=False)""",
        })

    self.__band_steering = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_band_steering(self):
    self.__band_steering = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="band-steering", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=False)


  def _get_steering_rssi(self):
    """
    Getter method for steering_rssi, mapped from YANG variable /access_points/access_point/ssids/ssid/band_steering/state/steering_rssi (int8)

    YANG Description: Minimum RSSI a dual-band Station's Probe Request
must be heard at on a 5GHz radio, in order for
band-steering to withhold 2.4GHz Probe Responses.
    """
    return self.__steering_rssi
      
  def _set_steering_rssi(self, v, load=False):
    """
    Setter method for steering_rssi, mapped from YANG variable /access_points/access_point/ssids/ssid/band_steering/state/steering_rssi (int8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_steering_rssi is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_steering_rssi() directly.

    YANG Description: Minimum RSSI a dual-band Station's Probe Request
must be heard at on a 5GHz radio, in order for
band-steering to withhold 2.4GHz Probe Responses.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['-128..127']}, int_size=8), is_leaf=True, yang_name="steering-rssi", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='int8', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """steering_rssi must be of a type compatible with int8""",
          'defined-type': "int8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['-128..127']}, int_size=8), is_leaf=True, yang_name="steering-rssi", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='int8', is_config=False)""",
        })

    self.__steering_rssi = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_steering_rssi(self):
    self.__steering_rssi = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['-128..127']}, int_size=8), is_leaf=True, yang_name="steering-rssi", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='int8', is_config=False)

  band_steering = __builtin__.property(_get_band_steering)
  steering_rssi = __builtin__.property(_get_steering_rssi)


  _pyangbind_elements = OrderedDict([('band_steering', band_steering), ('steering_rssi', steering_rssi), ])


class yc_band_steering_openconfig_access_points__access_points_access_point_ssids_ssid_band_steering(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-access-points - based on the path /access-points/access-point/ssids/ssid/band-steering. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Top-level container for band-steering configuration
and operational state data.
  """
  __slots__ = ('_path_helper', '_extmethods', '__config','__state',)

  _yang_name = 'band-steering'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__state = YANGDynClass(base=yc_state_openconfig_access_points__access_points_access_point_ssids_ssid_band_steering_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)
    self.__config = YANGDynClass(base=yc_config_openconfig_access_points__access_points_access_point_ssids_ssid_band_steering_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'access-points', u'access-point', u'ssids', u'ssid', u'band-steering']

  def _get_config(self):
    """
    Getter method for config, mapped from YANG variable /access_points/access_point/ssids/ssid/band_steering/config (container)

    YANG Description: Container for band-steering configuration elements.
    """
    return self.__config
      
  def _set_config(self, v, load=False):
    """
    Setter method for config, mapped from YANG variable /access_points/access_point/ssids/ssid/band_steering/config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config() directly.

    YANG Description: Container for band-steering configuration elements.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_config_openconfig_access_points__access_points_access_point_ssids_ssid_band_steering_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_config_openconfig_access_points__access_points_access_point_ssids_ssid_band_steering_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)""",
        })

    self.__config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config(self):
    self.__config = YANGDynClass(base=yc_config_openconfig_access_points__access_points_access_point_ssids_ssid_band_steering_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /access_points/access_point/ssids/ssid/band_steering/state (container)

    YANG Description: Container for band-steering state elements.
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /access_points/access_point/ssids/ssid/band_steering/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: Container for band-steering state elements.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_access_points__access_points_access_point_ssids_ssid_band_steering_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_access_points__access_points_access_point_ssids_ssid_band_steering_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_access_points__access_points_access_point_ssids_ssid_band_steering_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)

  config = __builtin__.property(_get_config, _set_config)
  state = __builtin__.property(_get_state, _set_state)


  _pyangbind_elements = OrderedDict([('config', config), ('state', state), ])


class yc_ssid_openconfig_access_points__access_points_access_point_ssids_ssid(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-access-points - based on the path /access-points/access-point/ssids/ssid. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The list of named ssids on the APs.
  """
  __slots__ = ('_path_helper', '_extmethods', '__name','__config','__state','__bssids','__wmm','__dot11r','__dot11v','__clients','__dot1x_timers','__band_steering',)

  _yang_name = 'ssid'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='leafref', is_config=True)
    self.__dot1x_timers = YANGDynClass(base=yc_dot1x_timers_openconfig_access_points__access_points_access_point_ssids_ssid_dot1x_timers, is_container='container', yang_name="dot1x-timers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)
    self.__config = YANGDynClass(base=yc_config_openconfig_access_points__access_points_access_point_ssids_ssid_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)
    self.__clients = YANGDynClass(base=yc_clients_openconfig_access_points__access_points_access_point_ssids_ssid_clients, is_container='container', yang_name="clients", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)
    self.__state = YANGDynClass(base=yc_state_openconfig_access_points__access_points_access_point_ssids_ssid_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)
    self.__wmm = YANGDynClass(base=yc_wmm_openconfig_access_points__access_points_access_point_ssids_ssid_wmm, is_container='container', yang_name="wmm", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)
    self.__band_steering = YANGDynClass(base=yc_band_steering_openconfig_access_points__access_points_access_point_ssids_ssid_band_steering, is_container='container', yang_name="band-steering", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)
    self.__dot11v = YANGDynClass(base=yc_dot11v_openconfig_access_points__access_points_access_point_ssids_ssid_dot11v, is_container='container', yang_name="dot11v", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)
    self.__bssids = YANGDynClass(base=yc_bssids_openconfig_access_points__access_points_access_point_ssids_ssid_bssids, is_container='container', yang_name="bssids", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)
    self.__dot11r = YANGDynClass(base=yc_dot11r_openconfig_access_points__access_points_access_point_ssids_ssid_dot11r, is_container='container', yang_name="dot11r", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'access-points', u'access-point', u'ssids', u'ssid']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /access_points/access_point/ssids/ssid/name (leafref)

    YANG Description: References the configured name of the ssid
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /access_points/access_point/ssids/ssid/name (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: References the configured name of the ssid
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='leafref', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='leafref', is_config=True)


  def _get_config(self):
    """
    Getter method for config, mapped from YANG variable /access_points/access_point/ssids/ssid/config (container)

    YANG Description: Configurable items at the global, ssid level
    """
    return self.__config
      
  def _set_config(self, v, load=False):
    """
    Setter method for config, mapped from YANG variable /access_points/access_point/ssids/ssid/config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config() directly.

    YANG Description: Configurable items at the global, ssid level
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_config_openconfig_access_points__access_points_access_point_ssids_ssid_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_config_openconfig_access_points__access_points_access_point_ssids_ssid_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)""",
        })

    self.__config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config(self):
    self.__config = YANGDynClass(base=yc_config_openconfig_access_points__access_points_access_point_ssids_ssid_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /access_points/access_point/ssids/ssid/state (container)

    YANG Description: Operational state data at the ssid level
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /access_points/access_point/ssids/ssid/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: Operational state data at the ssid level
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_access_points__access_points_access_point_ssids_ssid_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_access_points__access_points_access_point_ssids_ssid_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_access_points__access_points_access_point_ssids_ssid_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)


  def _get_bssids(self):
    """
    Getter method for bssids, mapped from YANG variable /access_points/access_point/ssids/ssid/bssids (container)

    YANG Description: Top-level container for BSSIDs operational state data.
    """
    return self.__bssids
      
  def _set_bssids(self, v, load=False):
    """
    Setter method for bssids, mapped from YANG variable /access_points/access_point/ssids/ssid/bssids (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bssids is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bssids() directly.

    YANG Description: Top-level container for BSSIDs operational state data.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_bssids_openconfig_access_points__access_points_access_point_ssids_ssid_bssids, is_container='container', yang_name="bssids", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bssids must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_bssids_openconfig_access_points__access_points_access_point_ssids_ssid_bssids, is_container='container', yang_name="bssids", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)""",
        })

    self.__bssids = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bssids(self):
    self.__bssids = YANGDynClass(base=yc_bssids_openconfig_access_points__access_points_access_point_ssids_ssid_bssids, is_container='container', yang_name="bssids", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)


  def _get_wmm(self):
    """
    Getter method for wmm, mapped from YANG variable /access_points/access_point/ssids/ssid/wmm (container)

    YANG Description: Top-level container for WMM configuration and
state container.
    """
    return self.__wmm
      
  def _set_wmm(self, v, load=False):
    """
    Setter method for wmm, mapped from YANG variable /access_points/access_point/ssids/ssid/wmm (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_wmm is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_wmm() directly.

    YANG Description: Top-level container for WMM configuration and
state container.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_wmm_openconfig_access_points__access_points_access_point_ssids_ssid_wmm, is_container='container', yang_name="wmm", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """wmm must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_wmm_openconfig_access_points__access_points_access_point_ssids_ssid_wmm, is_container='container', yang_name="wmm", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)""",
        })

    self.__wmm = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_wmm(self):
    self.__wmm = YANGDynClass(base=yc_wmm_openconfig_access_points__access_points_access_point_ssids_ssid_wmm, is_container='container', yang_name="wmm", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)


  def _get_dot11r(self):
    """
    Getter method for dot11r, mapped from YANG variable /access_points/access_point/ssids/ssid/dot11r (container)

    YANG Description: Top-level container for 802.11r configuration and
state container.
    """
    return self.__dot11r
      
  def _set_dot11r(self, v, load=False):
    """
    Setter method for dot11r, mapped from YANG variable /access_points/access_point/ssids/ssid/dot11r (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dot11r is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dot11r() directly.

    YANG Description: Top-level container for 802.11r configuration and
state container.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_dot11r_openconfig_access_points__access_points_access_point_ssids_ssid_dot11r, is_container='container', yang_name="dot11r", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dot11r must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_dot11r_openconfig_access_points__access_points_access_point_ssids_ssid_dot11r, is_container='container', yang_name="dot11r", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)""",
        })

    self.__dot11r = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dot11r(self):
    self.__dot11r = YANGDynClass(base=yc_dot11r_openconfig_access_points__access_points_access_point_ssids_ssid_dot11r, is_container='container', yang_name="dot11r", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)


  def _get_dot11v(self):
    """
    Getter method for dot11v, mapped from YANG variable /access_points/access_point/ssids/ssid/dot11v (container)

    YANG Description: Top-level container for 802.11v configuration and
operational state data.
    """
    return self.__dot11v
      
  def _set_dot11v(self, v, load=False):
    """
    Setter method for dot11v, mapped from YANG variable /access_points/access_point/ssids/ssid/dot11v (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dot11v is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dot11v() directly.

    YANG Description: Top-level container for 802.11v configuration and
operational state data.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_dot11v_openconfig_access_points__access_points_access_point_ssids_ssid_dot11v, is_container='container', yang_name="dot11v", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dot11v must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_dot11v_openconfig_access_points__access_points_access_point_ssids_ssid_dot11v, is_container='container', yang_name="dot11v", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)""",
        })

    self.__dot11v = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dot11v(self):
    self.__dot11v = YANGDynClass(base=yc_dot11v_openconfig_access_points__access_points_access_point_ssids_ssid_dot11v, is_container='container', yang_name="dot11v", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)


  def _get_clients(self):
    """
    Getter method for clients, mapped from YANG variable /access_points/access_point/ssids/ssid/clients (container)

    YANG Description: Top-level container for clients operational state data.
    """
    return self.__clients
      
  def _set_clients(self, v, load=False):
    """
    Setter method for clients, mapped from YANG variable /access_points/access_point/ssids/ssid/clients (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_clients is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_clients() directly.

    YANG Description: Top-level container for clients operational state data.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_clients_openconfig_access_points__access_points_access_point_ssids_ssid_clients, is_container='container', yang_name="clients", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """clients must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_clients_openconfig_access_points__access_points_access_point_ssids_ssid_clients, is_container='container', yang_name="clients", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)""",
        })

    self.__clients = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_clients(self):
    self.__clients = YANGDynClass(base=yc_clients_openconfig_access_points__access_points_access_point_ssids_ssid_clients, is_container='container', yang_name="clients", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)


  def _get_dot1x_timers(self):
    """
    Getter method for dot1x_timers, mapped from YANG variable /access_points/access_point/ssids/ssid/dot1x_timers (container)

    YANG Description: Top-level container for dot1x configuration
and operational state data.
    """
    return self.__dot1x_timers
      
  def _set_dot1x_timers(self, v, load=False):
    """
    Setter method for dot1x_timers, mapped from YANG variable /access_points/access_point/ssids/ssid/dot1x_timers (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dot1x_timers is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dot1x_timers() directly.

    YANG Description: Top-level container for dot1x configuration
and operational state data.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_dot1x_timers_openconfig_access_points__access_points_access_point_ssids_ssid_dot1x_timers, is_container='container', yang_name="dot1x-timers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dot1x_timers must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_dot1x_timers_openconfig_access_points__access_points_access_point_ssids_ssid_dot1x_timers, is_container='container', yang_name="dot1x-timers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)""",
        })

    self.__dot1x_timers = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dot1x_timers(self):
    self.__dot1x_timers = YANGDynClass(base=yc_dot1x_timers_openconfig_access_points__access_points_access_point_ssids_ssid_dot1x_timers, is_container='container', yang_name="dot1x-timers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)


  def _get_band_steering(self):
    """
    Getter method for band_steering, mapped from YANG variable /access_points/access_point/ssids/ssid/band_steering (container)

    YANG Description: Top-level container for band-steering configuration
and operational state data.
    """
    return self.__band_steering
      
  def _set_band_steering(self, v, load=False):
    """
    Setter method for band_steering, mapped from YANG variable /access_points/access_point/ssids/ssid/band_steering (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_band_steering is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_band_steering() directly.

    YANG Description: Top-level container for band-steering configuration
and operational state data.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_band_steering_openconfig_access_points__access_points_access_point_ssids_ssid_band_steering, is_container='container', yang_name="band-steering", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """band_steering must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_band_steering_openconfig_access_points__access_points_access_point_ssids_ssid_band_steering, is_container='container', yang_name="band-steering", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)""",
        })

    self.__band_steering = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_band_steering(self):
    self.__band_steering = YANGDynClass(base=yc_band_steering_openconfig_access_points__access_points_access_point_ssids_ssid_band_steering, is_container='container', yang_name="band-steering", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)

  name = __builtin__.property(_get_name, _set_name)
  config = __builtin__.property(_get_config, _set_config)
  state = __builtin__.property(_get_state, _set_state)
  bssids = __builtin__.property(_get_bssids, _set_bssids)
  wmm = __builtin__.property(_get_wmm, _set_wmm)
  dot11r = __builtin__.property(_get_dot11r, _set_dot11r)
  dot11v = __builtin__.property(_get_dot11v, _set_dot11v)
  clients = __builtin__.property(_get_clients, _set_clients)
  dot1x_timers = __builtin__.property(_get_dot1x_timers, _set_dot1x_timers)
  band_steering = __builtin__.property(_get_band_steering, _set_band_steering)


  _pyangbind_elements = OrderedDict([('name', name), ('config', config), ('state', state), ('bssids', bssids), ('wmm', wmm), ('dot11r', dot11r), ('dot11v', dot11v), ('clients', clients), ('dot1x_timers', dot1x_timers), ('band_steering', band_steering), ])


class yc_ssids_openconfig_access_points__access_points_access_point_ssids(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-access-points - based on the path /access-points/access-point/ssids. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Top level container for ssids, including configuration
and state data.
  """
  __slots__ = ('_path_helper', '_extmethods', '__ssid',)

  _yang_name = 'ssids'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__ssid = YANGDynClass(base=YANGListType("name",yc_ssid_openconfig_access_points__access_points_access_point_ssids_ssid, yang_name="ssid", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="ssid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'access-points', u'access-point', u'ssids']

  def _get_ssid(self):
    """
    Getter method for ssid, mapped from YANG variable /access_points/access_point/ssids/ssid (list)

    YANG Description: The list of named ssids on the APs.
    """
    return self.__ssid
      
  def _set_ssid(self, v, load=False):
    """
    Setter method for ssid, mapped from YANG variable /access_points/access_point/ssids/ssid (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ssid is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ssid() directly.

    YANG Description: The list of named ssids on the APs.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("name",yc_ssid_openconfig_access_points__access_points_access_point_ssids_ssid, yang_name="ssid", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="ssid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ssid must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("name",yc_ssid_openconfig_access_points__access_points_access_point_ssids_ssid, yang_name="ssid", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="ssid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='list', is_config=True)""",
        })

    self.__ssid = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ssid(self):
    self.__ssid = YANGDynClass(base=YANGListType("name",yc_ssid_openconfig_access_points__access_points_access_point_ssids_ssid, yang_name="ssid", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="ssid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='list', is_config=True)

  ssid = __builtin__.property(_get_ssid, _set_ssid)


  _pyangbind_elements = OrderedDict([('ssid', ssid), ])


class yc_config_openconfig_access_points__access_points_access_point_system_config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-access-points - based on the path /access-points/access-point/system/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Global configuration data for the system
  """
  __slots__ = ('_path_helper', '_extmethods', '__hostname','__domain_name','__login_banner','__motd_banner',)

  _yang_name = 'config'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__login_banner = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="login-banner", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='string', is_config=True)
    self.__hostname = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'((([a-zA-Z0-9_]([a-zA-Z0-9\\-_]){0,61})?[a-zA-Z0-9]\\.)*([a-zA-Z0-9_]([a-zA-Z0-9\\-_]){0,61})?[a-zA-Z0-9]\\.?)|\\.', u'length': [u'1..253']}), is_leaf=True, yang_name="hostname", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-inet:domain-name', is_config=True)
    self.__domain_name = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'((([a-zA-Z0-9_]([a-zA-Z0-9\\-_]){0,61})?[a-zA-Z0-9]\\.)*([a-zA-Z0-9_]([a-zA-Z0-9\\-_]){0,61})?[a-zA-Z0-9]\\.?)|\\.', u'length': [u'1..253']}), is_leaf=True, yang_name="domain-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-inet:domain-name', is_config=True)
    self.__motd_banner = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="motd-banner", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'access-points', u'access-point', u'system', u'config']

  def _get_hostname(self):
    """
    Getter method for hostname, mapped from YANG variable /access_points/access_point/system/config/hostname (oc-inet:domain-name)

    YANG Description: The hostname of the device -- should be a single domain
label, without the domain.
    """
    return self.__hostname
      
  def _set_hostname(self, v, load=False):
    """
    Setter method for hostname, mapped from YANG variable /access_points/access_point/system/config/hostname (oc-inet:domain-name)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_hostname is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_hostname() directly.

    YANG Description: The hostname of the device -- should be a single domain
label, without the domain.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'((([a-zA-Z0-9_]([a-zA-Z0-9\\-_]){0,61})?[a-zA-Z0-9]\\.)*([a-zA-Z0-9_]([a-zA-Z0-9\\-_]){0,61})?[a-zA-Z0-9]\\.?)|\\.', u'length': [u'1..253']}), is_leaf=True, yang_name="hostname", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-inet:domain-name', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """hostname must be of a type compatible with oc-inet:domain-name""",
          'defined-type': "oc-inet:domain-name",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'((([a-zA-Z0-9_]([a-zA-Z0-9\\-_]){0,61})?[a-zA-Z0-9]\\.)*([a-zA-Z0-9_]([a-zA-Z0-9\\-_]){0,61})?[a-zA-Z0-9]\\.?)|\\.', u'length': [u'1..253']}), is_leaf=True, yang_name="hostname", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-inet:domain-name', is_config=True)""",
        })

    self.__hostname = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_hostname(self):
    self.__hostname = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'((([a-zA-Z0-9_]([a-zA-Z0-9\\-_]){0,61})?[a-zA-Z0-9]\\.)*([a-zA-Z0-9_]([a-zA-Z0-9\\-_]){0,61})?[a-zA-Z0-9]\\.?)|\\.', u'length': [u'1..253']}), is_leaf=True, yang_name="hostname", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-inet:domain-name', is_config=True)


  def _get_domain_name(self):
    """
    Getter method for domain_name, mapped from YANG variable /access_points/access_point/system/config/domain_name (oc-inet:domain-name)

    YANG Description: Specifies the domain name used to form fully qualified name
for unqualified hostnames.
    """
    return self.__domain_name
      
  def _set_domain_name(self, v, load=False):
    """
    Setter method for domain_name, mapped from YANG variable /access_points/access_point/system/config/domain_name (oc-inet:domain-name)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_domain_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_domain_name() directly.

    YANG Description: Specifies the domain name used to form fully qualified name
for unqualified hostnames.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'((([a-zA-Z0-9_]([a-zA-Z0-9\\-_]){0,61})?[a-zA-Z0-9]\\.)*([a-zA-Z0-9_]([a-zA-Z0-9\\-_]){0,61})?[a-zA-Z0-9]\\.?)|\\.', u'length': [u'1..253']}), is_leaf=True, yang_name="domain-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-inet:domain-name', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """domain_name must be of a type compatible with oc-inet:domain-name""",
          'defined-type': "oc-inet:domain-name",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'((([a-zA-Z0-9_]([a-zA-Z0-9\\-_]){0,61})?[a-zA-Z0-9]\\.)*([a-zA-Z0-9_]([a-zA-Z0-9\\-_]){0,61})?[a-zA-Z0-9]\\.?)|\\.', u'length': [u'1..253']}), is_leaf=True, yang_name="domain-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-inet:domain-name', is_config=True)""",
        })

    self.__domain_name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_domain_name(self):
    self.__domain_name = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'((([a-zA-Z0-9_]([a-zA-Z0-9\\-_]){0,61})?[a-zA-Z0-9]\\.)*([a-zA-Z0-9_]([a-zA-Z0-9\\-_]){0,61})?[a-zA-Z0-9]\\.?)|\\.', u'length': [u'1..253']}), is_leaf=True, yang_name="domain-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-inet:domain-name', is_config=True)


  def _get_login_banner(self):
    """
    Getter method for login_banner, mapped from YANG variable /access_points/access_point/system/config/login_banner (string)

    YANG Description: The console login message displayed before the login prompt,
i.e., before a user logs into the system.
    """
    return self.__login_banner
      
  def _set_login_banner(self, v, load=False):
    """
    Setter method for login_banner, mapped from YANG variable /access_points/access_point/system/config/login_banner (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_login_banner is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_login_banner() directly.

    YANG Description: The console login message displayed before the login prompt,
i.e., before a user logs into the system.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="login-banner", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """login_banner must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="login-banner", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='string', is_config=True)""",
        })

    self.__login_banner = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_login_banner(self):
    self.__login_banner = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="login-banner", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='string', is_config=True)


  def _get_motd_banner(self):
    """
    Getter method for motd_banner, mapped from YANG variable /access_points/access_point/system/config/motd_banner (string)

    YANG Description: The console message displayed after a user logs into the
system.  They system may append additional standard
information such as the current system date and time, uptime,
last login timestamp, etc.
    """
    return self.__motd_banner
      
  def _set_motd_banner(self, v, load=False):
    """
    Setter method for motd_banner, mapped from YANG variable /access_points/access_point/system/config/motd_banner (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_motd_banner is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_motd_banner() directly.

    YANG Description: The console message displayed after a user logs into the
system.  They system may append additional standard
information such as the current system date and time, uptime,
last login timestamp, etc.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="motd-banner", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """motd_banner must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="motd-banner", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='string', is_config=True)""",
        })

    self.__motd_banner = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_motd_banner(self):
    self.__motd_banner = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="motd-banner", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='string', is_config=True)

  hostname = __builtin__.property(_get_hostname, _set_hostname)
  domain_name = __builtin__.property(_get_domain_name, _set_domain_name)
  login_banner = __builtin__.property(_get_login_banner, _set_login_banner)
  motd_banner = __builtin__.property(_get_motd_banner, _set_motd_banner)


  _pyangbind_elements = OrderedDict([('hostname', hostname), ('domain_name', domain_name), ('login_banner', login_banner), ('motd_banner', motd_banner), ])


class yc_state_openconfig_access_points__access_points_access_point_system_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-access-points - based on the path /access-points/access-point/system/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Global operational state data for the system
  """
  __slots__ = ('_path_helper', '_extmethods', '__hostname','__domain_name','__login_banner','__motd_banner','__current_datetime','__boot_time',)

  _yang_name = 'state'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__hostname = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'((([a-zA-Z0-9_]([a-zA-Z0-9\\-_]){0,61})?[a-zA-Z0-9]\\.)*([a-zA-Z0-9_]([a-zA-Z0-9\\-_]){0,61})?[a-zA-Z0-9]\\.?)|\\.', u'length': [u'1..253']}), is_leaf=True, yang_name="hostname", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-inet:domain-name', is_config=False)
    self.__domain_name = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'((([a-zA-Z0-9_]([a-zA-Z0-9\\-_]){0,61})?[a-zA-Z0-9]\\.)*([a-zA-Z0-9_]([a-zA-Z0-9\\-_]){0,61})?[a-zA-Z0-9]\\.?)|\\.', u'length': [u'1..253']}), is_leaf=True, yang_name="domain-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-inet:domain-name', is_config=False)
    self.__login_banner = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="login-banner", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='string', is_config=False)
    self.__boot_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="boot-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:timeticks64', is_config=False)
    self.__motd_banner = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="motd-banner", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='string', is_config=False)
    self.__current_datetime = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^[0-9]{4}\\-[0-9]{2}\\-[0-9]{2}T[0-9]{2}:[0-9]{2}:[0-9]{2}(\\.[0-9]+)?Z[+-][0-9]{2}:[0-9]{2}$'}), is_leaf=True, yang_name="current-datetime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:date-and-time', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'access-points', u'access-point', u'system', u'state']

  def _get_hostname(self):
    """
    Getter method for hostname, mapped from YANG variable /access_points/access_point/system/state/hostname (oc-inet:domain-name)

    YANG Description: The hostname of the device -- should be a single domain
label, without the domain.
    """
    return self.__hostname
      
  def _set_hostname(self, v, load=False):
    """
    Setter method for hostname, mapped from YANG variable /access_points/access_point/system/state/hostname (oc-inet:domain-name)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_hostname is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_hostname() directly.

    YANG Description: The hostname of the device -- should be a single domain
label, without the domain.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'((([a-zA-Z0-9_]([a-zA-Z0-9\\-_]){0,61})?[a-zA-Z0-9]\\.)*([a-zA-Z0-9_]([a-zA-Z0-9\\-_]){0,61})?[a-zA-Z0-9]\\.?)|\\.', u'length': [u'1..253']}), is_leaf=True, yang_name="hostname", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-inet:domain-name', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """hostname must be of a type compatible with oc-inet:domain-name""",
          'defined-type': "oc-inet:domain-name",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'((([a-zA-Z0-9_]([a-zA-Z0-9\\-_]){0,61})?[a-zA-Z0-9]\\.)*([a-zA-Z0-9_]([a-zA-Z0-9\\-_]){0,61})?[a-zA-Z0-9]\\.?)|\\.', u'length': [u'1..253']}), is_leaf=True, yang_name="hostname", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-inet:domain-name', is_config=False)""",
        })

    self.__hostname = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_hostname(self):
    self.__hostname = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'((([a-zA-Z0-9_]([a-zA-Z0-9\\-_]){0,61})?[a-zA-Z0-9]\\.)*([a-zA-Z0-9_]([a-zA-Z0-9\\-_]){0,61})?[a-zA-Z0-9]\\.?)|\\.', u'length': [u'1..253']}), is_leaf=True, yang_name="hostname", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-inet:domain-name', is_config=False)


  def _get_domain_name(self):
    """
    Getter method for domain_name, mapped from YANG variable /access_points/access_point/system/state/domain_name (oc-inet:domain-name)

    YANG Description: Specifies the domain name used to form fully qualified name
for unqualified hostnames.
    """
    return self.__domain_name
      
  def _set_domain_name(self, v, load=False):
    """
    Setter method for domain_name, mapped from YANG variable /access_points/access_point/system/state/domain_name (oc-inet:domain-name)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_domain_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_domain_name() directly.

    YANG Description: Specifies the domain name used to form fully qualified name
for unqualified hostnames.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'((([a-zA-Z0-9_]([a-zA-Z0-9\\-_]){0,61})?[a-zA-Z0-9]\\.)*([a-zA-Z0-9_]([a-zA-Z0-9\\-_]){0,61})?[a-zA-Z0-9]\\.?)|\\.', u'length': [u'1..253']}), is_leaf=True, yang_name="domain-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-inet:domain-name', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """domain_name must be of a type compatible with oc-inet:domain-name""",
          'defined-type': "oc-inet:domain-name",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'((([a-zA-Z0-9_]([a-zA-Z0-9\\-_]){0,61})?[a-zA-Z0-9]\\.)*([a-zA-Z0-9_]([a-zA-Z0-9\\-_]){0,61})?[a-zA-Z0-9]\\.?)|\\.', u'length': [u'1..253']}), is_leaf=True, yang_name="domain-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-inet:domain-name', is_config=False)""",
        })

    self.__domain_name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_domain_name(self):
    self.__domain_name = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'((([a-zA-Z0-9_]([a-zA-Z0-9\\-_]){0,61})?[a-zA-Z0-9]\\.)*([a-zA-Z0-9_]([a-zA-Z0-9\\-_]){0,61})?[a-zA-Z0-9]\\.?)|\\.', u'length': [u'1..253']}), is_leaf=True, yang_name="domain-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-inet:domain-name', is_config=False)


  def _get_login_banner(self):
    """
    Getter method for login_banner, mapped from YANG variable /access_points/access_point/system/state/login_banner (string)

    YANG Description: The console login message displayed before the login prompt,
i.e., before a user logs into the system.
    """
    return self.__login_banner
      
  def _set_login_banner(self, v, load=False):
    """
    Setter method for login_banner, mapped from YANG variable /access_points/access_point/system/state/login_banner (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_login_banner is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_login_banner() directly.

    YANG Description: The console login message displayed before the login prompt,
i.e., before a user logs into the system.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="login-banner", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """login_banner must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="login-banner", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='string', is_config=False)""",
        })

    self.__login_banner = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_login_banner(self):
    self.__login_banner = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="login-banner", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='string', is_config=False)


  def _get_motd_banner(self):
    """
    Getter method for motd_banner, mapped from YANG variable /access_points/access_point/system/state/motd_banner (string)

    YANG Description: The console message displayed after a user logs into the
system.  They system may append additional standard
information such as the current system date and time, uptime,
last login timestamp, etc.
    """
    return self.__motd_banner
      
  def _set_motd_banner(self, v, load=False):
    """
    Setter method for motd_banner, mapped from YANG variable /access_points/access_point/system/state/motd_banner (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_motd_banner is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_motd_banner() directly.

    YANG Description: The console message displayed after a user logs into the
system.  They system may append additional standard
information such as the current system date and time, uptime,
last login timestamp, etc.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="motd-banner", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """motd_banner must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="motd-banner", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='string', is_config=False)""",
        })

    self.__motd_banner = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_motd_banner(self):
    self.__motd_banner = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="motd-banner", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='string', is_config=False)


  def _get_current_datetime(self):
    """
    Getter method for current_datetime, mapped from YANG variable /access_points/access_point/system/state/current_datetime (oc-yang:date-and-time)

    YANG Description: The current system date and time.
    """
    return self.__current_datetime
      
  def _set_current_datetime(self, v, load=False):
    """
    Setter method for current_datetime, mapped from YANG variable /access_points/access_point/system/state/current_datetime (oc-yang:date-and-time)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_current_datetime is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_current_datetime() directly.

    YANG Description: The current system date and time.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^[0-9]{4}\\-[0-9]{2}\\-[0-9]{2}T[0-9]{2}:[0-9]{2}:[0-9]{2}(\\.[0-9]+)?Z[+-][0-9]{2}:[0-9]{2}$'}), is_leaf=True, yang_name="current-datetime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:date-and-time', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """current_datetime must be of a type compatible with oc-yang:date-and-time""",
          'defined-type': "oc-yang:date-and-time",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^[0-9]{4}\\-[0-9]{2}\\-[0-9]{2}T[0-9]{2}:[0-9]{2}:[0-9]{2}(\\.[0-9]+)?Z[+-][0-9]{2}:[0-9]{2}$'}), is_leaf=True, yang_name="current-datetime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:date-and-time', is_config=False)""",
        })

    self.__current_datetime = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_current_datetime(self):
    self.__current_datetime = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^[0-9]{4}\\-[0-9]{2}\\-[0-9]{2}T[0-9]{2}:[0-9]{2}:[0-9]{2}(\\.[0-9]+)?Z[+-][0-9]{2}:[0-9]{2}$'}), is_leaf=True, yang_name="current-datetime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:date-and-time', is_config=False)


  def _get_boot_time(self):
    """
    Getter method for boot_time, mapped from YANG variable /access_points/access_point/system/state/boot_time (oc-types:timeticks64)

    YANG Description: This timestamp indicates the time that the system was last
restarted.  The value is the timestamp in seconds relative
to the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    return self.__boot_time
      
  def _set_boot_time(self, v, load=False):
    """
    Setter method for boot_time, mapped from YANG variable /access_points/access_point/system/state/boot_time (oc-types:timeticks64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_boot_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_boot_time() directly.

    YANG Description: This timestamp indicates the time that the system was last
restarted.  The value is the timestamp in seconds relative
to the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="boot-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:timeticks64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """boot_time must be of a type compatible with oc-types:timeticks64""",
          'defined-type': "oc-types:timeticks64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="boot-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:timeticks64', is_config=False)""",
        })

    self.__boot_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_boot_time(self):
    self.__boot_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="boot-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:timeticks64', is_config=False)

  hostname = __builtin__.property(_get_hostname)
  domain_name = __builtin__.property(_get_domain_name)
  login_banner = __builtin__.property(_get_login_banner)
  motd_banner = __builtin__.property(_get_motd_banner)
  current_datetime = __builtin__.property(_get_current_datetime)
  boot_time = __builtin__.property(_get_boot_time)


  _pyangbind_elements = OrderedDict([('hostname', hostname), ('domain_name', domain_name), ('login_banner', login_banner), ('motd_banner', motd_banner), ('current_datetime', current_datetime), ('boot_time', boot_time), ])


class yc_config_openconfig_access_points__access_points_access_point_system_clock_config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-access-points - based on the path /access-points/access-point/system/clock/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration data for system clock
  """
  __slots__ = ('_path_helper', '_extmethods', '__timezone_name',)

  _yang_name = 'config'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__timezone_name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="timezone-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='timezone-name-type', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'access-points', u'access-point', u'system', u'clock', u'config']

  def _get_timezone_name(self):
    """
    Getter method for timezone_name, mapped from YANG variable /access_points/access_point/system/clock/config/timezone_name (timezone-name-type)

    YANG Description: The TZ database name to use for the system, such
as 'Europe/Stockholm'.
    """
    return self.__timezone_name
      
  def _set_timezone_name(self, v, load=False):
    """
    Setter method for timezone_name, mapped from YANG variable /access_points/access_point/system/clock/config/timezone_name (timezone-name-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_timezone_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_timezone_name() directly.

    YANG Description: The TZ database name to use for the system, such
as 'Europe/Stockholm'.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="timezone-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='timezone-name-type', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """timezone_name must be of a type compatible with timezone-name-type""",
          'defined-type': "openconfig-access-points:timezone-name-type",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="timezone-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='timezone-name-type', is_config=True)""",
        })

    self.__timezone_name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_timezone_name(self):
    self.__timezone_name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="timezone-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='timezone-name-type', is_config=True)

  timezone_name = __builtin__.property(_get_timezone_name, _set_timezone_name)


  _pyangbind_elements = OrderedDict([('timezone_name', timezone_name), ])


class yc_state_openconfig_access_points__access_points_access_point_system_clock_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-access-points - based on the path /access-points/access-point/system/clock/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Operational state data for system clock
  """
  __slots__ = ('_path_helper', '_extmethods', '__timezone_name',)

  _yang_name = 'state'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__timezone_name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="timezone-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='timezone-name-type', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'access-points', u'access-point', u'system', u'clock', u'state']

  def _get_timezone_name(self):
    """
    Getter method for timezone_name, mapped from YANG variable /access_points/access_point/system/clock/state/timezone_name (timezone-name-type)

    YANG Description: The TZ database name to use for the system, such
as 'Europe/Stockholm'.
    """
    return self.__timezone_name
      
  def _set_timezone_name(self, v, load=False):
    """
    Setter method for timezone_name, mapped from YANG variable /access_points/access_point/system/clock/state/timezone_name (timezone-name-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_timezone_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_timezone_name() directly.

    YANG Description: The TZ database name to use for the system, such
as 'Europe/Stockholm'.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="timezone-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='timezone-name-type', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """timezone_name must be of a type compatible with timezone-name-type""",
          'defined-type': "openconfig-access-points:timezone-name-type",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="timezone-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='timezone-name-type', is_config=False)""",
        })

    self.__timezone_name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_timezone_name(self):
    self.__timezone_name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="timezone-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='timezone-name-type', is_config=False)

  timezone_name = __builtin__.property(_get_timezone_name)


  _pyangbind_elements = OrderedDict([('timezone_name', timezone_name), ])


class yc_clock_openconfig_access_points__access_points_access_point_system_clock(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-access-points - based on the path /access-points/access-point/system/clock. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Top-level container for clock configuration data
  """
  __slots__ = ('_path_helper', '_extmethods', '__config','__state',)

  _yang_name = 'clock'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__state = YANGDynClass(base=yc_state_openconfig_access_points__access_points_access_point_system_clock_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)
    self.__config = YANGDynClass(base=yc_config_openconfig_access_points__access_points_access_point_system_clock_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'access-points', u'access-point', u'system', u'clock']

  def _get_config(self):
    """
    Getter method for config, mapped from YANG variable /access_points/access_point/system/clock/config (container)

    YANG Description: Configuration data for system clock
    """
    return self.__config
      
  def _set_config(self, v, load=False):
    """
    Setter method for config, mapped from YANG variable /access_points/access_point/system/clock/config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config() directly.

    YANG Description: Configuration data for system clock
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_config_openconfig_access_points__access_points_access_point_system_clock_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_config_openconfig_access_points__access_points_access_point_system_clock_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)""",
        })

    self.__config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config(self):
    self.__config = YANGDynClass(base=yc_config_openconfig_access_points__access_points_access_point_system_clock_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /access_points/access_point/system/clock/state (container)

    YANG Description: Operational state data for system clock
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /access_points/access_point/system/clock/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: Operational state data for system clock
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_access_points__access_points_access_point_system_clock_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_access_points__access_points_access_point_system_clock_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_access_points__access_points_access_point_system_clock_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)

  config = __builtin__.property(_get_config, _set_config)
  state = __builtin__.property(_get_state, _set_state)


  _pyangbind_elements = OrderedDict([('config', config), ('state', state), ])


class yc_config_openconfig_access_points__access_points_access_point_system_dns_config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-access-points - based on the path /access-points/access-point/system/dns/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration data for the DNS resolver
  """
  __slots__ = ('_path_helper', '_extmethods', '__search',)

  _yang_name = 'config'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__search = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'((([a-zA-Z0-9_]([a-zA-Z0-9\\-_]){0,61})?[a-zA-Z0-9]\\.)*([a-zA-Z0-9_]([a-zA-Z0-9\\-_]){0,61})?[a-zA-Z0-9]\\.?)|\\.', u'length': [u'1..253']})), is_leaf=False, yang_name="search", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-inet:domain-name', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'access-points', u'access-point', u'system', u'dns', u'config']

  def _get_search(self):
    """
    Getter method for search, mapped from YANG variable /access_points/access_point/system/dns/config/search (oc-inet:domain-name)

    YANG Description: An ordered list of domains to search when resolving
a host name.
    """
    return self.__search
      
  def _set_search(self, v, load=False):
    """
    Setter method for search, mapped from YANG variable /access_points/access_point/system/dns/config/search (oc-inet:domain-name)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_search is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_search() directly.

    YANG Description: An ordered list of domains to search when resolving
a host name.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'((([a-zA-Z0-9_]([a-zA-Z0-9\\-_]){0,61})?[a-zA-Z0-9]\\.)*([a-zA-Z0-9_]([a-zA-Z0-9\\-_]){0,61})?[a-zA-Z0-9]\\.?)|\\.', u'length': [u'1..253']})), is_leaf=False, yang_name="search", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-inet:domain-name', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """search must be of a type compatible with oc-inet:domain-name""",
          'defined-type': "oc-inet:domain-name",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'((([a-zA-Z0-9_]([a-zA-Z0-9\\-_]){0,61})?[a-zA-Z0-9]\\.)*([a-zA-Z0-9_]([a-zA-Z0-9\\-_]){0,61})?[a-zA-Z0-9]\\.?)|\\.', u'length': [u'1..253']})), is_leaf=False, yang_name="search", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-inet:domain-name', is_config=True)""",
        })

    self.__search = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_search(self):
    self.__search = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'((([a-zA-Z0-9_]([a-zA-Z0-9\\-_]){0,61})?[a-zA-Z0-9]\\.)*([a-zA-Z0-9_]([a-zA-Z0-9\\-_]){0,61})?[a-zA-Z0-9]\\.?)|\\.', u'length': [u'1..253']})), is_leaf=False, yang_name="search", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-inet:domain-name', is_config=True)

  search = __builtin__.property(_get_search, _set_search)


  _pyangbind_elements = OrderedDict([('search', search), ])


class yc_state_openconfig_access_points__access_points_access_point_system_dns_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-access-points - based on the path /access-points/access-point/system/dns/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Operational state data for the DNS resolver
  """
  __slots__ = ('_path_helper', '_extmethods', '__search',)

  _yang_name = 'state'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__search = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'((([a-zA-Z0-9_]([a-zA-Z0-9\\-_]){0,61})?[a-zA-Z0-9]\\.)*([a-zA-Z0-9_]([a-zA-Z0-9\\-_]){0,61})?[a-zA-Z0-9]\\.?)|\\.', u'length': [u'1..253']})), is_leaf=False, yang_name="search", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-inet:domain-name', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'access-points', u'access-point', u'system', u'dns', u'state']

  def _get_search(self):
    """
    Getter method for search, mapped from YANG variable /access_points/access_point/system/dns/state/search (oc-inet:domain-name)

    YANG Description: An ordered list of domains to search when resolving
a host name.
    """
    return self.__search
      
  def _set_search(self, v, load=False):
    """
    Setter method for search, mapped from YANG variable /access_points/access_point/system/dns/state/search (oc-inet:domain-name)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_search is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_search() directly.

    YANG Description: An ordered list of domains to search when resolving
a host name.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'((([a-zA-Z0-9_]([a-zA-Z0-9\\-_]){0,61})?[a-zA-Z0-9]\\.)*([a-zA-Z0-9_]([a-zA-Z0-9\\-_]){0,61})?[a-zA-Z0-9]\\.?)|\\.', u'length': [u'1..253']})), is_leaf=False, yang_name="search", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-inet:domain-name', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """search must be of a type compatible with oc-inet:domain-name""",
          'defined-type': "oc-inet:domain-name",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'((([a-zA-Z0-9_]([a-zA-Z0-9\\-_]){0,61})?[a-zA-Z0-9]\\.)*([a-zA-Z0-9_]([a-zA-Z0-9\\-_]){0,61})?[a-zA-Z0-9]\\.?)|\\.', u'length': [u'1..253']})), is_leaf=False, yang_name="search", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-inet:domain-name', is_config=False)""",
        })

    self.__search = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_search(self):
    self.__search = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'((([a-zA-Z0-9_]([a-zA-Z0-9\\-_]){0,61})?[a-zA-Z0-9]\\.)*([a-zA-Z0-9_]([a-zA-Z0-9\\-_]){0,61})?[a-zA-Z0-9]\\.?)|\\.', u'length': [u'1..253']})), is_leaf=False, yang_name="search", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-inet:domain-name', is_config=False)

  search = __builtin__.property(_get_search)


  _pyangbind_elements = OrderedDict([('search', search), ])


class yc_config_openconfig_access_points__access_points_access_point_system_dns_servers_server_config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-access-points - based on the path /access-points/access-point/system/dns/servers/server/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration data for each DNS resolver
  """
  __slots__ = ('_path_helper', '_extmethods', '__address','__port',)

  _yang_name = 'config'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__port = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(53), is_leaf=True, yang_name="port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-inet:port-number', is_config=True)
    self.__address = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])$'}),RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))$'}),], is_leaf=True, yang_name="address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-inet:ip-address', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'access-points', u'access-point', u'system', u'dns', u'servers', u'server', u'config']

  def _get_address(self):
    """
    Getter method for address, mapped from YANG variable /access_points/access_point/system/dns/servers/server/config/address (oc-inet:ip-address)

    YANG Description: The address of the DNS server, can be either IPv4
or IPv6.
    """
    return self.__address
      
  def _set_address(self, v, load=False):
    """
    Setter method for address, mapped from YANG variable /access_points/access_point/system/dns/servers/server/config/address (oc-inet:ip-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_address() directly.

    YANG Description: The address of the DNS server, can be either IPv4
or IPv6.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=[RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])$'}),RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))$'}),], is_leaf=True, yang_name="address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-inet:ip-address', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """address must be of a type compatible with oc-inet:ip-address""",
          'defined-type': "oc-inet:ip-address",
          'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])$'}),RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))$'}),], is_leaf=True, yang_name="address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-inet:ip-address', is_config=True)""",
        })

    self.__address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_address(self):
    self.__address = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])$'}),RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))$'}),], is_leaf=True, yang_name="address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-inet:ip-address', is_config=True)


  def _get_port(self):
    """
    Getter method for port, mapped from YANG variable /access_points/access_point/system/dns/servers/server/config/port (oc-inet:port-number)

    YANG Description: The port number of the DNS server.
    """
    return self.__port
      
  def _set_port(self, v, load=False):
    """
    Setter method for port, mapped from YANG variable /access_points/access_point/system/dns/servers/server/config/port (oc-inet:port-number)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_port is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_port() directly.

    YANG Description: The port number of the DNS server.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(53), is_leaf=True, yang_name="port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-inet:port-number', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """port must be of a type compatible with oc-inet:port-number""",
          'defined-type': "oc-inet:port-number",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(53), is_leaf=True, yang_name="port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-inet:port-number', is_config=True)""",
        })

    self.__port = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_port(self):
    self.__port = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(53), is_leaf=True, yang_name="port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-inet:port-number', is_config=True)

  address = __builtin__.property(_get_address, _set_address)
  port = __builtin__.property(_get_port, _set_port)


  _pyangbind_elements = OrderedDict([('address', address), ('port', port), ])


class yc_state_openconfig_access_points__access_points_access_point_system_dns_servers_server_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-access-points - based on the path /access-points/access-point/system/dns/servers/server/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Operational state data for each DNS resolver
  """
  __slots__ = ('_path_helper', '_extmethods', '__address','__port',)

  _yang_name = 'state'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__port = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(53), is_leaf=True, yang_name="port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-inet:port-number', is_config=False)
    self.__address = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])$'}),RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))$'}),], is_leaf=True, yang_name="address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-inet:ip-address', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'access-points', u'access-point', u'system', u'dns', u'servers', u'server', u'state']

  def _get_address(self):
    """
    Getter method for address, mapped from YANG variable /access_points/access_point/system/dns/servers/server/state/address (oc-inet:ip-address)

    YANG Description: The address of the DNS server, can be either IPv4
or IPv6.
    """
    return self.__address
      
  def _set_address(self, v, load=False):
    """
    Setter method for address, mapped from YANG variable /access_points/access_point/system/dns/servers/server/state/address (oc-inet:ip-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_address() directly.

    YANG Description: The address of the DNS server, can be either IPv4
or IPv6.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=[RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])$'}),RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))$'}),], is_leaf=True, yang_name="address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-inet:ip-address', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """address must be of a type compatible with oc-inet:ip-address""",
          'defined-type': "oc-inet:ip-address",
          'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])$'}),RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))$'}),], is_leaf=True, yang_name="address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-inet:ip-address', is_config=False)""",
        })

    self.__address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_address(self):
    self.__address = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])$'}),RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))$'}),], is_leaf=True, yang_name="address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-inet:ip-address', is_config=False)


  def _get_port(self):
    """
    Getter method for port, mapped from YANG variable /access_points/access_point/system/dns/servers/server/state/port (oc-inet:port-number)

    YANG Description: The port number of the DNS server.
    """
    return self.__port
      
  def _set_port(self, v, load=False):
    """
    Setter method for port, mapped from YANG variable /access_points/access_point/system/dns/servers/server/state/port (oc-inet:port-number)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_port is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_port() directly.

    YANG Description: The port number of the DNS server.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(53), is_leaf=True, yang_name="port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-inet:port-number', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """port must be of a type compatible with oc-inet:port-number""",
          'defined-type': "oc-inet:port-number",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(53), is_leaf=True, yang_name="port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-inet:port-number', is_config=False)""",
        })

    self.__port = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_port(self):
    self.__port = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(53), is_leaf=True, yang_name="port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-inet:port-number', is_config=False)

  address = __builtin__.property(_get_address)
  port = __builtin__.property(_get_port)


  _pyangbind_elements = OrderedDict([('address', address), ('port', port), ])


class yc_server_openconfig_access_points__access_points_access_point_system_dns_servers_server(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-access-points - based on the path /access-points/access-point/system/dns/servers/server. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of the DNS servers that the resolver should query.

When the resolver is invoked by a calling application, it
sends the query to the first name server in this list.  If
no response has been received within 'timeout' seconds,
the resolver continues with the next server in the list.
If no response is received from any server, the resolver
continues with the first server again.  When the resolver
has traversed the list 'attempts' times without receiving
any response, it gives up and returns an error to the
calling application.

Implementations MAY limit the number of entries in this
list.
  """
  __slots__ = ('_path_helper', '_extmethods', '__address','__config','__state',)

  _yang_name = 'server'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__state = YANGDynClass(base=yc_state_openconfig_access_points__access_points_access_point_system_dns_servers_server_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)
    self.__config = YANGDynClass(base=yc_config_openconfig_access_points__access_points_access_point_system_dns_servers_server_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)
    self.__address = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='leafref', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'access-points', u'access-point', u'system', u'dns', u'servers', u'server']

  def _get_address(self):
    """
    Getter method for address, mapped from YANG variable /access_points/access_point/system/dns/servers/server/address (leafref)

    YANG Description: References the configured address of the DNS server
    """
    return self.__address
      
  def _set_address(self, v, load=False):
    """
    Setter method for address, mapped from YANG variable /access_points/access_point/system/dns/servers/server/address (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_address() directly.

    YANG Description: References the configured address of the DNS server
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """address must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='leafref', is_config=True)""",
        })

    self.__address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_address(self):
    self.__address = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='leafref', is_config=True)


  def _get_config(self):
    """
    Getter method for config, mapped from YANG variable /access_points/access_point/system/dns/servers/server/config (container)

    YANG Description: Configuration data for each DNS resolver
    """
    return self.__config
      
  def _set_config(self, v, load=False):
    """
    Setter method for config, mapped from YANG variable /access_points/access_point/system/dns/servers/server/config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config() directly.

    YANG Description: Configuration data for each DNS resolver
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_config_openconfig_access_points__access_points_access_point_system_dns_servers_server_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_config_openconfig_access_points__access_points_access_point_system_dns_servers_server_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)""",
        })

    self.__config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config(self):
    self.__config = YANGDynClass(base=yc_config_openconfig_access_points__access_points_access_point_system_dns_servers_server_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /access_points/access_point/system/dns/servers/server/state (container)

    YANG Description: Operational state data for each DNS resolver
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /access_points/access_point/system/dns/servers/server/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: Operational state data for each DNS resolver
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_access_points__access_points_access_point_system_dns_servers_server_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_access_points__access_points_access_point_system_dns_servers_server_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_access_points__access_points_access_point_system_dns_servers_server_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)

  address = __builtin__.property(_get_address, _set_address)
  config = __builtin__.property(_get_config, _set_config)
  state = __builtin__.property(_get_state, _set_state)


  _pyangbind_elements = OrderedDict([('address', address), ('config', config), ('state', state), ])


class yc_servers_openconfig_access_points__access_points_access_point_system_dns_servers(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-access-points - based on the path /access-points/access-point/system/dns/servers. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Enclosing container for DNS resolver list
  """
  __slots__ = ('_path_helper', '_extmethods', '__server',)

  _yang_name = 'servers'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__server = YANGDynClass(base=YANGListType("address",yc_server_openconfig_access_points__access_points_access_point_system_dns_servers_server, yang_name="server", parent=self, is_container='list', user_ordered=True, path_helper=self._path_helper, yang_keys='address', extensions=None), is_container='list', yang_name="server", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'access-points', u'access-point', u'system', u'dns', u'servers']

  def _get_server(self):
    """
    Getter method for server, mapped from YANG variable /access_points/access_point/system/dns/servers/server (list)

    YANG Description: List of the DNS servers that the resolver should query.

When the resolver is invoked by a calling application, it
sends the query to the first name server in this list.  If
no response has been received within 'timeout' seconds,
the resolver continues with the next server in the list.
If no response is received from any server, the resolver
continues with the first server again.  When the resolver
has traversed the list 'attempts' times without receiving
any response, it gives up and returns an error to the
calling application.

Implementations MAY limit the number of entries in this
list.
    """
    return self.__server
      
  def _set_server(self, v, load=False):
    """
    Setter method for server, mapped from YANG variable /access_points/access_point/system/dns/servers/server (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_server is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_server() directly.

    YANG Description: List of the DNS servers that the resolver should query.

When the resolver is invoked by a calling application, it
sends the query to the first name server in this list.  If
no response has been received within 'timeout' seconds,
the resolver continues with the next server in the list.
If no response is received from any server, the resolver
continues with the first server again.  When the resolver
has traversed the list 'attempts' times without receiving
any response, it gives up and returns an error to the
calling application.

Implementations MAY limit the number of entries in this
list.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("address",yc_server_openconfig_access_points__access_points_access_point_system_dns_servers_server, yang_name="server", parent=self, is_container='list', user_ordered=True, path_helper=self._path_helper, yang_keys='address', extensions=None), is_container='list', yang_name="server", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """server must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("address",yc_server_openconfig_access_points__access_points_access_point_system_dns_servers_server, yang_name="server", parent=self, is_container='list', user_ordered=True, path_helper=self._path_helper, yang_keys='address', extensions=None), is_container='list', yang_name="server", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='list', is_config=True)""",
        })

    self.__server = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_server(self):
    self.__server = YANGDynClass(base=YANGListType("address",yc_server_openconfig_access_points__access_points_access_point_system_dns_servers_server, yang_name="server", parent=self, is_container='list', user_ordered=True, path_helper=self._path_helper, yang_keys='address', extensions=None), is_container='list', yang_name="server", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='list', is_config=True)

  server = __builtin__.property(_get_server, _set_server)


  _pyangbind_elements = OrderedDict([('server', server), ])


class yc_config_openconfig_access_points__access_points_access_point_system_dns_host_entries_host_entry_config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-access-points - based on the path /access-points/access-point/system/dns/host-entries/host-entry/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration data for static host entries
  """
  __slots__ = ('_path_helper', '_extmethods', '__hostname','__alias','__ipv4_address','__ipv6_address',)

  _yang_name = 'config'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__ipv4_address = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])$'})), is_leaf=False, yang_name="ipv4-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-inet:ipv4-address', is_config=True)
    self.__alias = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="alias", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='string', is_config=True)
    self.__ipv6_address = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))$'})), is_leaf=False, yang_name="ipv6-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-inet:ipv6-address', is_config=True)
    self.__hostname = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="hostname", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'access-points', u'access-point', u'system', u'dns', u'host-entries', u'host-entry', u'config']

  def _get_hostname(self):
    """
    Getter method for hostname, mapped from YANG variable /access_points/access_point/system/dns/host_entries/host_entry/config/hostname (string)

    YANG Description: Hostname for the static DNS entry
    """
    return self.__hostname
      
  def _set_hostname(self, v, load=False):
    """
    Setter method for hostname, mapped from YANG variable /access_points/access_point/system/dns/host_entries/host_entry/config/hostname (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_hostname is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_hostname() directly.

    YANG Description: Hostname for the static DNS entry
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="hostname", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """hostname must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="hostname", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='string', is_config=True)""",
        })

    self.__hostname = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_hostname(self):
    self.__hostname = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="hostname", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='string', is_config=True)


  def _get_alias(self):
    """
    Getter method for alias, mapped from YANG variable /access_points/access_point/system/dns/host_entries/host_entry/config/alias (string)

    YANG Description: Additional aliases for the hostname
    """
    return self.__alias
      
  def _set_alias(self, v, load=False):
    """
    Setter method for alias, mapped from YANG variable /access_points/access_point/system/dns/host_entries/host_entry/config/alias (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_alias is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_alias() directly.

    YANG Description: Additional aliases for the hostname
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="alias", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """alias must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="alias", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='string', is_config=True)""",
        })

    self.__alias = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_alias(self):
    self.__alias = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="alias", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='string', is_config=True)


  def _get_ipv4_address(self):
    """
    Getter method for ipv4_address, mapped from YANG variable /access_points/access_point/system/dns/host_entries/host_entry/config/ipv4_address (oc-inet:ipv4-address)

    YANG Description: List of IPv4 addressses for the host entry
    """
    return self.__ipv4_address
      
  def _set_ipv4_address(self, v, load=False):
    """
    Setter method for ipv4_address, mapped from YANG variable /access_points/access_point/system/dns/host_entries/host_entry/config/ipv4_address (oc-inet:ipv4-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ipv4_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ipv4_address() directly.

    YANG Description: List of IPv4 addressses for the host entry
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])$'})), is_leaf=False, yang_name="ipv4-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-inet:ipv4-address', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ipv4_address must be of a type compatible with oc-inet:ipv4-address""",
          'defined-type': "oc-inet:ipv4-address",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])$'})), is_leaf=False, yang_name="ipv4-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-inet:ipv4-address', is_config=True)""",
        })

    self.__ipv4_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ipv4_address(self):
    self.__ipv4_address = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])$'})), is_leaf=False, yang_name="ipv4-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-inet:ipv4-address', is_config=True)


  def _get_ipv6_address(self):
    """
    Getter method for ipv6_address, mapped from YANG variable /access_points/access_point/system/dns/host_entries/host_entry/config/ipv6_address (oc-inet:ipv6-address)

    YANG Description: List of IPv6 addresses for the host entry
    """
    return self.__ipv6_address
      
  def _set_ipv6_address(self, v, load=False):
    """
    Setter method for ipv6_address, mapped from YANG variable /access_points/access_point/system/dns/host_entries/host_entry/config/ipv6_address (oc-inet:ipv6-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ipv6_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ipv6_address() directly.

    YANG Description: List of IPv6 addresses for the host entry
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))$'})), is_leaf=False, yang_name="ipv6-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-inet:ipv6-address', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ipv6_address must be of a type compatible with oc-inet:ipv6-address""",
          'defined-type': "oc-inet:ipv6-address",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))$'})), is_leaf=False, yang_name="ipv6-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-inet:ipv6-address', is_config=True)""",
        })

    self.__ipv6_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ipv6_address(self):
    self.__ipv6_address = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))$'})), is_leaf=False, yang_name="ipv6-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-inet:ipv6-address', is_config=True)

  hostname = __builtin__.property(_get_hostname, _set_hostname)
  alias = __builtin__.property(_get_alias, _set_alias)
  ipv4_address = __builtin__.property(_get_ipv4_address, _set_ipv4_address)
  ipv6_address = __builtin__.property(_get_ipv6_address, _set_ipv6_address)


  _pyangbind_elements = OrderedDict([('hostname', hostname), ('alias', alias), ('ipv4_address', ipv4_address), ('ipv6_address', ipv6_address), ])


class yc_state_openconfig_access_points__access_points_access_point_system_dns_host_entries_host_entry_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-access-points - based on the path /access-points/access-point/system/dns/host-entries/host-entry/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Operational state data for static host entries
  """
  __slots__ = ('_path_helper', '_extmethods', '__hostname','__alias','__ipv4_address','__ipv6_address',)

  _yang_name = 'state'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__ipv4_address = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])$'})), is_leaf=False, yang_name="ipv4-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-inet:ipv4-address', is_config=False)
    self.__alias = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="alias", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='string', is_config=False)
    self.__ipv6_address = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))$'})), is_leaf=False, yang_name="ipv6-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-inet:ipv6-address', is_config=False)
    self.__hostname = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="hostname", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='string', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'access-points', u'access-point', u'system', u'dns', u'host-entries', u'host-entry', u'state']

  def _get_hostname(self):
    """
    Getter method for hostname, mapped from YANG variable /access_points/access_point/system/dns/host_entries/host_entry/state/hostname (string)

    YANG Description: Hostname for the static DNS entry
    """
    return self.__hostname
      
  def _set_hostname(self, v, load=False):
    """
    Setter method for hostname, mapped from YANG variable /access_points/access_point/system/dns/host_entries/host_entry/state/hostname (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_hostname is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_hostname() directly.

    YANG Description: Hostname for the static DNS entry
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="hostname", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """hostname must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="hostname", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='string', is_config=False)""",
        })

    self.__hostname = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_hostname(self):
    self.__hostname = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="hostname", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='string', is_config=False)


  def _get_alias(self):
    """
    Getter method for alias, mapped from YANG variable /access_points/access_point/system/dns/host_entries/host_entry/state/alias (string)

    YANG Description: Additional aliases for the hostname
    """
    return self.__alias
      
  def _set_alias(self, v, load=False):
    """
    Setter method for alias, mapped from YANG variable /access_points/access_point/system/dns/host_entries/host_entry/state/alias (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_alias is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_alias() directly.

    YANG Description: Additional aliases for the hostname
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="alias", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """alias must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="alias", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='string', is_config=False)""",
        })

    self.__alias = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_alias(self):
    self.__alias = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="alias", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='string', is_config=False)


  def _get_ipv4_address(self):
    """
    Getter method for ipv4_address, mapped from YANG variable /access_points/access_point/system/dns/host_entries/host_entry/state/ipv4_address (oc-inet:ipv4-address)

    YANG Description: List of IPv4 addressses for the host entry
    """
    return self.__ipv4_address
      
  def _set_ipv4_address(self, v, load=False):
    """
    Setter method for ipv4_address, mapped from YANG variable /access_points/access_point/system/dns/host_entries/host_entry/state/ipv4_address (oc-inet:ipv4-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ipv4_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ipv4_address() directly.

    YANG Description: List of IPv4 addressses for the host entry
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])$'})), is_leaf=False, yang_name="ipv4-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-inet:ipv4-address', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ipv4_address must be of a type compatible with oc-inet:ipv4-address""",
          'defined-type': "oc-inet:ipv4-address",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])$'})), is_leaf=False, yang_name="ipv4-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-inet:ipv4-address', is_config=False)""",
        })

    self.__ipv4_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ipv4_address(self):
    self.__ipv4_address = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])$'})), is_leaf=False, yang_name="ipv4-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-inet:ipv4-address', is_config=False)


  def _get_ipv6_address(self):
    """
    Getter method for ipv6_address, mapped from YANG variable /access_points/access_point/system/dns/host_entries/host_entry/state/ipv6_address (oc-inet:ipv6-address)

    YANG Description: List of IPv6 addresses for the host entry
    """
    return self.__ipv6_address
      
  def _set_ipv6_address(self, v, load=False):
    """
    Setter method for ipv6_address, mapped from YANG variable /access_points/access_point/system/dns/host_entries/host_entry/state/ipv6_address (oc-inet:ipv6-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ipv6_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ipv6_address() directly.

    YANG Description: List of IPv6 addresses for the host entry
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))$'})), is_leaf=False, yang_name="ipv6-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-inet:ipv6-address', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ipv6_address must be of a type compatible with oc-inet:ipv6-address""",
          'defined-type': "oc-inet:ipv6-address",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))$'})), is_leaf=False, yang_name="ipv6-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-inet:ipv6-address', is_config=False)""",
        })

    self.__ipv6_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ipv6_address(self):
    self.__ipv6_address = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))$'})), is_leaf=False, yang_name="ipv6-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-inet:ipv6-address', is_config=False)

  hostname = __builtin__.property(_get_hostname)
  alias = __builtin__.property(_get_alias)
  ipv4_address = __builtin__.property(_get_ipv4_address)
  ipv6_address = __builtin__.property(_get_ipv6_address)


  _pyangbind_elements = OrderedDict([('hostname', hostname), ('alias', alias), ('ipv4_address', ipv4_address), ('ipv6_address', ipv6_address), ])


class yc_host_entry_openconfig_access_points__access_points_access_point_system_dns_host_entries_host_entry(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-access-points - based on the path /access-points/access-point/system/dns/host-entries/host-entry. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of static host entries
  """
  __slots__ = ('_path_helper', '_extmethods', '__hostname','__config','__state',)

  _yang_name = 'host-entry'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__state = YANGDynClass(base=yc_state_openconfig_access_points__access_points_access_point_system_dns_host_entries_host_entry_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)
    self.__hostname = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="hostname", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='leafref', is_config=True)
    self.__config = YANGDynClass(base=yc_config_openconfig_access_points__access_points_access_point_system_dns_host_entries_host_entry_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'access-points', u'access-point', u'system', u'dns', u'host-entries', u'host-entry']

  def _get_hostname(self):
    """
    Getter method for hostname, mapped from YANG variable /access_points/access_point/system/dns/host_entries/host_entry/hostname (leafref)

    YANG Description: Reference to the hostname list key
    """
    return self.__hostname
      
  def _set_hostname(self, v, load=False):
    """
    Setter method for hostname, mapped from YANG variable /access_points/access_point/system/dns/host_entries/host_entry/hostname (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_hostname is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_hostname() directly.

    YANG Description: Reference to the hostname list key
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="hostname", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """hostname must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="hostname", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='leafref', is_config=True)""",
        })

    self.__hostname = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_hostname(self):
    self.__hostname = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="hostname", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='leafref', is_config=True)


  def _get_config(self):
    """
    Getter method for config, mapped from YANG variable /access_points/access_point/system/dns/host_entries/host_entry/config (container)

    YANG Description: Configuration data for static host entries
    """
    return self.__config
      
  def _set_config(self, v, load=False):
    """
    Setter method for config, mapped from YANG variable /access_points/access_point/system/dns/host_entries/host_entry/config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config() directly.

    YANG Description: Configuration data for static host entries
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_config_openconfig_access_points__access_points_access_point_system_dns_host_entries_host_entry_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_config_openconfig_access_points__access_points_access_point_system_dns_host_entries_host_entry_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)""",
        })

    self.__config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config(self):
    self.__config = YANGDynClass(base=yc_config_openconfig_access_points__access_points_access_point_system_dns_host_entries_host_entry_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /access_points/access_point/system/dns/host_entries/host_entry/state (container)

    YANG Description: Operational state data for static host entries
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /access_points/access_point/system/dns/host_entries/host_entry/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: Operational state data for static host entries
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_access_points__access_points_access_point_system_dns_host_entries_host_entry_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_access_points__access_points_access_point_system_dns_host_entries_host_entry_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_access_points__access_points_access_point_system_dns_host_entries_host_entry_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)

  hostname = __builtin__.property(_get_hostname, _set_hostname)
  config = __builtin__.property(_get_config, _set_config)
  state = __builtin__.property(_get_state, _set_state)


  _pyangbind_elements = OrderedDict([('hostname', hostname), ('config', config), ('state', state), ])


class yc_host_entries_openconfig_access_points__access_points_access_point_system_dns_host_entries(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-access-points - based on the path /access-points/access-point/system/dns/host-entries. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Enclosing container for list of static host entries
  """
  __slots__ = ('_path_helper', '_extmethods', '__host_entry',)

  _yang_name = 'host-entries'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__host_entry = YANGDynClass(base=YANGListType("hostname",yc_host_entry_openconfig_access_points__access_points_access_point_system_dns_host_entries_host_entry, yang_name="host-entry", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='hostname', extensions=None), is_container='list', yang_name="host-entry", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'access-points', u'access-point', u'system', u'dns', u'host-entries']

  def _get_host_entry(self):
    """
    Getter method for host_entry, mapped from YANG variable /access_points/access_point/system/dns/host_entries/host_entry (list)

    YANG Description: List of static host entries
    """
    return self.__host_entry
      
  def _set_host_entry(self, v, load=False):
    """
    Setter method for host_entry, mapped from YANG variable /access_points/access_point/system/dns/host_entries/host_entry (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_host_entry is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_host_entry() directly.

    YANG Description: List of static host entries
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("hostname",yc_host_entry_openconfig_access_points__access_points_access_point_system_dns_host_entries_host_entry, yang_name="host-entry", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='hostname', extensions=None), is_container='list', yang_name="host-entry", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """host_entry must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("hostname",yc_host_entry_openconfig_access_points__access_points_access_point_system_dns_host_entries_host_entry, yang_name="host-entry", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='hostname', extensions=None), is_container='list', yang_name="host-entry", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='list', is_config=True)""",
        })

    self.__host_entry = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_host_entry(self):
    self.__host_entry = YANGDynClass(base=YANGListType("hostname",yc_host_entry_openconfig_access_points__access_points_access_point_system_dns_host_entries_host_entry, yang_name="host-entry", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='hostname', extensions=None), is_container='list', yang_name="host-entry", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='list', is_config=True)

  host_entry = __builtin__.property(_get_host_entry, _set_host_entry)


  _pyangbind_elements = OrderedDict([('host_entry', host_entry), ])


class yc_dns_openconfig_access_points__access_points_access_point_system_dns(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-access-points - based on the path /access-points/access-point/system/dns. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Enclosing container for DNS resolver data
  """
  __slots__ = ('_path_helper', '_extmethods', '__config','__state','__servers','__host_entries',)

  _yang_name = 'dns'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__state = YANGDynClass(base=yc_state_openconfig_access_points__access_points_access_point_system_dns_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)
    self.__host_entries = YANGDynClass(base=yc_host_entries_openconfig_access_points__access_points_access_point_system_dns_host_entries, is_container='container', yang_name="host-entries", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)
    self.__config = YANGDynClass(base=yc_config_openconfig_access_points__access_points_access_point_system_dns_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)
    self.__servers = YANGDynClass(base=yc_servers_openconfig_access_points__access_points_access_point_system_dns_servers, is_container='container', yang_name="servers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'access-points', u'access-point', u'system', u'dns']

  def _get_config(self):
    """
    Getter method for config, mapped from YANG variable /access_points/access_point/system/dns/config (container)

    YANG Description: Configuration data for the DNS resolver
    """
    return self.__config
      
  def _set_config(self, v, load=False):
    """
    Setter method for config, mapped from YANG variable /access_points/access_point/system/dns/config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config() directly.

    YANG Description: Configuration data for the DNS resolver
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_config_openconfig_access_points__access_points_access_point_system_dns_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_config_openconfig_access_points__access_points_access_point_system_dns_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)""",
        })

    self.__config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config(self):
    self.__config = YANGDynClass(base=yc_config_openconfig_access_points__access_points_access_point_system_dns_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /access_points/access_point/system/dns/state (container)

    YANG Description: Operational state data for the DNS resolver
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /access_points/access_point/system/dns/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: Operational state data for the DNS resolver
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_access_points__access_points_access_point_system_dns_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_access_points__access_points_access_point_system_dns_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_access_points__access_points_access_point_system_dns_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)


  def _get_servers(self):
    """
    Getter method for servers, mapped from YANG variable /access_points/access_point/system/dns/servers (container)

    YANG Description: Enclosing container for DNS resolver list
    """
    return self.__servers
      
  def _set_servers(self, v, load=False):
    """
    Setter method for servers, mapped from YANG variable /access_points/access_point/system/dns/servers (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_servers is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_servers() directly.

    YANG Description: Enclosing container for DNS resolver list
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_servers_openconfig_access_points__access_points_access_point_system_dns_servers, is_container='container', yang_name="servers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """servers must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_servers_openconfig_access_points__access_points_access_point_system_dns_servers, is_container='container', yang_name="servers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)""",
        })

    self.__servers = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_servers(self):
    self.__servers = YANGDynClass(base=yc_servers_openconfig_access_points__access_points_access_point_system_dns_servers, is_container='container', yang_name="servers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)


  def _get_host_entries(self):
    """
    Getter method for host_entries, mapped from YANG variable /access_points/access_point/system/dns/host_entries (container)

    YANG Description: Enclosing container for list of static host entries
    """
    return self.__host_entries
      
  def _set_host_entries(self, v, load=False):
    """
    Setter method for host_entries, mapped from YANG variable /access_points/access_point/system/dns/host_entries (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_host_entries is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_host_entries() directly.

    YANG Description: Enclosing container for list of static host entries
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_host_entries_openconfig_access_points__access_points_access_point_system_dns_host_entries, is_container='container', yang_name="host-entries", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """host_entries must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_host_entries_openconfig_access_points__access_points_access_point_system_dns_host_entries, is_container='container', yang_name="host-entries", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)""",
        })

    self.__host_entries = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_host_entries(self):
    self.__host_entries = YANGDynClass(base=yc_host_entries_openconfig_access_points__access_points_access_point_system_dns_host_entries, is_container='container', yang_name="host-entries", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)

  config = __builtin__.property(_get_config, _set_config)
  state = __builtin__.property(_get_state, _set_state)
  servers = __builtin__.property(_get_servers, _set_servers)
  host_entries = __builtin__.property(_get_host_entries, _set_host_entries)


  _pyangbind_elements = OrderedDict([('config', config), ('state', state), ('servers', servers), ('host_entries', host_entries), ])


class yc_config_openconfig_access_points__access_points_access_point_system_ntp_config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-access-points - based on the path /access-points/access-point/system/ntp/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration data for NTP client.
  """
  __slots__ = ('_path_helper', '_extmethods', '__enabled','__ntp_source_address','__enable_ntp_auth',)

  _yang_name = 'config'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__enable_ntp_auth = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enable-ntp-auth", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=True)
    self.__ntp_source_address = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])$'}),RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))$'}),], is_leaf=True, yang_name="ntp-source-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-inet:ip-address', is_config=True)
    self.__enabled = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'access-points', u'access-point', u'system', u'ntp', u'config']

  def _get_enabled(self):
    """
    Getter method for enabled, mapped from YANG variable /access_points/access_point/system/ntp/config/enabled (boolean)

    YANG Description: Enables the NTP protocol and indicates that the system should
attempt to synchronize the system clock with an NTP server
from the servers defined in the 'ntp/server' list.
    """
    return self.__enabled
      
  def _set_enabled(self, v, load=False):
    """
    Setter method for enabled, mapped from YANG variable /access_points/access_point/system/ntp/config/enabled (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_enabled is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_enabled() directly.

    YANG Description: Enables the NTP protocol and indicates that the system should
attempt to synchronize the system clock with an NTP server
from the servers defined in the 'ntp/server' list.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """enabled must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=True)""",
        })

    self.__enabled = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_enabled(self):
    self.__enabled = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=True)


  def _get_ntp_source_address(self):
    """
    Getter method for ntp_source_address, mapped from YANG variable /access_points/access_point/system/ntp/config/ntp_source_address (oc-inet:ip-address)

    YANG Description: Source address to use on outgoing NTP packets
    """
    return self.__ntp_source_address
      
  def _set_ntp_source_address(self, v, load=False):
    """
    Setter method for ntp_source_address, mapped from YANG variable /access_points/access_point/system/ntp/config/ntp_source_address (oc-inet:ip-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ntp_source_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ntp_source_address() directly.

    YANG Description: Source address to use on outgoing NTP packets
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=[RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])$'}),RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))$'}),], is_leaf=True, yang_name="ntp-source-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-inet:ip-address', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ntp_source_address must be of a type compatible with oc-inet:ip-address""",
          'defined-type': "oc-inet:ip-address",
          'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])$'}),RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))$'}),], is_leaf=True, yang_name="ntp-source-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-inet:ip-address', is_config=True)""",
        })

    self.__ntp_source_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ntp_source_address(self):
    self.__ntp_source_address = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])$'}),RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))$'}),], is_leaf=True, yang_name="ntp-source-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-inet:ip-address', is_config=True)


  def _get_enable_ntp_auth(self):
    """
    Getter method for enable_ntp_auth, mapped from YANG variable /access_points/access_point/system/ntp/config/enable_ntp_auth (boolean)

    YANG Description: Enable or disable NTP authentication -- when enabled, the
system will only use packets containing a trusted
authentication key to synchronize the time.
    """
    return self.__enable_ntp_auth
      
  def _set_enable_ntp_auth(self, v, load=False):
    """
    Setter method for enable_ntp_auth, mapped from YANG variable /access_points/access_point/system/ntp/config/enable_ntp_auth (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_enable_ntp_auth is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_enable_ntp_auth() directly.

    YANG Description: Enable or disable NTP authentication -- when enabled, the
system will only use packets containing a trusted
authentication key to synchronize the time.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enable-ntp-auth", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """enable_ntp_auth must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enable-ntp-auth", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=True)""",
        })

    self.__enable_ntp_auth = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_enable_ntp_auth(self):
    self.__enable_ntp_auth = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enable-ntp-auth", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=True)

  enabled = __builtin__.property(_get_enabled, _set_enabled)
  ntp_source_address = __builtin__.property(_get_ntp_source_address, _set_ntp_source_address)
  enable_ntp_auth = __builtin__.property(_get_enable_ntp_auth, _set_enable_ntp_auth)


  _pyangbind_elements = OrderedDict([('enabled', enabled), ('ntp_source_address', ntp_source_address), ('enable_ntp_auth', enable_ntp_auth), ])


class yc_state_openconfig_access_points__access_points_access_point_system_ntp_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-access-points - based on the path /access-points/access-point/system/ntp/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Operational state data for NTP services.
  """
  __slots__ = ('_path_helper', '_extmethods', '__enabled','__ntp_source_address','__enable_ntp_auth','__auth_mismatch',)

  _yang_name = 'state'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__enable_ntp_auth = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enable-ntp-auth", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=False)
    self.__ntp_source_address = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])$'}),RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))$'}),], is_leaf=True, yang_name="ntp-source-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-inet:ip-address', is_config=False)
    self.__auth_mismatch = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="auth-mismatch", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)
    self.__enabled = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'access-points', u'access-point', u'system', u'ntp', u'state']

  def _get_enabled(self):
    """
    Getter method for enabled, mapped from YANG variable /access_points/access_point/system/ntp/state/enabled (boolean)

    YANG Description: Enables the NTP protocol and indicates that the system should
attempt to synchronize the system clock with an NTP server
from the servers defined in the 'ntp/server' list.
    """
    return self.__enabled
      
  def _set_enabled(self, v, load=False):
    """
    Setter method for enabled, mapped from YANG variable /access_points/access_point/system/ntp/state/enabled (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_enabled is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_enabled() directly.

    YANG Description: Enables the NTP protocol and indicates that the system should
attempt to synchronize the system clock with an NTP server
from the servers defined in the 'ntp/server' list.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """enabled must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=False)""",
        })

    self.__enabled = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_enabled(self):
    self.__enabled = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=False)


  def _get_ntp_source_address(self):
    """
    Getter method for ntp_source_address, mapped from YANG variable /access_points/access_point/system/ntp/state/ntp_source_address (oc-inet:ip-address)

    YANG Description: Source address to use on outgoing NTP packets
    """
    return self.__ntp_source_address
      
  def _set_ntp_source_address(self, v, load=False):
    """
    Setter method for ntp_source_address, mapped from YANG variable /access_points/access_point/system/ntp/state/ntp_source_address (oc-inet:ip-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ntp_source_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ntp_source_address() directly.

    YANG Description: Source address to use on outgoing NTP packets
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=[RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])$'}),RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))$'}),], is_leaf=True, yang_name="ntp-source-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-inet:ip-address', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ntp_source_address must be of a type compatible with oc-inet:ip-address""",
          'defined-type': "oc-inet:ip-address",
          'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])$'}),RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))$'}),], is_leaf=True, yang_name="ntp-source-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-inet:ip-address', is_config=False)""",
        })

    self.__ntp_source_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ntp_source_address(self):
    self.__ntp_source_address = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])$'}),RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))$'}),], is_leaf=True, yang_name="ntp-source-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-inet:ip-address', is_config=False)


  def _get_enable_ntp_auth(self):
    """
    Getter method for enable_ntp_auth, mapped from YANG variable /access_points/access_point/system/ntp/state/enable_ntp_auth (boolean)

    YANG Description: Enable or disable NTP authentication -- when enabled, the
system will only use packets containing a trusted
authentication key to synchronize the time.
    """
    return self.__enable_ntp_auth
      
  def _set_enable_ntp_auth(self, v, load=False):
    """
    Setter method for enable_ntp_auth, mapped from YANG variable /access_points/access_point/system/ntp/state/enable_ntp_auth (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_enable_ntp_auth is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_enable_ntp_auth() directly.

    YANG Description: Enable or disable NTP authentication -- when enabled, the
system will only use packets containing a trusted
authentication key to synchronize the time.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enable-ntp-auth", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """enable_ntp_auth must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enable-ntp-auth", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=False)""",
        })

    self.__enable_ntp_auth = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_enable_ntp_auth(self):
    self.__enable_ntp_auth = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enable-ntp-auth", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=False)


  def _get_auth_mismatch(self):
    """
    Getter method for auth_mismatch, mapped from YANG variable /access_points/access_point/system/ntp/state/auth_mismatch (oc-yang:counter64)

    YANG Description: Count of the number of NTP packets received that were not
processed due to authentication mismatch.
    """
    return self.__auth_mismatch
      
  def _set_auth_mismatch(self, v, load=False):
    """
    Setter method for auth_mismatch, mapped from YANG variable /access_points/access_point/system/ntp/state/auth_mismatch (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_auth_mismatch is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_auth_mismatch() directly.

    YANG Description: Count of the number of NTP packets received that were not
processed due to authentication mismatch.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="auth-mismatch", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """auth_mismatch must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="auth-mismatch", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__auth_mismatch = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_auth_mismatch(self):
    self.__auth_mismatch = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="auth-mismatch", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)

  enabled = __builtin__.property(_get_enabled)
  ntp_source_address = __builtin__.property(_get_ntp_source_address)
  enable_ntp_auth = __builtin__.property(_get_enable_ntp_auth)
  auth_mismatch = __builtin__.property(_get_auth_mismatch)


  _pyangbind_elements = OrderedDict([('enabled', enabled), ('ntp_source_address', ntp_source_address), ('enable_ntp_auth', enable_ntp_auth), ('auth_mismatch', auth_mismatch), ])


class yc_config_openconfig_access_points__access_points_access_point_system_ntp_ntp_keys_ntp_key_config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-access-points - based on the path /access-points/access-point/system/ntp/ntp-keys/ntp-key/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration data for NTP auth keys
  """
  __slots__ = ('_path_helper', '_extmethods', '__key_id','__key_type','__key_value',)

  _yang_name = 'config'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__key_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'oc-sys:NTP_AUTH_MD5': {u'@namespace': u'http://openconfig.net/yang/system', u'@module': u'openconfig-system'}, u'NTP_AUTH_MD5': {u'@namespace': u'http://openconfig.net/yang/system', u'@module': u'openconfig-system'}},), is_leaf=True, yang_name="key-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='identityref', is_config=True)
    self.__key_id = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="key-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint16', is_config=True)
    self.__key_value = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key-value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'access-points', u'access-point', u'system', u'ntp', u'ntp-keys', u'ntp-key', u'config']

  def _get_key_id(self):
    """
    Getter method for key_id, mapped from YANG variable /access_points/access_point/system/ntp/ntp_keys/ntp_key/config/key_id (uint16)

    YANG Description: Integer identifier used by the client and server to
designate a secret key.  The client and server must use
the same key id.
    """
    return self.__key_id
      
  def _set_key_id(self, v, load=False):
    """
    Setter method for key_id, mapped from YANG variable /access_points/access_point/system/ntp/ntp_keys/ntp_key/config/key_id (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_key_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_key_id() directly.

    YANG Description: Integer identifier used by the client and server to
designate a secret key.  The client and server must use
the same key id.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="key-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """key_id must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="key-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint16', is_config=True)""",
        })

    self.__key_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_key_id(self):
    self.__key_id = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="key-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint16', is_config=True)


  def _get_key_type(self):
    """
    Getter method for key_type, mapped from YANG variable /access_points/access_point/system/ntp/ntp_keys/ntp_key/config/key_type (identityref)

    YANG Description: Encryption type used for the NTP authentication key
    """
    return self.__key_type
      
  def _set_key_type(self, v, load=False):
    """
    Setter method for key_type, mapped from YANG variable /access_points/access_point/system/ntp/ntp_keys/ntp_key/config/key_type (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_key_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_key_type() directly.

    YANG Description: Encryption type used for the NTP authentication key
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'oc-sys:NTP_AUTH_MD5': {u'@namespace': u'http://openconfig.net/yang/system', u'@module': u'openconfig-system'}, u'NTP_AUTH_MD5': {u'@namespace': u'http://openconfig.net/yang/system', u'@module': u'openconfig-system'}},), is_leaf=True, yang_name="key-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='identityref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """key_type must be of a type compatible with identityref""",
          'defined-type': "openconfig-access-points:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'oc-sys:NTP_AUTH_MD5': {u'@namespace': u'http://openconfig.net/yang/system', u'@module': u'openconfig-system'}, u'NTP_AUTH_MD5': {u'@namespace': u'http://openconfig.net/yang/system', u'@module': u'openconfig-system'}},), is_leaf=True, yang_name="key-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='identityref', is_config=True)""",
        })

    self.__key_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_key_type(self):
    self.__key_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'oc-sys:NTP_AUTH_MD5': {u'@namespace': u'http://openconfig.net/yang/system', u'@module': u'openconfig-system'}, u'NTP_AUTH_MD5': {u'@namespace': u'http://openconfig.net/yang/system', u'@module': u'openconfig-system'}},), is_leaf=True, yang_name="key-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='identityref', is_config=True)


  def _get_key_value(self):
    """
    Getter method for key_value, mapped from YANG variable /access_points/access_point/system/ntp/ntp_keys/ntp_key/config/key_value (string)

    YANG Description: NTP authentication key value
    """
    return self.__key_value
      
  def _set_key_value(self, v, load=False):
    """
    Setter method for key_value, mapped from YANG variable /access_points/access_point/system/ntp/ntp_keys/ntp_key/config/key_value (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_key_value is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_key_value() directly.

    YANG Description: NTP authentication key value
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="key-value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """key_value must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key-value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='string', is_config=True)""",
        })

    self.__key_value = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_key_value(self):
    self.__key_value = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key-value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='string', is_config=True)

  key_id = __builtin__.property(_get_key_id, _set_key_id)
  key_type = __builtin__.property(_get_key_type, _set_key_type)
  key_value = __builtin__.property(_get_key_value, _set_key_value)


  _pyangbind_elements = OrderedDict([('key_id', key_id), ('key_type', key_type), ('key_value', key_value), ])


class yc_state_openconfig_access_points__access_points_access_point_system_ntp_ntp_keys_ntp_key_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-access-points - based on the path /access-points/access-point/system/ntp/ntp-keys/ntp-key/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Operational state data for NTP auth keys
  """
  __slots__ = ('_path_helper', '_extmethods', '__key_id','__key_type','__key_value',)

  _yang_name = 'state'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__key_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'oc-sys:NTP_AUTH_MD5': {u'@namespace': u'http://openconfig.net/yang/system', u'@module': u'openconfig-system'}, u'NTP_AUTH_MD5': {u'@namespace': u'http://openconfig.net/yang/system', u'@module': u'openconfig-system'}},), is_leaf=True, yang_name="key-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='identityref', is_config=False)
    self.__key_id = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="key-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint16', is_config=False)
    self.__key_value = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key-value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='string', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'access-points', u'access-point', u'system', u'ntp', u'ntp-keys', u'ntp-key', u'state']

  def _get_key_id(self):
    """
    Getter method for key_id, mapped from YANG variable /access_points/access_point/system/ntp/ntp_keys/ntp_key/state/key_id (uint16)

    YANG Description: Integer identifier used by the client and server to
designate a secret key.  The client and server must use
the same key id.
    """
    return self.__key_id
      
  def _set_key_id(self, v, load=False):
    """
    Setter method for key_id, mapped from YANG variable /access_points/access_point/system/ntp/ntp_keys/ntp_key/state/key_id (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_key_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_key_id() directly.

    YANG Description: Integer identifier used by the client and server to
designate a secret key.  The client and server must use
the same key id.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="key-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint16', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """key_id must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="key-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint16', is_config=False)""",
        })

    self.__key_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_key_id(self):
    self.__key_id = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="key-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint16', is_config=False)


  def _get_key_type(self):
    """
    Getter method for key_type, mapped from YANG variable /access_points/access_point/system/ntp/ntp_keys/ntp_key/state/key_type (identityref)

    YANG Description: Encryption type used for the NTP authentication key
    """
    return self.__key_type
      
  def _set_key_type(self, v, load=False):
    """
    Setter method for key_type, mapped from YANG variable /access_points/access_point/system/ntp/ntp_keys/ntp_key/state/key_type (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_key_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_key_type() directly.

    YANG Description: Encryption type used for the NTP authentication key
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'oc-sys:NTP_AUTH_MD5': {u'@namespace': u'http://openconfig.net/yang/system', u'@module': u'openconfig-system'}, u'NTP_AUTH_MD5': {u'@namespace': u'http://openconfig.net/yang/system', u'@module': u'openconfig-system'}},), is_leaf=True, yang_name="key-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='identityref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """key_type must be of a type compatible with identityref""",
          'defined-type': "openconfig-access-points:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'oc-sys:NTP_AUTH_MD5': {u'@namespace': u'http://openconfig.net/yang/system', u'@module': u'openconfig-system'}, u'NTP_AUTH_MD5': {u'@namespace': u'http://openconfig.net/yang/system', u'@module': u'openconfig-system'}},), is_leaf=True, yang_name="key-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='identityref', is_config=False)""",
        })

    self.__key_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_key_type(self):
    self.__key_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'oc-sys:NTP_AUTH_MD5': {u'@namespace': u'http://openconfig.net/yang/system', u'@module': u'openconfig-system'}, u'NTP_AUTH_MD5': {u'@namespace': u'http://openconfig.net/yang/system', u'@module': u'openconfig-system'}},), is_leaf=True, yang_name="key-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='identityref', is_config=False)


  def _get_key_value(self):
    """
    Getter method for key_value, mapped from YANG variable /access_points/access_point/system/ntp/ntp_keys/ntp_key/state/key_value (string)

    YANG Description: NTP authentication key value
    """
    return self.__key_value
      
  def _set_key_value(self, v, load=False):
    """
    Setter method for key_value, mapped from YANG variable /access_points/access_point/system/ntp/ntp_keys/ntp_key/state/key_value (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_key_value is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_key_value() directly.

    YANG Description: NTP authentication key value
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="key-value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """key_value must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key-value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='string', is_config=False)""",
        })

    self.__key_value = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_key_value(self):
    self.__key_value = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key-value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='string', is_config=False)

  key_id = __builtin__.property(_get_key_id)
  key_type = __builtin__.property(_get_key_type)
  key_value = __builtin__.property(_get_key_value)


  _pyangbind_elements = OrderedDict([('key_id', key_id), ('key_type', key_type), ('key_value', key_value), ])


class yc_ntp_key_openconfig_access_points__access_points_access_point_system_ntp_ntp_keys_ntp_key(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-access-points - based on the path /access-points/access-point/system/ntp/ntp-keys/ntp-key. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of NTP authentication keys
  """
  __slots__ = ('_path_helper', '_extmethods', '__key_id','__config','__state',)

  _yang_name = 'ntp-key'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__key_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='leafref', is_config=True)
    self.__state = YANGDynClass(base=yc_state_openconfig_access_points__access_points_access_point_system_ntp_ntp_keys_ntp_key_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)
    self.__config = YANGDynClass(base=yc_config_openconfig_access_points__access_points_access_point_system_ntp_ntp_keys_ntp_key_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'access-points', u'access-point', u'system', u'ntp', u'ntp-keys', u'ntp-key']

  def _get_key_id(self):
    """
    Getter method for key_id, mapped from YANG variable /access_points/access_point/system/ntp/ntp_keys/ntp_key/key_id (leafref)

    YANG Description: Reference to auth key-id list key
    """
    return self.__key_id
      
  def _set_key_id(self, v, load=False):
    """
    Setter method for key_id, mapped from YANG variable /access_points/access_point/system/ntp/ntp_keys/ntp_key/key_id (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_key_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_key_id() directly.

    YANG Description: Reference to auth key-id list key
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="key-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """key_id must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='leafref', is_config=True)""",
        })

    self.__key_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_key_id(self):
    self.__key_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='leafref', is_config=True)


  def _get_config(self):
    """
    Getter method for config, mapped from YANG variable /access_points/access_point/system/ntp/ntp_keys/ntp_key/config (container)

    YANG Description: Configuration data for NTP auth keys
    """
    return self.__config
      
  def _set_config(self, v, load=False):
    """
    Setter method for config, mapped from YANG variable /access_points/access_point/system/ntp/ntp_keys/ntp_key/config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config() directly.

    YANG Description: Configuration data for NTP auth keys
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_config_openconfig_access_points__access_points_access_point_system_ntp_ntp_keys_ntp_key_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_config_openconfig_access_points__access_points_access_point_system_ntp_ntp_keys_ntp_key_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)""",
        })

    self.__config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config(self):
    self.__config = YANGDynClass(base=yc_config_openconfig_access_points__access_points_access_point_system_ntp_ntp_keys_ntp_key_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /access_points/access_point/system/ntp/ntp_keys/ntp_key/state (container)

    YANG Description: Operational state data for NTP auth keys
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /access_points/access_point/system/ntp/ntp_keys/ntp_key/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: Operational state data for NTP auth keys
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_access_points__access_points_access_point_system_ntp_ntp_keys_ntp_key_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_access_points__access_points_access_point_system_ntp_ntp_keys_ntp_key_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_access_points__access_points_access_point_system_ntp_ntp_keys_ntp_key_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)

  key_id = __builtin__.property(_get_key_id, _set_key_id)
  config = __builtin__.property(_get_config, _set_config)
  state = __builtin__.property(_get_state, _set_state)


  _pyangbind_elements = OrderedDict([('key_id', key_id), ('config', config), ('state', state), ])


class yc_ntp_keys_openconfig_access_points__access_points_access_point_system_ntp_ntp_keys(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-access-points - based on the path /access-points/access-point/system/ntp/ntp-keys. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Enclosing container for list of NTP authentication keys
  """
  __slots__ = ('_path_helper', '_extmethods', '__ntp_key',)

  _yang_name = 'ntp-keys'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__ntp_key = YANGDynClass(base=YANGListType("key_id",yc_ntp_key_openconfig_access_points__access_points_access_point_system_ntp_ntp_keys_ntp_key, yang_name="ntp-key", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='key-id', extensions=None), is_container='list', yang_name="ntp-key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'access-points', u'access-point', u'system', u'ntp', u'ntp-keys']

  def _get_ntp_key(self):
    """
    Getter method for ntp_key, mapped from YANG variable /access_points/access_point/system/ntp/ntp_keys/ntp_key (list)

    YANG Description: List of NTP authentication keys
    """
    return self.__ntp_key
      
  def _set_ntp_key(self, v, load=False):
    """
    Setter method for ntp_key, mapped from YANG variable /access_points/access_point/system/ntp/ntp_keys/ntp_key (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ntp_key is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ntp_key() directly.

    YANG Description: List of NTP authentication keys
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("key_id",yc_ntp_key_openconfig_access_points__access_points_access_point_system_ntp_ntp_keys_ntp_key, yang_name="ntp-key", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='key-id', extensions=None), is_container='list', yang_name="ntp-key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ntp_key must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("key_id",yc_ntp_key_openconfig_access_points__access_points_access_point_system_ntp_ntp_keys_ntp_key, yang_name="ntp-key", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='key-id', extensions=None), is_container='list', yang_name="ntp-key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='list', is_config=True)""",
        })

    self.__ntp_key = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ntp_key(self):
    self.__ntp_key = YANGDynClass(base=YANGListType("key_id",yc_ntp_key_openconfig_access_points__access_points_access_point_system_ntp_ntp_keys_ntp_key, yang_name="ntp-key", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='key-id', extensions=None), is_container='list', yang_name="ntp-key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='list', is_config=True)

  ntp_key = __builtin__.property(_get_ntp_key, _set_ntp_key)


  _pyangbind_elements = OrderedDict([('ntp_key', ntp_key), ])


class yc_config_openconfig_access_points__access_points_access_point_system_ntp_servers_server_config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-access-points - based on the path /access-points/access-point/system/ntp/servers/server/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration data for an NTP server.
  """
  __slots__ = ('_path_helper', '_extmethods', '__address','__port','__version','__association_type','__iburst','__prefer',)

  _yang_name = 'config'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__version = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={u'range': [u'1..4']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(4), is_leaf=True, yang_name="version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint8', is_config=True)
    self.__association_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'PEER': {}, u'POOL': {}, u'SERVER': {}},), default=six.text_type("SERVER"), is_leaf=True, yang_name="association-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='enumeration', is_config=True)
    self.__prefer = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="prefer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=True)
    self.__iburst = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="iburst", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=True)
    self.__address = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])$'}),RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))$'}),RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'((([a-zA-Z0-9_]([a-zA-Z0-9\\-_]){0,61})?[a-zA-Z0-9]\\.)*([a-zA-Z0-9_]([a-zA-Z0-9\\-_]){0,61})?[a-zA-Z0-9]\\.?)|\\.', u'length': [u'1..253']}),], is_leaf=True, yang_name="address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-inet:host', is_config=True)
    self.__port = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(123), is_leaf=True, yang_name="port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-inet:port-number', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'access-points', u'access-point', u'system', u'ntp', u'servers', u'server', u'config']

  def _get_address(self):
    """
    Getter method for address, mapped from YANG variable /access_points/access_point/system/ntp/servers/server/config/address (oc-inet:host)

    YANG Description: The address or hostname of the NTP server.
    """
    return self.__address
      
  def _set_address(self, v, load=False):
    """
    Setter method for address, mapped from YANG variable /access_points/access_point/system/ntp/servers/server/config/address (oc-inet:host)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_address() directly.

    YANG Description: The address or hostname of the NTP server.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=[RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])$'}),RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))$'}),RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'((([a-zA-Z0-9_]([a-zA-Z0-9\\-_]){0,61})?[a-zA-Z0-9]\\.)*([a-zA-Z0-9_]([a-zA-Z0-9\\-_]){0,61})?[a-zA-Z0-9]\\.?)|\\.', u'length': [u'1..253']}),], is_leaf=True, yang_name="address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-inet:host', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """address must be of a type compatible with oc-inet:host""",
          'defined-type': "oc-inet:host",
          'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])$'}),RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))$'}),RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'((([a-zA-Z0-9_]([a-zA-Z0-9\\-_]){0,61})?[a-zA-Z0-9]\\.)*([a-zA-Z0-9_]([a-zA-Z0-9\\-_]){0,61})?[a-zA-Z0-9]\\.?)|\\.', u'length': [u'1..253']}),], is_leaf=True, yang_name="address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-inet:host', is_config=True)""",
        })

    self.__address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_address(self):
    self.__address = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])$'}),RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))$'}),RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'((([a-zA-Z0-9_]([a-zA-Z0-9\\-_]){0,61})?[a-zA-Z0-9]\\.)*([a-zA-Z0-9_]([a-zA-Z0-9\\-_]){0,61})?[a-zA-Z0-9]\\.?)|\\.', u'length': [u'1..253']}),], is_leaf=True, yang_name="address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-inet:host', is_config=True)


  def _get_port(self):
    """
    Getter method for port, mapped from YANG variable /access_points/access_point/system/ntp/servers/server/config/port (oc-inet:port-number)

    YANG Description: The port number of the NTP server.
    """
    return self.__port
      
  def _set_port(self, v, load=False):
    """
    Setter method for port, mapped from YANG variable /access_points/access_point/system/ntp/servers/server/config/port (oc-inet:port-number)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_port is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_port() directly.

    YANG Description: The port number of the NTP server.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(123), is_leaf=True, yang_name="port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-inet:port-number', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """port must be of a type compatible with oc-inet:port-number""",
          'defined-type': "oc-inet:port-number",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(123), is_leaf=True, yang_name="port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-inet:port-number', is_config=True)""",
        })

    self.__port = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_port(self):
    self.__port = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(123), is_leaf=True, yang_name="port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-inet:port-number', is_config=True)


  def _get_version(self):
    """
    Getter method for version, mapped from YANG variable /access_points/access_point/system/ntp/servers/server/config/version (uint8)

    YANG Description: Version number to put in outgoing NTP packets
    """
    return self.__version
      
  def _set_version(self, v, load=False):
    """
    Setter method for version, mapped from YANG variable /access_points/access_point/system/ntp/servers/server/config/version (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_version is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_version() directly.

    YANG Description: Version number to put in outgoing NTP packets
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={u'range': [u'1..4']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(4), is_leaf=True, yang_name="version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """version must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={u'range': [u'1..4']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(4), is_leaf=True, yang_name="version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint8', is_config=True)""",
        })

    self.__version = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_version(self):
    self.__version = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={u'range': [u'1..4']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(4), is_leaf=True, yang_name="version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint8', is_config=True)


  def _get_association_type(self):
    """
    Getter method for association_type, mapped from YANG variable /access_points/access_point/system/ntp/servers/server/config/association_type (enumeration)

    YANG Description: The desired association type for this NTP server.
    """
    return self.__association_type
      
  def _set_association_type(self, v, load=False):
    """
    Setter method for association_type, mapped from YANG variable /access_points/access_point/system/ntp/servers/server/config/association_type (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_association_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_association_type() directly.

    YANG Description: The desired association type for this NTP server.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'PEER': {}, u'POOL': {}, u'SERVER': {}},), default=six.text_type("SERVER"), is_leaf=True, yang_name="association-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """association_type must be of a type compatible with enumeration""",
          'defined-type': "openconfig-access-points:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'PEER': {}, u'POOL': {}, u'SERVER': {}},), default=six.text_type("SERVER"), is_leaf=True, yang_name="association-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='enumeration', is_config=True)""",
        })

    self.__association_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_association_type(self):
    self.__association_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'PEER': {}, u'POOL': {}, u'SERVER': {}},), default=six.text_type("SERVER"), is_leaf=True, yang_name="association-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='enumeration', is_config=True)


  def _get_iburst(self):
    """
    Getter method for iburst, mapped from YANG variable /access_points/access_point/system/ntp/servers/server/config/iburst (boolean)

    YANG Description: Indicates whether this server should enable burst
synchronization or not.
    """
    return self.__iburst
      
  def _set_iburst(self, v, load=False):
    """
    Setter method for iburst, mapped from YANG variable /access_points/access_point/system/ntp/servers/server/config/iburst (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_iburst is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_iburst() directly.

    YANG Description: Indicates whether this server should enable burst
synchronization or not.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="iburst", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """iburst must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="iburst", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=True)""",
        })

    self.__iburst = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_iburst(self):
    self.__iburst = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="iburst", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=True)


  def _get_prefer(self):
    """
    Getter method for prefer, mapped from YANG variable /access_points/access_point/system/ntp/servers/server/config/prefer (boolean)

    YANG Description: Indicates whether this server should be preferred
or not.
    """
    return self.__prefer
      
  def _set_prefer(self, v, load=False):
    """
    Setter method for prefer, mapped from YANG variable /access_points/access_point/system/ntp/servers/server/config/prefer (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_prefer is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_prefer() directly.

    YANG Description: Indicates whether this server should be preferred
or not.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="prefer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """prefer must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="prefer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=True)""",
        })

    self.__prefer = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_prefer(self):
    self.__prefer = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="prefer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=True)

  address = __builtin__.property(_get_address, _set_address)
  port = __builtin__.property(_get_port, _set_port)
  version = __builtin__.property(_get_version, _set_version)
  association_type = __builtin__.property(_get_association_type, _set_association_type)
  iburst = __builtin__.property(_get_iburst, _set_iburst)
  prefer = __builtin__.property(_get_prefer, _set_prefer)


  _pyangbind_elements = OrderedDict([('address', address), ('port', port), ('version', version), ('association_type', association_type), ('iburst', iburst), ('prefer', prefer), ])


class yc_state_openconfig_access_points__access_points_access_point_system_ntp_servers_server_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-access-points - based on the path /access-points/access-point/system/ntp/servers/server/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Operational state data for an NTP server.
  """
  __slots__ = ('_path_helper', '_extmethods', '__address','__port','__version','__association_type','__iburst','__prefer','__stratum','__root_delay','__root_dispersion','__offset','__poll_interval',)

  _yang_name = 'state'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__root_delay = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="root-delay", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint32', is_config=False)
    self.__version = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={u'range': [u'1..4']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(4), is_leaf=True, yang_name="version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint8', is_config=False)
    self.__association_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'PEER': {}, u'POOL': {}, u'SERVER': {}},), default=six.text_type("SERVER"), is_leaf=True, yang_name="association-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='enumeration', is_config=False)
    self.__poll_interval = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="poll-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint32', is_config=False)
    self.__stratum = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="stratum", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint8', is_config=False)
    self.__prefer = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="prefer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=False)
    self.__offset = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="offset", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint64', is_config=False)
    self.__iburst = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="iburst", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=False)
    self.__root_dispersion = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="root-dispersion", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint64', is_config=False)
    self.__address = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])$'}),RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))$'}),RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'((([a-zA-Z0-9_]([a-zA-Z0-9\\-_]){0,61})?[a-zA-Z0-9]\\.)*([a-zA-Z0-9_]([a-zA-Z0-9\\-_]){0,61})?[a-zA-Z0-9]\\.?)|\\.', u'length': [u'1..253']}),], is_leaf=True, yang_name="address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-inet:host', is_config=False)
    self.__port = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(123), is_leaf=True, yang_name="port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-inet:port-number', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'access-points', u'access-point', u'system', u'ntp', u'servers', u'server', u'state']

  def _get_address(self):
    """
    Getter method for address, mapped from YANG variable /access_points/access_point/system/ntp/servers/server/state/address (oc-inet:host)

    YANG Description: The address or hostname of the NTP server.
    """
    return self.__address
      
  def _set_address(self, v, load=False):
    """
    Setter method for address, mapped from YANG variable /access_points/access_point/system/ntp/servers/server/state/address (oc-inet:host)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_address() directly.

    YANG Description: The address or hostname of the NTP server.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=[RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])$'}),RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))$'}),RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'((([a-zA-Z0-9_]([a-zA-Z0-9\\-_]){0,61})?[a-zA-Z0-9]\\.)*([a-zA-Z0-9_]([a-zA-Z0-9\\-_]){0,61})?[a-zA-Z0-9]\\.?)|\\.', u'length': [u'1..253']}),], is_leaf=True, yang_name="address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-inet:host', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """address must be of a type compatible with oc-inet:host""",
          'defined-type': "oc-inet:host",
          'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])$'}),RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))$'}),RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'((([a-zA-Z0-9_]([a-zA-Z0-9\\-_]){0,61})?[a-zA-Z0-9]\\.)*([a-zA-Z0-9_]([a-zA-Z0-9\\-_]){0,61})?[a-zA-Z0-9]\\.?)|\\.', u'length': [u'1..253']}),], is_leaf=True, yang_name="address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-inet:host', is_config=False)""",
        })

    self.__address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_address(self):
    self.__address = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])$'}),RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))$'}),RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'((([a-zA-Z0-9_]([a-zA-Z0-9\\-_]){0,61})?[a-zA-Z0-9]\\.)*([a-zA-Z0-9_]([a-zA-Z0-9\\-_]){0,61})?[a-zA-Z0-9]\\.?)|\\.', u'length': [u'1..253']}),], is_leaf=True, yang_name="address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-inet:host', is_config=False)


  def _get_port(self):
    """
    Getter method for port, mapped from YANG variable /access_points/access_point/system/ntp/servers/server/state/port (oc-inet:port-number)

    YANG Description: The port number of the NTP server.
    """
    return self.__port
      
  def _set_port(self, v, load=False):
    """
    Setter method for port, mapped from YANG variable /access_points/access_point/system/ntp/servers/server/state/port (oc-inet:port-number)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_port is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_port() directly.

    YANG Description: The port number of the NTP server.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(123), is_leaf=True, yang_name="port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-inet:port-number', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """port must be of a type compatible with oc-inet:port-number""",
          'defined-type': "oc-inet:port-number",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(123), is_leaf=True, yang_name="port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-inet:port-number', is_config=False)""",
        })

    self.__port = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_port(self):
    self.__port = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(123), is_leaf=True, yang_name="port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-inet:port-number', is_config=False)


  def _get_version(self):
    """
    Getter method for version, mapped from YANG variable /access_points/access_point/system/ntp/servers/server/state/version (uint8)

    YANG Description: Version number to put in outgoing NTP packets
    """
    return self.__version
      
  def _set_version(self, v, load=False):
    """
    Setter method for version, mapped from YANG variable /access_points/access_point/system/ntp/servers/server/state/version (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_version is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_version() directly.

    YANG Description: Version number to put in outgoing NTP packets
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={u'range': [u'1..4']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(4), is_leaf=True, yang_name="version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint8', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """version must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={u'range': [u'1..4']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(4), is_leaf=True, yang_name="version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint8', is_config=False)""",
        })

    self.__version = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_version(self):
    self.__version = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={u'range': [u'1..4']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(4), is_leaf=True, yang_name="version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint8', is_config=False)


  def _get_association_type(self):
    """
    Getter method for association_type, mapped from YANG variable /access_points/access_point/system/ntp/servers/server/state/association_type (enumeration)

    YANG Description: The desired association type for this NTP server.
    """
    return self.__association_type
      
  def _set_association_type(self, v, load=False):
    """
    Setter method for association_type, mapped from YANG variable /access_points/access_point/system/ntp/servers/server/state/association_type (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_association_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_association_type() directly.

    YANG Description: The desired association type for this NTP server.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'PEER': {}, u'POOL': {}, u'SERVER': {}},), default=six.text_type("SERVER"), is_leaf=True, yang_name="association-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='enumeration', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """association_type must be of a type compatible with enumeration""",
          'defined-type': "openconfig-access-points:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'PEER': {}, u'POOL': {}, u'SERVER': {}},), default=six.text_type("SERVER"), is_leaf=True, yang_name="association-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='enumeration', is_config=False)""",
        })

    self.__association_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_association_type(self):
    self.__association_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'PEER': {}, u'POOL': {}, u'SERVER': {}},), default=six.text_type("SERVER"), is_leaf=True, yang_name="association-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='enumeration', is_config=False)


  def _get_iburst(self):
    """
    Getter method for iburst, mapped from YANG variable /access_points/access_point/system/ntp/servers/server/state/iburst (boolean)

    YANG Description: Indicates whether this server should enable burst
synchronization or not.
    """
    return self.__iburst
      
  def _set_iburst(self, v, load=False):
    """
    Setter method for iburst, mapped from YANG variable /access_points/access_point/system/ntp/servers/server/state/iburst (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_iburst is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_iburst() directly.

    YANG Description: Indicates whether this server should enable burst
synchronization or not.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="iburst", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """iburst must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="iburst", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=False)""",
        })

    self.__iburst = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_iburst(self):
    self.__iburst = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="iburst", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=False)


  def _get_prefer(self):
    """
    Getter method for prefer, mapped from YANG variable /access_points/access_point/system/ntp/servers/server/state/prefer (boolean)

    YANG Description: Indicates whether this server should be preferred
or not.
    """
    return self.__prefer
      
  def _set_prefer(self, v, load=False):
    """
    Setter method for prefer, mapped from YANG variable /access_points/access_point/system/ntp/servers/server/state/prefer (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_prefer is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_prefer() directly.

    YANG Description: Indicates whether this server should be preferred
or not.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="prefer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """prefer must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="prefer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=False)""",
        })

    self.__prefer = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_prefer(self):
    self.__prefer = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="prefer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=False)


  def _get_stratum(self):
    """
    Getter method for stratum, mapped from YANG variable /access_points/access_point/system/ntp/servers/server/state/stratum (uint8)

    YANG Description: Indicates the level of the server in the NTP hierarchy. As
stratum number increases, the accuracy is degraded.  Primary
servers are stratum while a maximum value of 16 indicates
unsynchronized.  The values have the following specific
semantics:

| 0      | unspecified or invalid
| 1      | primary server (e.g., equipped with a GPS receiver)
| 2-15   | secondary server (via NTP)
| 16     | unsynchronized
| 17-255 | reserved
    """
    return self.__stratum
      
  def _set_stratum(self, v, load=False):
    """
    Setter method for stratum, mapped from YANG variable /access_points/access_point/system/ntp/servers/server/state/stratum (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_stratum is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_stratum() directly.

    YANG Description: Indicates the level of the server in the NTP hierarchy. As
stratum number increases, the accuracy is degraded.  Primary
servers are stratum while a maximum value of 16 indicates
unsynchronized.  The values have the following specific
semantics:

| 0      | unspecified or invalid
| 1      | primary server (e.g., equipped with a GPS receiver)
| 2-15   | secondary server (via NTP)
| 16     | unsynchronized
| 17-255 | reserved
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="stratum", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint8', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """stratum must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="stratum", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint8', is_config=False)""",
        })

    self.__stratum = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_stratum(self):
    self.__stratum = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="stratum", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint8', is_config=False)


  def _get_root_delay(self):
    """
    Getter method for root_delay, mapped from YANG variable /access_points/access_point/system/ntp/servers/server/state/root_delay (uint32)

    YANG Description: The round-trip delay to the server, in milliseconds.
    """
    return self.__root_delay
      
  def _set_root_delay(self, v, load=False):
    """
    Setter method for root_delay, mapped from YANG variable /access_points/access_point/system/ntp/servers/server/state/root_delay (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_root_delay is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_root_delay() directly.

    YANG Description: The round-trip delay to the server, in milliseconds.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="root-delay", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """root_delay must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="root-delay", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint32', is_config=False)""",
        })

    self.__root_delay = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_root_delay(self):
    self.__root_delay = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="root-delay", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint32', is_config=False)


  def _get_root_dispersion(self):
    """
    Getter method for root_dispersion, mapped from YANG variable /access_points/access_point/system/ntp/servers/server/state/root_dispersion (uint64)

    YANG Description: Dispersion (epsilon) represents the maximum error inherent
in the measurement
    """
    return self.__root_dispersion
      
  def _set_root_dispersion(self, v, load=False):
    """
    Setter method for root_dispersion, mapped from YANG variable /access_points/access_point/system/ntp/servers/server/state/root_dispersion (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_root_dispersion is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_root_dispersion() directly.

    YANG Description: Dispersion (epsilon) represents the maximum error inherent
in the measurement
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="root-dispersion", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """root_dispersion must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="root-dispersion", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint64', is_config=False)""",
        })

    self.__root_dispersion = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_root_dispersion(self):
    self.__root_dispersion = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="root-dispersion", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint64', is_config=False)


  def _get_offset(self):
    """
    Getter method for offset, mapped from YANG variable /access_points/access_point/system/ntp/servers/server/state/offset (uint64)

    YANG Description: Estimate of the current time offset from the peer.  This is
the time difference between the local and reference clock.
    """
    return self.__offset
      
  def _set_offset(self, v, load=False):
    """
    Setter method for offset, mapped from YANG variable /access_points/access_point/system/ntp/servers/server/state/offset (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_offset is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_offset() directly.

    YANG Description: Estimate of the current time offset from the peer.  This is
the time difference between the local and reference clock.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="offset", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """offset must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="offset", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint64', is_config=False)""",
        })

    self.__offset = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_offset(self):
    self.__offset = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="offset", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint64', is_config=False)


  def _get_poll_interval(self):
    """
    Getter method for poll_interval, mapped from YANG variable /access_points/access_point/system/ntp/servers/server/state/poll_interval (uint32)

    YANG Description: Polling interval of the peer
    """
    return self.__poll_interval
      
  def _set_poll_interval(self, v, load=False):
    """
    Setter method for poll_interval, mapped from YANG variable /access_points/access_point/system/ntp/servers/server/state/poll_interval (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_poll_interval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_poll_interval() directly.

    YANG Description: Polling interval of the peer
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="poll-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """poll_interval must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="poll-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint32', is_config=False)""",
        })

    self.__poll_interval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_poll_interval(self):
    self.__poll_interval = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="poll-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint32', is_config=False)

  address = __builtin__.property(_get_address)
  port = __builtin__.property(_get_port)
  version = __builtin__.property(_get_version)
  association_type = __builtin__.property(_get_association_type)
  iburst = __builtin__.property(_get_iburst)
  prefer = __builtin__.property(_get_prefer)
  stratum = __builtin__.property(_get_stratum)
  root_delay = __builtin__.property(_get_root_delay)
  root_dispersion = __builtin__.property(_get_root_dispersion)
  offset = __builtin__.property(_get_offset)
  poll_interval = __builtin__.property(_get_poll_interval)


  _pyangbind_elements = OrderedDict([('address', address), ('port', port), ('version', version), ('association_type', association_type), ('iburst', iburst), ('prefer', prefer), ('stratum', stratum), ('root_delay', root_delay), ('root_dispersion', root_dispersion), ('offset', offset), ('poll_interval', poll_interval), ])


class yc_server_openconfig_access_points__access_points_access_point_system_ntp_servers_server(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-access-points - based on the path /access-points/access-point/system/ntp/servers/server. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of NTP servers to use for system clock
synchronization.  If '/system/ntp/enabled'
is 'true', then the system will attempt to
contact and utilize the specified NTP servers.
  """
  __slots__ = ('_path_helper', '_extmethods', '__address','__config','__state',)

  _yang_name = 'server'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__state = YANGDynClass(base=yc_state_openconfig_access_points__access_points_access_point_system_ntp_servers_server_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)
    self.__config = YANGDynClass(base=yc_config_openconfig_access_points__access_points_access_point_system_ntp_servers_server_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)
    self.__address = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='leafref', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'access-points', u'access-point', u'system', u'ntp', u'servers', u'server']

  def _get_address(self):
    """
    Getter method for address, mapped from YANG variable /access_points/access_point/system/ntp/servers/server/address (leafref)

    YANG Description: References the configured address or hostname of the
NTP server.
    """
    return self.__address
      
  def _set_address(self, v, load=False):
    """
    Setter method for address, mapped from YANG variable /access_points/access_point/system/ntp/servers/server/address (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_address() directly.

    YANG Description: References the configured address or hostname of the
NTP server.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """address must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='leafref', is_config=True)""",
        })

    self.__address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_address(self):
    self.__address = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='leafref', is_config=True)


  def _get_config(self):
    """
    Getter method for config, mapped from YANG variable /access_points/access_point/system/ntp/servers/server/config (container)

    YANG Description: Configuration data for an NTP server.
    """
    return self.__config
      
  def _set_config(self, v, load=False):
    """
    Setter method for config, mapped from YANG variable /access_points/access_point/system/ntp/servers/server/config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config() directly.

    YANG Description: Configuration data for an NTP server.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_config_openconfig_access_points__access_points_access_point_system_ntp_servers_server_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_config_openconfig_access_points__access_points_access_point_system_ntp_servers_server_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)""",
        })

    self.__config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config(self):
    self.__config = YANGDynClass(base=yc_config_openconfig_access_points__access_points_access_point_system_ntp_servers_server_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /access_points/access_point/system/ntp/servers/server/state (container)

    YANG Description: Operational state data for an NTP server.
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /access_points/access_point/system/ntp/servers/server/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: Operational state data for an NTP server.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_access_points__access_points_access_point_system_ntp_servers_server_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_access_points__access_points_access_point_system_ntp_servers_server_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_access_points__access_points_access_point_system_ntp_servers_server_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)

  address = __builtin__.property(_get_address, _set_address)
  config = __builtin__.property(_get_config, _set_config)
  state = __builtin__.property(_get_state, _set_state)


  _pyangbind_elements = OrderedDict([('address', address), ('config', config), ('state', state), ])


class yc_servers_openconfig_access_points__access_points_access_point_system_ntp_servers(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-access-points - based on the path /access-points/access-point/system/ntp/servers. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Enclosing container for the list of NTP servers
  """
  __slots__ = ('_path_helper', '_extmethods', '__server',)

  _yang_name = 'servers'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__server = YANGDynClass(base=YANGListType("address",yc_server_openconfig_access_points__access_points_access_point_system_ntp_servers_server, yang_name="server", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='address', extensions=None), is_container='list', yang_name="server", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'access-points', u'access-point', u'system', u'ntp', u'servers']

  def _get_server(self):
    """
    Getter method for server, mapped from YANG variable /access_points/access_point/system/ntp/servers/server (list)

    YANG Description: List of NTP servers to use for system clock
synchronization.  If '/system/ntp/enabled'
is 'true', then the system will attempt to
contact and utilize the specified NTP servers.
    """
    return self.__server
      
  def _set_server(self, v, load=False):
    """
    Setter method for server, mapped from YANG variable /access_points/access_point/system/ntp/servers/server (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_server is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_server() directly.

    YANG Description: List of NTP servers to use for system clock
synchronization.  If '/system/ntp/enabled'
is 'true', then the system will attempt to
contact and utilize the specified NTP servers.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("address",yc_server_openconfig_access_points__access_points_access_point_system_ntp_servers_server, yang_name="server", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='address', extensions=None), is_container='list', yang_name="server", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """server must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("address",yc_server_openconfig_access_points__access_points_access_point_system_ntp_servers_server, yang_name="server", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='address', extensions=None), is_container='list', yang_name="server", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='list', is_config=True)""",
        })

    self.__server = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_server(self):
    self.__server = YANGDynClass(base=YANGListType("address",yc_server_openconfig_access_points__access_points_access_point_system_ntp_servers_server, yang_name="server", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='address', extensions=None), is_container='list', yang_name="server", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='list', is_config=True)

  server = __builtin__.property(_get_server, _set_server)


  _pyangbind_elements = OrderedDict([('server', server), ])


class yc_ntp_openconfig_access_points__access_points_access_point_system_ntp(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-access-points - based on the path /access-points/access-point/system/ntp. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Top-level container for NTP configuration and state
  """
  __slots__ = ('_path_helper', '_extmethods', '__config','__state','__ntp_keys','__servers',)

  _yang_name = 'ntp'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__ntp_keys = YANGDynClass(base=yc_ntp_keys_openconfig_access_points__access_points_access_point_system_ntp_ntp_keys, is_container='container', yang_name="ntp-keys", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)
    self.__state = YANGDynClass(base=yc_state_openconfig_access_points__access_points_access_point_system_ntp_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)
    self.__config = YANGDynClass(base=yc_config_openconfig_access_points__access_points_access_point_system_ntp_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)
    self.__servers = YANGDynClass(base=yc_servers_openconfig_access_points__access_points_access_point_system_ntp_servers, is_container='container', yang_name="servers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'access-points', u'access-point', u'system', u'ntp']

  def _get_config(self):
    """
    Getter method for config, mapped from YANG variable /access_points/access_point/system/ntp/config (container)

    YANG Description: Configuration data for NTP client.
    """
    return self.__config
      
  def _set_config(self, v, load=False):
    """
    Setter method for config, mapped from YANG variable /access_points/access_point/system/ntp/config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config() directly.

    YANG Description: Configuration data for NTP client.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_config_openconfig_access_points__access_points_access_point_system_ntp_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_config_openconfig_access_points__access_points_access_point_system_ntp_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)""",
        })

    self.__config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config(self):
    self.__config = YANGDynClass(base=yc_config_openconfig_access_points__access_points_access_point_system_ntp_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /access_points/access_point/system/ntp/state (container)

    YANG Description: Operational state data for NTP services.
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /access_points/access_point/system/ntp/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: Operational state data for NTP services.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_access_points__access_points_access_point_system_ntp_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_access_points__access_points_access_point_system_ntp_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_access_points__access_points_access_point_system_ntp_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)


  def _get_ntp_keys(self):
    """
    Getter method for ntp_keys, mapped from YANG variable /access_points/access_point/system/ntp/ntp_keys (container)

    YANG Description: Enclosing container for list of NTP authentication keys
    """
    return self.__ntp_keys
      
  def _set_ntp_keys(self, v, load=False):
    """
    Setter method for ntp_keys, mapped from YANG variable /access_points/access_point/system/ntp/ntp_keys (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ntp_keys is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ntp_keys() directly.

    YANG Description: Enclosing container for list of NTP authentication keys
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_ntp_keys_openconfig_access_points__access_points_access_point_system_ntp_ntp_keys, is_container='container', yang_name="ntp-keys", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ntp_keys must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_ntp_keys_openconfig_access_points__access_points_access_point_system_ntp_ntp_keys, is_container='container', yang_name="ntp-keys", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)""",
        })

    self.__ntp_keys = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ntp_keys(self):
    self.__ntp_keys = YANGDynClass(base=yc_ntp_keys_openconfig_access_points__access_points_access_point_system_ntp_ntp_keys, is_container='container', yang_name="ntp-keys", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)


  def _get_servers(self):
    """
    Getter method for servers, mapped from YANG variable /access_points/access_point/system/ntp/servers (container)

    YANG Description: Enclosing container for the list of NTP servers
    """
    return self.__servers
      
  def _set_servers(self, v, load=False):
    """
    Setter method for servers, mapped from YANG variable /access_points/access_point/system/ntp/servers (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_servers is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_servers() directly.

    YANG Description: Enclosing container for the list of NTP servers
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_servers_openconfig_access_points__access_points_access_point_system_ntp_servers, is_container='container', yang_name="servers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """servers must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_servers_openconfig_access_points__access_points_access_point_system_ntp_servers, is_container='container', yang_name="servers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)""",
        })

    self.__servers = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_servers(self):
    self.__servers = YANGDynClass(base=yc_servers_openconfig_access_points__access_points_access_point_system_ntp_servers, is_container='container', yang_name="servers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)

  config = __builtin__.property(_get_config, _set_config)
  state = __builtin__.property(_get_state, _set_state)
  ntp_keys = __builtin__.property(_get_ntp_keys, _set_ntp_keys)
  servers = __builtin__.property(_get_servers, _set_servers)


  _pyangbind_elements = OrderedDict([('config', config), ('state', state), ('ntp_keys', ntp_keys), ('servers', servers), ])


class yc_config_openconfig_access_points__access_points_access_point_system_grpc_server_config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-access-points - based on the path /access-points/access-point/system/grpc-server/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration data for the system gRPC server
  """
  __slots__ = ('_path_helper', '_extmethods', '__enable','__port','__transport_security','__certificate_id','__listen_addresses',)

  _yang_name = 'config'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__listen_addresses = YANGDynClass(unique=True, base=TypedListType(allowed_type=[RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])$'}),RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))$'}),RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'ANY': {}},),]), is_leaf=False, yang_name="listen-addresses", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='union', is_config=True)
    self.__certificate_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="certificate-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='string', is_config=True)
    self.__transport_security = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="transport-security", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=True)
    self.__enable = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=True)
    self.__port = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-inet:port-number', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'access-points', u'access-point', u'system', u'grpc-server', u'config']

  def _get_enable(self):
    """
    Getter method for enable, mapped from YANG variable /access_points/access_point/system/grpc_server/config/enable (boolean)

    YANG Description: Enables the gRPC server. The gRPC server is enabled by
default
    """
    return self.__enable
      
  def _set_enable(self, v, load=False):
    """
    Setter method for enable, mapped from YANG variable /access_points/access_point/system/grpc_server/config/enable (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_enable is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_enable() directly.

    YANG Description: Enables the gRPC server. The gRPC server is enabled by
default
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """enable must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=True)""",
        })

    self.__enable = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_enable(self):
    self.__enable = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=True)


  def _get_port(self):
    """
    Getter method for port, mapped from YANG variable /access_points/access_point/system/grpc_server/config/port (oc-inet:port-number)

    YANG Description: TCP port on which the gRPC server should listen
    """
    return self.__port
      
  def _set_port(self, v, load=False):
    """
    Setter method for port, mapped from YANG variable /access_points/access_point/system/grpc_server/config/port (oc-inet:port-number)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_port is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_port() directly.

    YANG Description: TCP port on which the gRPC server should listen
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-inet:port-number', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """port must be of a type compatible with oc-inet:port-number""",
          'defined-type': "oc-inet:port-number",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-inet:port-number', is_config=True)""",
        })

    self.__port = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_port(self):
    self.__port = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-inet:port-number', is_config=True)


  def _get_transport_security(self):
    """
    Getter method for transport_security, mapped from YANG variable /access_points/access_point/system/grpc_server/config/transport_security (boolean)

    YANG Description: Enables gRPC transport security (e.g., TLS or SSL)
    """
    return self.__transport_security
      
  def _set_transport_security(self, v, load=False):
    """
    Setter method for transport_security, mapped from YANG variable /access_points/access_point/system/grpc_server/config/transport_security (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_transport_security is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_transport_security() directly.

    YANG Description: Enables gRPC transport security (e.g., TLS or SSL)
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="transport-security", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """transport_security must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="transport-security", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=True)""",
        })

    self.__transport_security = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_transport_security(self):
    self.__transport_security = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="transport-security", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=True)


  def _get_certificate_id(self):
    """
    Getter method for certificate_id, mapped from YANG variable /access_points/access_point/system/grpc_server/config/certificate_id (string)

    YANG Description: The certificate ID to be used for authentication
    """
    return self.__certificate_id
      
  def _set_certificate_id(self, v, load=False):
    """
    Setter method for certificate_id, mapped from YANG variable /access_points/access_point/system/grpc_server/config/certificate_id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_certificate_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_certificate_id() directly.

    YANG Description: The certificate ID to be used for authentication
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="certificate-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """certificate_id must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="certificate-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='string', is_config=True)""",
        })

    self.__certificate_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_certificate_id(self):
    self.__certificate_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="certificate-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='string', is_config=True)


  def _get_listen_addresses(self):
    """
    Getter method for listen_addresses, mapped from YANG variable /access_points/access_point/system/grpc_server/config/listen_addresses (union)

    YANG Description: The IP addresses that the gRPC server should listen
on. This may be an IPv4 or an IPv6 address
    """
    return self.__listen_addresses
      
  def _set_listen_addresses(self, v, load=False):
    """
    Setter method for listen_addresses, mapped from YANG variable /access_points/access_point/system/grpc_server/config/listen_addresses (union)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_listen_addresses is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_listen_addresses() directly.

    YANG Description: The IP addresses that the gRPC server should listen
on. This may be an IPv4 or an IPv6 address
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=[RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])$'}),RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))$'}),RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'ANY': {}},),]), is_leaf=False, yang_name="listen-addresses", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='union', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """listen_addresses must be of a type compatible with union""",
          'defined-type': "openconfig-access-points:union",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=[RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])$'}),RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))$'}),RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'ANY': {}},),]), is_leaf=False, yang_name="listen-addresses", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='union', is_config=True)""",
        })

    self.__listen_addresses = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_listen_addresses(self):
    self.__listen_addresses = YANGDynClass(unique=True, base=TypedListType(allowed_type=[RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])$'}),RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))$'}),RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'ANY': {}},),]), is_leaf=False, yang_name="listen-addresses", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='union', is_config=True)

  enable = __builtin__.property(_get_enable, _set_enable)
  port = __builtin__.property(_get_port, _set_port)
  transport_security = __builtin__.property(_get_transport_security, _set_transport_security)
  certificate_id = __builtin__.property(_get_certificate_id, _set_certificate_id)
  listen_addresses = __builtin__.property(_get_listen_addresses, _set_listen_addresses)


  _pyangbind_elements = OrderedDict([('enable', enable), ('port', port), ('transport_security', transport_security), ('certificate_id', certificate_id), ('listen_addresses', listen_addresses), ])


class yc_state_openconfig_access_points__access_points_access_point_system_grpc_server_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-access-points - based on the path /access-points/access-point/system/grpc-server/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Operational state data for the system gRPC server
  """
  __slots__ = ('_path_helper', '_extmethods', '__enable','__port','__transport_security','__certificate_id','__listen_addresses',)

  _yang_name = 'state'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__listen_addresses = YANGDynClass(unique=True, base=TypedListType(allowed_type=[RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])$'}),RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))$'}),RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'ANY': {}},),]), is_leaf=False, yang_name="listen-addresses", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='union', is_config=False)
    self.__certificate_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="certificate-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='string', is_config=False)
    self.__transport_security = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="transport-security", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=False)
    self.__enable = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=False)
    self.__port = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-inet:port-number', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'access-points', u'access-point', u'system', u'grpc-server', u'state']

  def _get_enable(self):
    """
    Getter method for enable, mapped from YANG variable /access_points/access_point/system/grpc_server/state/enable (boolean)

    YANG Description: Enables the gRPC server. The gRPC server is enabled by
default
    """
    return self.__enable
      
  def _set_enable(self, v, load=False):
    """
    Setter method for enable, mapped from YANG variable /access_points/access_point/system/grpc_server/state/enable (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_enable is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_enable() directly.

    YANG Description: Enables the gRPC server. The gRPC server is enabled by
default
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """enable must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=False)""",
        })

    self.__enable = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_enable(self):
    self.__enable = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=False)


  def _get_port(self):
    """
    Getter method for port, mapped from YANG variable /access_points/access_point/system/grpc_server/state/port (oc-inet:port-number)

    YANG Description: TCP port on which the gRPC server should listen
    """
    return self.__port
      
  def _set_port(self, v, load=False):
    """
    Setter method for port, mapped from YANG variable /access_points/access_point/system/grpc_server/state/port (oc-inet:port-number)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_port is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_port() directly.

    YANG Description: TCP port on which the gRPC server should listen
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-inet:port-number', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """port must be of a type compatible with oc-inet:port-number""",
          'defined-type': "oc-inet:port-number",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-inet:port-number', is_config=False)""",
        })

    self.__port = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_port(self):
    self.__port = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-inet:port-number', is_config=False)


  def _get_transport_security(self):
    """
    Getter method for transport_security, mapped from YANG variable /access_points/access_point/system/grpc_server/state/transport_security (boolean)

    YANG Description: Enables gRPC transport security (e.g., TLS or SSL)
    """
    return self.__transport_security
      
  def _set_transport_security(self, v, load=False):
    """
    Setter method for transport_security, mapped from YANG variable /access_points/access_point/system/grpc_server/state/transport_security (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_transport_security is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_transport_security() directly.

    YANG Description: Enables gRPC transport security (e.g., TLS or SSL)
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="transport-security", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """transport_security must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="transport-security", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=False)""",
        })

    self.__transport_security = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_transport_security(self):
    self.__transport_security = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="transport-security", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=False)


  def _get_certificate_id(self):
    """
    Getter method for certificate_id, mapped from YANG variable /access_points/access_point/system/grpc_server/state/certificate_id (string)

    YANG Description: The certificate ID to be used for authentication
    """
    return self.__certificate_id
      
  def _set_certificate_id(self, v, load=False):
    """
    Setter method for certificate_id, mapped from YANG variable /access_points/access_point/system/grpc_server/state/certificate_id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_certificate_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_certificate_id() directly.

    YANG Description: The certificate ID to be used for authentication
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="certificate-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """certificate_id must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="certificate-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='string', is_config=False)""",
        })

    self.__certificate_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_certificate_id(self):
    self.__certificate_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="certificate-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='string', is_config=False)


  def _get_listen_addresses(self):
    """
    Getter method for listen_addresses, mapped from YANG variable /access_points/access_point/system/grpc_server/state/listen_addresses (union)

    YANG Description: The IP addresses that the gRPC server should listen
on. This may be an IPv4 or an IPv6 address
    """
    return self.__listen_addresses
      
  def _set_listen_addresses(self, v, load=False):
    """
    Setter method for listen_addresses, mapped from YANG variable /access_points/access_point/system/grpc_server/state/listen_addresses (union)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_listen_addresses is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_listen_addresses() directly.

    YANG Description: The IP addresses that the gRPC server should listen
on. This may be an IPv4 or an IPv6 address
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=[RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])$'}),RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))$'}),RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'ANY': {}},),]), is_leaf=False, yang_name="listen-addresses", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='union', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """listen_addresses must be of a type compatible with union""",
          'defined-type': "openconfig-access-points:union",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=[RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])$'}),RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))$'}),RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'ANY': {}},),]), is_leaf=False, yang_name="listen-addresses", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='union', is_config=False)""",
        })

    self.__listen_addresses = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_listen_addresses(self):
    self.__listen_addresses = YANGDynClass(unique=True, base=TypedListType(allowed_type=[RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])$'}),RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))$'}),RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'ANY': {}},),]), is_leaf=False, yang_name="listen-addresses", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='union', is_config=False)

  enable = __builtin__.property(_get_enable)
  port = __builtin__.property(_get_port)
  transport_security = __builtin__.property(_get_transport_security)
  certificate_id = __builtin__.property(_get_certificate_id)
  listen_addresses = __builtin__.property(_get_listen_addresses)


  _pyangbind_elements = OrderedDict([('enable', enable), ('port', port), ('transport_security', transport_security), ('certificate_id', certificate_id), ('listen_addresses', listen_addresses), ])


class yc_grpc_server_openconfig_access_points__access_points_access_point_system_grpc_server(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-access-points - based on the path /access-points/access-point/system/grpc-server. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Top-level container for the gRPC server
  """
  __slots__ = ('_path_helper', '_extmethods', '__config','__state',)

  _yang_name = 'grpc-server'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__state = YANGDynClass(base=yc_state_openconfig_access_points__access_points_access_point_system_grpc_server_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)
    self.__config = YANGDynClass(base=yc_config_openconfig_access_points__access_points_access_point_system_grpc_server_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'access-points', u'access-point', u'system', u'grpc-server']

  def _get_config(self):
    """
    Getter method for config, mapped from YANG variable /access_points/access_point/system/grpc_server/config (container)

    YANG Description: Configuration data for the system gRPC server
    """
    return self.__config
      
  def _set_config(self, v, load=False):
    """
    Setter method for config, mapped from YANG variable /access_points/access_point/system/grpc_server/config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config() directly.

    YANG Description: Configuration data for the system gRPC server
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_config_openconfig_access_points__access_points_access_point_system_grpc_server_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_config_openconfig_access_points__access_points_access_point_system_grpc_server_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)""",
        })

    self.__config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config(self):
    self.__config = YANGDynClass(base=yc_config_openconfig_access_points__access_points_access_point_system_grpc_server_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /access_points/access_point/system/grpc_server/state (container)

    YANG Description: Operational state data for the system gRPC server
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /access_points/access_point/system/grpc_server/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: Operational state data for the system gRPC server
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_access_points__access_points_access_point_system_grpc_server_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_access_points__access_points_access_point_system_grpc_server_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_access_points__access_points_access_point_system_grpc_server_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)

  config = __builtin__.property(_get_config, _set_config)
  state = __builtin__.property(_get_state, _set_state)


  _pyangbind_elements = OrderedDict([('config', config), ('state', state), ])


class yc_config_openconfig_access_points__access_points_access_point_system_ssh_server_config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-access-points - based on the path /access-points/access-point/system/ssh-server/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration data for the system ssh server
  """
  __slots__ = ('_path_helper', '_extmethods', '__enable','__protocol_version','__timeout','__rate_limit','__session_limit',)

  _yang_name = 'config'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__protocol_version = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'V1': {}, u'V2': {}, u'V1_V2': {}},), default=six.text_type("V2"), is_leaf=True, yang_name="protocol-version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='enumeration', is_config=True)
    self.__enable = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=True)
    self.__rate_limit = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="rate-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint16', is_config=True)
    self.__session_limit = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="session-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint16', is_config=True)
    self.__timeout = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="timeout", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint16', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'access-points', u'access-point', u'system', u'ssh-server', u'config']

  def _get_enable(self):
    """
    Getter method for enable, mapped from YANG variable /access_points/access_point/system/ssh_server/config/enable (boolean)

    YANG Description: Enables the ssh server.  The ssh server is enabled by
default.
    """
    return self.__enable
      
  def _set_enable(self, v, load=False):
    """
    Setter method for enable, mapped from YANG variable /access_points/access_point/system/ssh_server/config/enable (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_enable is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_enable() directly.

    YANG Description: Enables the ssh server.  The ssh server is enabled by
default.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """enable must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=True)""",
        })

    self.__enable = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_enable(self):
    self.__enable = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=True)


  def _get_protocol_version(self):
    """
    Getter method for protocol_version, mapped from YANG variable /access_points/access_point/system/ssh_server/config/protocol_version (enumeration)

    YANG Description: Set the protocol version for SSH connections to the system
    """
    return self.__protocol_version
      
  def _set_protocol_version(self, v, load=False):
    """
    Setter method for protocol_version, mapped from YANG variable /access_points/access_point/system/ssh_server/config/protocol_version (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_protocol_version is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_protocol_version() directly.

    YANG Description: Set the protocol version for SSH connections to the system
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'V1': {}, u'V2': {}, u'V1_V2': {}},), default=six.text_type("V2"), is_leaf=True, yang_name="protocol-version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """protocol_version must be of a type compatible with enumeration""",
          'defined-type': "openconfig-access-points:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'V1': {}, u'V2': {}, u'V1_V2': {}},), default=six.text_type("V2"), is_leaf=True, yang_name="protocol-version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='enumeration', is_config=True)""",
        })

    self.__protocol_version = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_protocol_version(self):
    self.__protocol_version = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'V1': {}, u'V2': {}, u'V1_V2': {}},), default=six.text_type("V2"), is_leaf=True, yang_name="protocol-version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='enumeration', is_config=True)


  def _get_timeout(self):
    """
    Getter method for timeout, mapped from YANG variable /access_points/access_point/system/ssh_server/config/timeout (uint16)

    YANG Description: Set the idle timeout in seconds on terminal connections to
the system for the protocol.
    """
    return self.__timeout
      
  def _set_timeout(self, v, load=False):
    """
    Setter method for timeout, mapped from YANG variable /access_points/access_point/system/ssh_server/config/timeout (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_timeout is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_timeout() directly.

    YANG Description: Set the idle timeout in seconds on terminal connections to
the system for the protocol.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="timeout", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """timeout must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="timeout", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint16', is_config=True)""",
        })

    self.__timeout = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_timeout(self):
    self.__timeout = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="timeout", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint16', is_config=True)


  def _get_rate_limit(self):
    """
    Getter method for rate_limit, mapped from YANG variable /access_points/access_point/system/ssh_server/config/rate_limit (uint16)

    YANG Description: Set a limit on the number of connection attempts per
minute to the system for the protocol.
    """
    return self.__rate_limit
      
  def _set_rate_limit(self, v, load=False):
    """
    Setter method for rate_limit, mapped from YANG variable /access_points/access_point/system/ssh_server/config/rate_limit (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_rate_limit is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_rate_limit() directly.

    YANG Description: Set a limit on the number of connection attempts per
minute to the system for the protocol.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="rate-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """rate_limit must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="rate-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint16', is_config=True)""",
        })

    self.__rate_limit = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_rate_limit(self):
    self.__rate_limit = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="rate-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint16', is_config=True)


  def _get_session_limit(self):
    """
    Getter method for session_limit, mapped from YANG variable /access_points/access_point/system/ssh_server/config/session_limit (uint16)

    YANG Description: Set a limit on the number of simultaneous active terminal
sessions to the system for the protocol (e.g., ssh,
telnet, ...) 
    """
    return self.__session_limit
      
  def _set_session_limit(self, v, load=False):
    """
    Setter method for session_limit, mapped from YANG variable /access_points/access_point/system/ssh_server/config/session_limit (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_session_limit is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_session_limit() directly.

    YANG Description: Set a limit on the number of simultaneous active terminal
sessions to the system for the protocol (e.g., ssh,
telnet, ...) 
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="session-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """session_limit must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="session-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint16', is_config=True)""",
        })

    self.__session_limit = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_session_limit(self):
    self.__session_limit = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="session-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint16', is_config=True)

  enable = __builtin__.property(_get_enable, _set_enable)
  protocol_version = __builtin__.property(_get_protocol_version, _set_protocol_version)
  timeout = __builtin__.property(_get_timeout, _set_timeout)
  rate_limit = __builtin__.property(_get_rate_limit, _set_rate_limit)
  session_limit = __builtin__.property(_get_session_limit, _set_session_limit)


  _pyangbind_elements = OrderedDict([('enable', enable), ('protocol_version', protocol_version), ('timeout', timeout), ('rate_limit', rate_limit), ('session_limit', session_limit), ])


class yc_state_openconfig_access_points__access_points_access_point_system_ssh_server_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-access-points - based on the path /access-points/access-point/system/ssh-server/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Operational state data for the system ssh server
  """
  __slots__ = ('_path_helper', '_extmethods', '__enable','__protocol_version','__timeout','__rate_limit','__session_limit',)

  _yang_name = 'state'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__protocol_version = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'V1': {}, u'V2': {}, u'V1_V2': {}},), default=six.text_type("V2"), is_leaf=True, yang_name="protocol-version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='enumeration', is_config=False)
    self.__enable = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=False)
    self.__rate_limit = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="rate-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint16', is_config=False)
    self.__session_limit = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="session-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint16', is_config=False)
    self.__timeout = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="timeout", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint16', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'access-points', u'access-point', u'system', u'ssh-server', u'state']

  def _get_enable(self):
    """
    Getter method for enable, mapped from YANG variable /access_points/access_point/system/ssh_server/state/enable (boolean)

    YANG Description: Enables the ssh server.  The ssh server is enabled by
default.
    """
    return self.__enable
      
  def _set_enable(self, v, load=False):
    """
    Setter method for enable, mapped from YANG variable /access_points/access_point/system/ssh_server/state/enable (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_enable is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_enable() directly.

    YANG Description: Enables the ssh server.  The ssh server is enabled by
default.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """enable must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=False)""",
        })

    self.__enable = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_enable(self):
    self.__enable = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=False)


  def _get_protocol_version(self):
    """
    Getter method for protocol_version, mapped from YANG variable /access_points/access_point/system/ssh_server/state/protocol_version (enumeration)

    YANG Description: Set the protocol version for SSH connections to the system
    """
    return self.__protocol_version
      
  def _set_protocol_version(self, v, load=False):
    """
    Setter method for protocol_version, mapped from YANG variable /access_points/access_point/system/ssh_server/state/protocol_version (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_protocol_version is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_protocol_version() directly.

    YANG Description: Set the protocol version for SSH connections to the system
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'V1': {}, u'V2': {}, u'V1_V2': {}},), default=six.text_type("V2"), is_leaf=True, yang_name="protocol-version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='enumeration', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """protocol_version must be of a type compatible with enumeration""",
          'defined-type': "openconfig-access-points:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'V1': {}, u'V2': {}, u'V1_V2': {}},), default=six.text_type("V2"), is_leaf=True, yang_name="protocol-version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='enumeration', is_config=False)""",
        })

    self.__protocol_version = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_protocol_version(self):
    self.__protocol_version = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'V1': {}, u'V2': {}, u'V1_V2': {}},), default=six.text_type("V2"), is_leaf=True, yang_name="protocol-version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='enumeration', is_config=False)


  def _get_timeout(self):
    """
    Getter method for timeout, mapped from YANG variable /access_points/access_point/system/ssh_server/state/timeout (uint16)

    YANG Description: Set the idle timeout in seconds on terminal connections to
the system for the protocol.
    """
    return self.__timeout
      
  def _set_timeout(self, v, load=False):
    """
    Setter method for timeout, mapped from YANG variable /access_points/access_point/system/ssh_server/state/timeout (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_timeout is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_timeout() directly.

    YANG Description: Set the idle timeout in seconds on terminal connections to
the system for the protocol.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="timeout", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint16', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """timeout must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="timeout", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint16', is_config=False)""",
        })

    self.__timeout = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_timeout(self):
    self.__timeout = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="timeout", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint16', is_config=False)


  def _get_rate_limit(self):
    """
    Getter method for rate_limit, mapped from YANG variable /access_points/access_point/system/ssh_server/state/rate_limit (uint16)

    YANG Description: Set a limit on the number of connection attempts per
minute to the system for the protocol.
    """
    return self.__rate_limit
      
  def _set_rate_limit(self, v, load=False):
    """
    Setter method for rate_limit, mapped from YANG variable /access_points/access_point/system/ssh_server/state/rate_limit (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_rate_limit is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_rate_limit() directly.

    YANG Description: Set a limit on the number of connection attempts per
minute to the system for the protocol.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="rate-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint16', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """rate_limit must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="rate-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint16', is_config=False)""",
        })

    self.__rate_limit = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_rate_limit(self):
    self.__rate_limit = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="rate-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint16', is_config=False)


  def _get_session_limit(self):
    """
    Getter method for session_limit, mapped from YANG variable /access_points/access_point/system/ssh_server/state/session_limit (uint16)

    YANG Description: Set a limit on the number of simultaneous active terminal
sessions to the system for the protocol (e.g., ssh,
telnet, ...) 
    """
    return self.__session_limit
      
  def _set_session_limit(self, v, load=False):
    """
    Setter method for session_limit, mapped from YANG variable /access_points/access_point/system/ssh_server/state/session_limit (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_session_limit is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_session_limit() directly.

    YANG Description: Set a limit on the number of simultaneous active terminal
sessions to the system for the protocol (e.g., ssh,
telnet, ...) 
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="session-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint16', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """session_limit must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="session-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint16', is_config=False)""",
        })

    self.__session_limit = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_session_limit(self):
    self.__session_limit = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="session-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint16', is_config=False)

  enable = __builtin__.property(_get_enable)
  protocol_version = __builtin__.property(_get_protocol_version)
  timeout = __builtin__.property(_get_timeout)
  rate_limit = __builtin__.property(_get_rate_limit)
  session_limit = __builtin__.property(_get_session_limit)


  _pyangbind_elements = OrderedDict([('enable', enable), ('protocol_version', protocol_version), ('timeout', timeout), ('rate_limit', rate_limit), ('session_limit', session_limit), ])


class yc_ssh_server_openconfig_access_points__access_points_access_point_system_ssh_server(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-access-points - based on the path /access-points/access-point/system/ssh-server. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Top-level container for ssh server
  """
  __slots__ = ('_path_helper', '_extmethods', '__config','__state',)

  _yang_name = 'ssh-server'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__state = YANGDynClass(base=yc_state_openconfig_access_points__access_points_access_point_system_ssh_server_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)
    self.__config = YANGDynClass(base=yc_config_openconfig_access_points__access_points_access_point_system_ssh_server_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'access-points', u'access-point', u'system', u'ssh-server']

  def _get_config(self):
    """
    Getter method for config, mapped from YANG variable /access_points/access_point/system/ssh_server/config (container)

    YANG Description: Configuration data for the system ssh server
    """
    return self.__config
      
  def _set_config(self, v, load=False):
    """
    Setter method for config, mapped from YANG variable /access_points/access_point/system/ssh_server/config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config() directly.

    YANG Description: Configuration data for the system ssh server
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_config_openconfig_access_points__access_points_access_point_system_ssh_server_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_config_openconfig_access_points__access_points_access_point_system_ssh_server_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)""",
        })

    self.__config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config(self):
    self.__config = YANGDynClass(base=yc_config_openconfig_access_points__access_points_access_point_system_ssh_server_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /access_points/access_point/system/ssh_server/state (container)

    YANG Description: Operational state data for the system ssh server
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /access_points/access_point/system/ssh_server/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: Operational state data for the system ssh server
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_access_points__access_points_access_point_system_ssh_server_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_access_points__access_points_access_point_system_ssh_server_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_access_points__access_points_access_point_system_ssh_server_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)

  config = __builtin__.property(_get_config, _set_config)
  state = __builtin__.property(_get_state, _set_state)


  _pyangbind_elements = OrderedDict([('config', config), ('state', state), ])


class yc_config_openconfig_access_points__access_points_access_point_system_telnet_server_config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-access-points - based on the path /access-points/access-point/system/telnet-server/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration data for telnet
  """
  __slots__ = ('_path_helper', '_extmethods', '__enable','__timeout','__rate_limit','__session_limit',)

  _yang_name = 'config'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__enable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=True)
    self.__rate_limit = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="rate-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint16', is_config=True)
    self.__session_limit = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="session-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint16', is_config=True)
    self.__timeout = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="timeout", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint16', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'access-points', u'access-point', u'system', u'telnet-server', u'config']

  def _get_enable(self):
    """
    Getter method for enable, mapped from YANG variable /access_points/access_point/system/telnet_server/config/enable (boolean)

    YANG Description: Enables the telnet server.  Telnet is disabled by
default
    """
    return self.__enable
      
  def _set_enable(self, v, load=False):
    """
    Setter method for enable, mapped from YANG variable /access_points/access_point/system/telnet_server/config/enable (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_enable is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_enable() directly.

    YANG Description: Enables the telnet server.  Telnet is disabled by
default
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """enable must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=True)""",
        })

    self.__enable = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_enable(self):
    self.__enable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=True)


  def _get_timeout(self):
    """
    Getter method for timeout, mapped from YANG variable /access_points/access_point/system/telnet_server/config/timeout (uint16)

    YANG Description: Set the idle timeout in seconds on terminal connections to
the system for the protocol.
    """
    return self.__timeout
      
  def _set_timeout(self, v, load=False):
    """
    Setter method for timeout, mapped from YANG variable /access_points/access_point/system/telnet_server/config/timeout (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_timeout is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_timeout() directly.

    YANG Description: Set the idle timeout in seconds on terminal connections to
the system for the protocol.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="timeout", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """timeout must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="timeout", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint16', is_config=True)""",
        })

    self.__timeout = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_timeout(self):
    self.__timeout = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="timeout", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint16', is_config=True)


  def _get_rate_limit(self):
    """
    Getter method for rate_limit, mapped from YANG variable /access_points/access_point/system/telnet_server/config/rate_limit (uint16)

    YANG Description: Set a limit on the number of connection attempts per
minute to the system for the protocol.
    """
    return self.__rate_limit
      
  def _set_rate_limit(self, v, load=False):
    """
    Setter method for rate_limit, mapped from YANG variable /access_points/access_point/system/telnet_server/config/rate_limit (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_rate_limit is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_rate_limit() directly.

    YANG Description: Set a limit on the number of connection attempts per
minute to the system for the protocol.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="rate-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """rate_limit must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="rate-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint16', is_config=True)""",
        })

    self.__rate_limit = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_rate_limit(self):
    self.__rate_limit = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="rate-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint16', is_config=True)


  def _get_session_limit(self):
    """
    Getter method for session_limit, mapped from YANG variable /access_points/access_point/system/telnet_server/config/session_limit (uint16)

    YANG Description: Set a limit on the number of simultaneous active terminal
sessions to the system for the protocol (e.g., ssh,
telnet, ...) 
    """
    return self.__session_limit
      
  def _set_session_limit(self, v, load=False):
    """
    Setter method for session_limit, mapped from YANG variable /access_points/access_point/system/telnet_server/config/session_limit (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_session_limit is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_session_limit() directly.

    YANG Description: Set a limit on the number of simultaneous active terminal
sessions to the system for the protocol (e.g., ssh,
telnet, ...) 
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="session-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """session_limit must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="session-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint16', is_config=True)""",
        })

    self.__session_limit = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_session_limit(self):
    self.__session_limit = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="session-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint16', is_config=True)

  enable = __builtin__.property(_get_enable, _set_enable)
  timeout = __builtin__.property(_get_timeout, _set_timeout)
  rate_limit = __builtin__.property(_get_rate_limit, _set_rate_limit)
  session_limit = __builtin__.property(_get_session_limit, _set_session_limit)


  _pyangbind_elements = OrderedDict([('enable', enable), ('timeout', timeout), ('rate_limit', rate_limit), ('session_limit', session_limit), ])


class yc_state_openconfig_access_points__access_points_access_point_system_telnet_server_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-access-points - based on the path /access-points/access-point/system/telnet-server/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Operational state data for telnet
  """
  __slots__ = ('_path_helper', '_extmethods', '__enable','__timeout','__rate_limit','__session_limit',)

  _yang_name = 'state'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__enable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=False)
    self.__rate_limit = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="rate-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint16', is_config=False)
    self.__session_limit = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="session-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint16', is_config=False)
    self.__timeout = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="timeout", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint16', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'access-points', u'access-point', u'system', u'telnet-server', u'state']

  def _get_enable(self):
    """
    Getter method for enable, mapped from YANG variable /access_points/access_point/system/telnet_server/state/enable (boolean)

    YANG Description: Enables the telnet server.  Telnet is disabled by
default
    """
    return self.__enable
      
  def _set_enable(self, v, load=False):
    """
    Setter method for enable, mapped from YANG variable /access_points/access_point/system/telnet_server/state/enable (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_enable is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_enable() directly.

    YANG Description: Enables the telnet server.  Telnet is disabled by
default
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """enable must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=False)""",
        })

    self.__enable = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_enable(self):
    self.__enable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=False)


  def _get_timeout(self):
    """
    Getter method for timeout, mapped from YANG variable /access_points/access_point/system/telnet_server/state/timeout (uint16)

    YANG Description: Set the idle timeout in seconds on terminal connections to
the system for the protocol.
    """
    return self.__timeout
      
  def _set_timeout(self, v, load=False):
    """
    Setter method for timeout, mapped from YANG variable /access_points/access_point/system/telnet_server/state/timeout (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_timeout is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_timeout() directly.

    YANG Description: Set the idle timeout in seconds on terminal connections to
the system for the protocol.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="timeout", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint16', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """timeout must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="timeout", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint16', is_config=False)""",
        })

    self.__timeout = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_timeout(self):
    self.__timeout = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="timeout", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint16', is_config=False)


  def _get_rate_limit(self):
    """
    Getter method for rate_limit, mapped from YANG variable /access_points/access_point/system/telnet_server/state/rate_limit (uint16)

    YANG Description: Set a limit on the number of connection attempts per
minute to the system for the protocol.
    """
    return self.__rate_limit
      
  def _set_rate_limit(self, v, load=False):
    """
    Setter method for rate_limit, mapped from YANG variable /access_points/access_point/system/telnet_server/state/rate_limit (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_rate_limit is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_rate_limit() directly.

    YANG Description: Set a limit on the number of connection attempts per
minute to the system for the protocol.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="rate-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint16', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """rate_limit must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="rate-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint16', is_config=False)""",
        })

    self.__rate_limit = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_rate_limit(self):
    self.__rate_limit = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="rate-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint16', is_config=False)


  def _get_session_limit(self):
    """
    Getter method for session_limit, mapped from YANG variable /access_points/access_point/system/telnet_server/state/session_limit (uint16)

    YANG Description: Set a limit on the number of simultaneous active terminal
sessions to the system for the protocol (e.g., ssh,
telnet, ...) 
    """
    return self.__session_limit
      
  def _set_session_limit(self, v, load=False):
    """
    Setter method for session_limit, mapped from YANG variable /access_points/access_point/system/telnet_server/state/session_limit (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_session_limit is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_session_limit() directly.

    YANG Description: Set a limit on the number of simultaneous active terminal
sessions to the system for the protocol (e.g., ssh,
telnet, ...) 
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="session-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint16', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """session_limit must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="session-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint16', is_config=False)""",
        })

    self.__session_limit = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_session_limit(self):
    self.__session_limit = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="session-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint16', is_config=False)

  enable = __builtin__.property(_get_enable)
  timeout = __builtin__.property(_get_timeout)
  rate_limit = __builtin__.property(_get_rate_limit)
  session_limit = __builtin__.property(_get_session_limit)


  _pyangbind_elements = OrderedDict([('enable', enable), ('timeout', timeout), ('rate_limit', rate_limit), ('session_limit', session_limit), ])


class yc_telnet_server_openconfig_access_points__access_points_access_point_system_telnet_server(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-access-points - based on the path /access-points/access-point/system/telnet-server. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Top-level container for telnet terminal servers
  """
  __slots__ = ('_path_helper', '_extmethods', '__config','__state',)

  _yang_name = 'telnet-server'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__state = YANGDynClass(base=yc_state_openconfig_access_points__access_points_access_point_system_telnet_server_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)
    self.__config = YANGDynClass(base=yc_config_openconfig_access_points__access_points_access_point_system_telnet_server_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'access-points', u'access-point', u'system', u'telnet-server']

  def _get_config(self):
    """
    Getter method for config, mapped from YANG variable /access_points/access_point/system/telnet_server/config (container)

    YANG Description: Configuration data for telnet
    """
    return self.__config
      
  def _set_config(self, v, load=False):
    """
    Setter method for config, mapped from YANG variable /access_points/access_point/system/telnet_server/config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config() directly.

    YANG Description: Configuration data for telnet
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_config_openconfig_access_points__access_points_access_point_system_telnet_server_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_config_openconfig_access_points__access_points_access_point_system_telnet_server_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)""",
        })

    self.__config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config(self):
    self.__config = YANGDynClass(base=yc_config_openconfig_access_points__access_points_access_point_system_telnet_server_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /access_points/access_point/system/telnet_server/state (container)

    YANG Description: Operational state data for telnet
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /access_points/access_point/system/telnet_server/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: Operational state data for telnet
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_access_points__access_points_access_point_system_telnet_server_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_access_points__access_points_access_point_system_telnet_server_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_access_points__access_points_access_point_system_telnet_server_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)

  config = __builtin__.property(_get_config, _set_config)
  state = __builtin__.property(_get_state, _set_state)


  _pyangbind_elements = OrderedDict([('config', config), ('state', state), ])


class yc_config_openconfig_access_points__access_points_access_point_system_logging_console_selectors_selector_config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-access-points - based on the path /access-points/access-point/system/logging/console/selectors/selector/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration data 
  """
  __slots__ = ('_path_helper', '_extmethods', '__facility','__severity',)

  _yang_name = 'config'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__severity = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'NOTICE': {}, u'WARNING': {}, u'EMERGENCY': {}, u'ALERT': {}, u'CRITICAL': {}, u'ERROR': {}, u'DEBUG': {}, u'INFORMATIONAL': {}},), is_leaf=True, yang_name="severity", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='syslog-severity', is_config=True)
    self.__facility = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'oc-log:AUDIT': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'KERNEL': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:NTP': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'SYSTEM_DAEMON': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'SYSLOG': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'USER': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:MAIL': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:ALL': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:LOCAL1': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:AUTHPRIV': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:LOCAL3': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:LOCAL2': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:LOCAL5': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:LOCAL4': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:LOCAL7': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:LOCAL6': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'AUDIT': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:KERNEL': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'CONSOLE': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'AUTH': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:USER': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:LOCAL0': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:SYSTEM_DAEMON': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'ALL': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'MAIL': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:CONSOLE': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:SYSLOG': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'LOCAL0': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:AUTH': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'NTP': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'LOCAL5': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'LOCAL4': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'LOCAL7': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'LOCAL6': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'LOCAL1': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'AUTHPRIV': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'LOCAL3': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'LOCAL2': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}},), is_leaf=True, yang_name="facility", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='identityref', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'access-points', u'access-point', u'system', u'logging', u'console', u'selectors', u'selector', u'config']

  def _get_facility(self):
    """
    Getter method for facility, mapped from YANG variable /access_points/access_point/system/logging/console/selectors/selector/config/facility (identityref)

    YANG Description: Specifies the facility, or class of messages to log
    """
    return self.__facility
      
  def _set_facility(self, v, load=False):
    """
    Setter method for facility, mapped from YANG variable /access_points/access_point/system/logging/console/selectors/selector/config/facility (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_facility is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_facility() directly.

    YANG Description: Specifies the facility, or class of messages to log
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'oc-log:AUDIT': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'KERNEL': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:NTP': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'SYSTEM_DAEMON': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'SYSLOG': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'USER': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:MAIL': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:ALL': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:LOCAL1': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:AUTHPRIV': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:LOCAL3': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:LOCAL2': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:LOCAL5': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:LOCAL4': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:LOCAL7': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:LOCAL6': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'AUDIT': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:KERNEL': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'CONSOLE': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'AUTH': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:USER': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:LOCAL0': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:SYSTEM_DAEMON': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'ALL': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'MAIL': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:CONSOLE': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:SYSLOG': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'LOCAL0': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:AUTH': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'NTP': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'LOCAL5': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'LOCAL4': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'LOCAL7': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'LOCAL6': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'LOCAL1': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'AUTHPRIV': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'LOCAL3': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'LOCAL2': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}},), is_leaf=True, yang_name="facility", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='identityref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """facility must be of a type compatible with identityref""",
          'defined-type': "openconfig-access-points:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'oc-log:AUDIT': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'KERNEL': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:NTP': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'SYSTEM_DAEMON': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'SYSLOG': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'USER': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:MAIL': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:ALL': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:LOCAL1': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:AUTHPRIV': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:LOCAL3': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:LOCAL2': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:LOCAL5': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:LOCAL4': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:LOCAL7': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:LOCAL6': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'AUDIT': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:KERNEL': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'CONSOLE': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'AUTH': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:USER': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:LOCAL0': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:SYSTEM_DAEMON': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'ALL': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'MAIL': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:CONSOLE': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:SYSLOG': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'LOCAL0': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:AUTH': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'NTP': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'LOCAL5': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'LOCAL4': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'LOCAL7': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'LOCAL6': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'LOCAL1': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'AUTHPRIV': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'LOCAL3': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'LOCAL2': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}},), is_leaf=True, yang_name="facility", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='identityref', is_config=True)""",
        })

    self.__facility = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_facility(self):
    self.__facility = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'oc-log:AUDIT': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'KERNEL': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:NTP': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'SYSTEM_DAEMON': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'SYSLOG': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'USER': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:MAIL': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:ALL': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:LOCAL1': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:AUTHPRIV': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:LOCAL3': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:LOCAL2': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:LOCAL5': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:LOCAL4': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:LOCAL7': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:LOCAL6': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'AUDIT': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:KERNEL': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'CONSOLE': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'AUTH': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:USER': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:LOCAL0': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:SYSTEM_DAEMON': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'ALL': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'MAIL': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:CONSOLE': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:SYSLOG': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'LOCAL0': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:AUTH': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'NTP': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'LOCAL5': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'LOCAL4': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'LOCAL7': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'LOCAL6': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'LOCAL1': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'AUTHPRIV': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'LOCAL3': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'LOCAL2': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}},), is_leaf=True, yang_name="facility", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='identityref', is_config=True)


  def _get_severity(self):
    """
    Getter method for severity, mapped from YANG variable /access_points/access_point/system/logging/console/selectors/selector/config/severity (syslog-severity)

    YANG Description: Specifies that only messages of the given severity (or
greater severity) for the corresonding facility are logged
    """
    return self.__severity
      
  def _set_severity(self, v, load=False):
    """
    Setter method for severity, mapped from YANG variable /access_points/access_point/system/logging/console/selectors/selector/config/severity (syslog-severity)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_severity is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_severity() directly.

    YANG Description: Specifies that only messages of the given severity (or
greater severity) for the corresonding facility are logged
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'NOTICE': {}, u'WARNING': {}, u'EMERGENCY': {}, u'ALERT': {}, u'CRITICAL': {}, u'ERROR': {}, u'DEBUG': {}, u'INFORMATIONAL': {}},), is_leaf=True, yang_name="severity", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='syslog-severity', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """severity must be of a type compatible with syslog-severity""",
          'defined-type': "openconfig-access-points:syslog-severity",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'NOTICE': {}, u'WARNING': {}, u'EMERGENCY': {}, u'ALERT': {}, u'CRITICAL': {}, u'ERROR': {}, u'DEBUG': {}, u'INFORMATIONAL': {}},), is_leaf=True, yang_name="severity", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='syslog-severity', is_config=True)""",
        })

    self.__severity = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_severity(self):
    self.__severity = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'NOTICE': {}, u'WARNING': {}, u'EMERGENCY': {}, u'ALERT': {}, u'CRITICAL': {}, u'ERROR': {}, u'DEBUG': {}, u'INFORMATIONAL': {}},), is_leaf=True, yang_name="severity", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='syslog-severity', is_config=True)

  facility = __builtin__.property(_get_facility, _set_facility)
  severity = __builtin__.property(_get_severity, _set_severity)


  _pyangbind_elements = OrderedDict([('facility', facility), ('severity', severity), ])


class yc_state_openconfig_access_points__access_points_access_point_system_logging_console_selectors_selector_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-access-points - based on the path /access-points/access-point/system/logging/console/selectors/selector/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Operational state data 
  """
  __slots__ = ('_path_helper', '_extmethods', '__facility','__severity',)

  _yang_name = 'state'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__severity = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'NOTICE': {}, u'WARNING': {}, u'EMERGENCY': {}, u'ALERT': {}, u'CRITICAL': {}, u'ERROR': {}, u'DEBUG': {}, u'INFORMATIONAL': {}},), is_leaf=True, yang_name="severity", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='syslog-severity', is_config=False)
    self.__facility = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'oc-log:AUDIT': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'KERNEL': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:NTP': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'SYSTEM_DAEMON': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'SYSLOG': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'USER': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:MAIL': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:ALL': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:LOCAL1': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:AUTHPRIV': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:LOCAL3': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:LOCAL2': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:LOCAL5': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:LOCAL4': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:LOCAL7': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:LOCAL6': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'AUDIT': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:KERNEL': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'CONSOLE': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'AUTH': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:USER': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:LOCAL0': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:SYSTEM_DAEMON': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'ALL': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'MAIL': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:CONSOLE': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:SYSLOG': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'LOCAL0': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:AUTH': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'NTP': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'LOCAL5': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'LOCAL4': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'LOCAL7': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'LOCAL6': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'LOCAL1': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'AUTHPRIV': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'LOCAL3': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'LOCAL2': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}},), is_leaf=True, yang_name="facility", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='identityref', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'access-points', u'access-point', u'system', u'logging', u'console', u'selectors', u'selector', u'state']

  def _get_facility(self):
    """
    Getter method for facility, mapped from YANG variable /access_points/access_point/system/logging/console/selectors/selector/state/facility (identityref)

    YANG Description: Specifies the facility, or class of messages to log
    """
    return self.__facility
      
  def _set_facility(self, v, load=False):
    """
    Setter method for facility, mapped from YANG variable /access_points/access_point/system/logging/console/selectors/selector/state/facility (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_facility is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_facility() directly.

    YANG Description: Specifies the facility, or class of messages to log
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'oc-log:AUDIT': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'KERNEL': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:NTP': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'SYSTEM_DAEMON': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'SYSLOG': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'USER': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:MAIL': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:ALL': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:LOCAL1': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:AUTHPRIV': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:LOCAL3': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:LOCAL2': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:LOCAL5': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:LOCAL4': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:LOCAL7': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:LOCAL6': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'AUDIT': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:KERNEL': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'CONSOLE': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'AUTH': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:USER': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:LOCAL0': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:SYSTEM_DAEMON': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'ALL': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'MAIL': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:CONSOLE': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:SYSLOG': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'LOCAL0': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:AUTH': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'NTP': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'LOCAL5': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'LOCAL4': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'LOCAL7': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'LOCAL6': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'LOCAL1': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'AUTHPRIV': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'LOCAL3': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'LOCAL2': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}},), is_leaf=True, yang_name="facility", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='identityref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """facility must be of a type compatible with identityref""",
          'defined-type': "openconfig-access-points:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'oc-log:AUDIT': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'KERNEL': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:NTP': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'SYSTEM_DAEMON': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'SYSLOG': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'USER': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:MAIL': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:ALL': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:LOCAL1': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:AUTHPRIV': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:LOCAL3': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:LOCAL2': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:LOCAL5': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:LOCAL4': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:LOCAL7': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:LOCAL6': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'AUDIT': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:KERNEL': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'CONSOLE': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'AUTH': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:USER': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:LOCAL0': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:SYSTEM_DAEMON': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'ALL': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'MAIL': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:CONSOLE': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:SYSLOG': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'LOCAL0': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:AUTH': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'NTP': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'LOCAL5': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'LOCAL4': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'LOCAL7': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'LOCAL6': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'LOCAL1': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'AUTHPRIV': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'LOCAL3': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'LOCAL2': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}},), is_leaf=True, yang_name="facility", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='identityref', is_config=False)""",
        })

    self.__facility = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_facility(self):
    self.__facility = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'oc-log:AUDIT': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'KERNEL': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:NTP': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'SYSTEM_DAEMON': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'SYSLOG': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'USER': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:MAIL': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:ALL': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:LOCAL1': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:AUTHPRIV': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:LOCAL3': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:LOCAL2': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:LOCAL5': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:LOCAL4': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:LOCAL7': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:LOCAL6': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'AUDIT': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:KERNEL': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'CONSOLE': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'AUTH': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:USER': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:LOCAL0': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:SYSTEM_DAEMON': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'ALL': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'MAIL': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:CONSOLE': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:SYSLOG': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'LOCAL0': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:AUTH': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'NTP': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'LOCAL5': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'LOCAL4': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'LOCAL7': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'LOCAL6': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'LOCAL1': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'AUTHPRIV': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'LOCAL3': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'LOCAL2': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}},), is_leaf=True, yang_name="facility", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='identityref', is_config=False)


  def _get_severity(self):
    """
    Getter method for severity, mapped from YANG variable /access_points/access_point/system/logging/console/selectors/selector/state/severity (syslog-severity)

    YANG Description: Specifies that only messages of the given severity (or
greater severity) for the corresonding facility are logged
    """
    return self.__severity
      
  def _set_severity(self, v, load=False):
    """
    Setter method for severity, mapped from YANG variable /access_points/access_point/system/logging/console/selectors/selector/state/severity (syslog-severity)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_severity is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_severity() directly.

    YANG Description: Specifies that only messages of the given severity (or
greater severity) for the corresonding facility are logged
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'NOTICE': {}, u'WARNING': {}, u'EMERGENCY': {}, u'ALERT': {}, u'CRITICAL': {}, u'ERROR': {}, u'DEBUG': {}, u'INFORMATIONAL': {}},), is_leaf=True, yang_name="severity", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='syslog-severity', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """severity must be of a type compatible with syslog-severity""",
          'defined-type': "openconfig-access-points:syslog-severity",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'NOTICE': {}, u'WARNING': {}, u'EMERGENCY': {}, u'ALERT': {}, u'CRITICAL': {}, u'ERROR': {}, u'DEBUG': {}, u'INFORMATIONAL': {}},), is_leaf=True, yang_name="severity", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='syslog-severity', is_config=False)""",
        })

    self.__severity = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_severity(self):
    self.__severity = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'NOTICE': {}, u'WARNING': {}, u'EMERGENCY': {}, u'ALERT': {}, u'CRITICAL': {}, u'ERROR': {}, u'DEBUG': {}, u'INFORMATIONAL': {}},), is_leaf=True, yang_name="severity", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='syslog-severity', is_config=False)

  facility = __builtin__.property(_get_facility)
  severity = __builtin__.property(_get_severity)


  _pyangbind_elements = OrderedDict([('facility', facility), ('severity', severity), ])


class yc_selector_openconfig_access_points__access_points_access_point_system_logging_console_selectors_selector(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-access-points - based on the path /access-points/access-point/system/logging/console/selectors/selector. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of selectors for log messages
  """
  __slots__ = ('_path_helper', '_extmethods', '__facility','__severity','__config','__state',)

  _yang_name = 'selector'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__state = YANGDynClass(base=yc_state_openconfig_access_points__access_points_access_point_system_logging_console_selectors_selector_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)
    self.__config = YANGDynClass(base=yc_config_openconfig_access_points__access_points_access_point_system_logging_console_selectors_selector_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)
    self.__severity = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="severity", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='leafref', is_config=True)
    self.__facility = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="facility", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='leafref', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'access-points', u'access-point', u'system', u'logging', u'console', u'selectors', u'selector']

  def _get_facility(self):
    """
    Getter method for facility, mapped from YANG variable /access_points/access_point/system/logging/console/selectors/selector/facility (leafref)

    YANG Description: Reference to facility list key
    """
    return self.__facility
      
  def _set_facility(self, v, load=False):
    """
    Setter method for facility, mapped from YANG variable /access_points/access_point/system/logging/console/selectors/selector/facility (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_facility is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_facility() directly.

    YANG Description: Reference to facility list key
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="facility", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """facility must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="facility", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='leafref', is_config=True)""",
        })

    self.__facility = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_facility(self):
    self.__facility = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="facility", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='leafref', is_config=True)


  def _get_severity(self):
    """
    Getter method for severity, mapped from YANG variable /access_points/access_point/system/logging/console/selectors/selector/severity (leafref)

    YANG Description: Reference to severity list key
    """
    return self.__severity
      
  def _set_severity(self, v, load=False):
    """
    Setter method for severity, mapped from YANG variable /access_points/access_point/system/logging/console/selectors/selector/severity (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_severity is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_severity() directly.

    YANG Description: Reference to severity list key
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="severity", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """severity must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="severity", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='leafref', is_config=True)""",
        })

    self.__severity = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_severity(self):
    self.__severity = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="severity", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='leafref', is_config=True)


  def _get_config(self):
    """
    Getter method for config, mapped from YANG variable /access_points/access_point/system/logging/console/selectors/selector/config (container)

    YANG Description: Configuration data 
    """
    return self.__config
      
  def _set_config(self, v, load=False):
    """
    Setter method for config, mapped from YANG variable /access_points/access_point/system/logging/console/selectors/selector/config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config() directly.

    YANG Description: Configuration data 
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_config_openconfig_access_points__access_points_access_point_system_logging_console_selectors_selector_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_config_openconfig_access_points__access_points_access_point_system_logging_console_selectors_selector_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)""",
        })

    self.__config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config(self):
    self.__config = YANGDynClass(base=yc_config_openconfig_access_points__access_points_access_point_system_logging_console_selectors_selector_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /access_points/access_point/system/logging/console/selectors/selector/state (container)

    YANG Description: Operational state data 
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /access_points/access_point/system/logging/console/selectors/selector/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: Operational state data 
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_access_points__access_points_access_point_system_logging_console_selectors_selector_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_access_points__access_points_access_point_system_logging_console_selectors_selector_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_access_points__access_points_access_point_system_logging_console_selectors_selector_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)

  facility = __builtin__.property(_get_facility, _set_facility)
  severity = __builtin__.property(_get_severity, _set_severity)
  config = __builtin__.property(_get_config, _set_config)
  state = __builtin__.property(_get_state, _set_state)


  _pyangbind_elements = OrderedDict([('facility', facility), ('severity', severity), ('config', config), ('state', state), ])


class yc_selectors_openconfig_access_points__access_points_access_point_system_logging_console_selectors(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-access-points - based on the path /access-points/access-point/system/logging/console/selectors. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Enclosing container 
  """
  __slots__ = ('_path_helper', '_extmethods', '__selector',)

  _yang_name = 'selectors'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__selector = YANGDynClass(base=YANGListType("facility severity",yc_selector_openconfig_access_points__access_points_access_point_system_logging_console_selectors_selector, yang_name="selector", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='facility severity', extensions=None), is_container='list', yang_name="selector", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'access-points', u'access-point', u'system', u'logging', u'console', u'selectors']

  def _get_selector(self):
    """
    Getter method for selector, mapped from YANG variable /access_points/access_point/system/logging/console/selectors/selector (list)

    YANG Description: List of selectors for log messages
    """
    return self.__selector
      
  def _set_selector(self, v, load=False):
    """
    Setter method for selector, mapped from YANG variable /access_points/access_point/system/logging/console/selectors/selector (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_selector is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_selector() directly.

    YANG Description: List of selectors for log messages
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("facility severity",yc_selector_openconfig_access_points__access_points_access_point_system_logging_console_selectors_selector, yang_name="selector", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='facility severity', extensions=None), is_container='list', yang_name="selector", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """selector must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("facility severity",yc_selector_openconfig_access_points__access_points_access_point_system_logging_console_selectors_selector, yang_name="selector", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='facility severity', extensions=None), is_container='list', yang_name="selector", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='list', is_config=True)""",
        })

    self.__selector = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_selector(self):
    self.__selector = YANGDynClass(base=YANGListType("facility severity",yc_selector_openconfig_access_points__access_points_access_point_system_logging_console_selectors_selector, yang_name="selector", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='facility severity', extensions=None), is_container='list', yang_name="selector", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='list', is_config=True)

  selector = __builtin__.property(_get_selector, _set_selector)


  _pyangbind_elements = OrderedDict([('selector', selector), ])


class yc_console_openconfig_access_points__access_points_access_point_system_logging_console(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-access-points - based on the path /access-points/access-point/system/logging/console. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Top-level container for data related to console-based
logging
  """
  __slots__ = ('_path_helper', '_extmethods', '__selectors',)

  _yang_name = 'console'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__selectors = YANGDynClass(base=yc_selectors_openconfig_access_points__access_points_access_point_system_logging_console_selectors, is_container='container', yang_name="selectors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'access-points', u'access-point', u'system', u'logging', u'console']

  def _get_selectors(self):
    """
    Getter method for selectors, mapped from YANG variable /access_points/access_point/system/logging/console/selectors (container)

    YANG Description: Enclosing container 
    """
    return self.__selectors
      
  def _set_selectors(self, v, load=False):
    """
    Setter method for selectors, mapped from YANG variable /access_points/access_point/system/logging/console/selectors (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_selectors is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_selectors() directly.

    YANG Description: Enclosing container 
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_selectors_openconfig_access_points__access_points_access_point_system_logging_console_selectors, is_container='container', yang_name="selectors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """selectors must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_selectors_openconfig_access_points__access_points_access_point_system_logging_console_selectors, is_container='container', yang_name="selectors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)""",
        })

    self.__selectors = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_selectors(self):
    self.__selectors = YANGDynClass(base=yc_selectors_openconfig_access_points__access_points_access_point_system_logging_console_selectors, is_container='container', yang_name="selectors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)

  selectors = __builtin__.property(_get_selectors, _set_selectors)


  _pyangbind_elements = OrderedDict([('selectors', selectors), ])


class yc_config_openconfig_access_points__access_points_access_point_system_logging_remote_servers_remote_server_config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-access-points - based on the path /access-points/access-point/system/logging/remote-servers/remote-server/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration data for remote log servers
  """
  __slots__ = ('_path_helper', '_extmethods', '__host','__source_address','__remote_port',)

  _yang_name = 'config'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__host = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])$'}),RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))$'}),RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'((([a-zA-Z0-9_]([a-zA-Z0-9\\-_]){0,61})?[a-zA-Z0-9]\\.)*([a-zA-Z0-9_]([a-zA-Z0-9\\-_]){0,61})?[a-zA-Z0-9]\\.?)|\\.', u'length': [u'1..253']}),], is_leaf=True, yang_name="host", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-inet:host', is_config=True)
    self.__source_address = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])$'}),RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))$'}),], is_leaf=True, yang_name="source-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-inet:ip-address', is_config=True)
    self.__remote_port = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(514), is_leaf=True, yang_name="remote-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-inet:port-number', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'access-points', u'access-point', u'system', u'logging', u'remote-servers', u'remote-server', u'config']

  def _get_host(self):
    """
    Getter method for host, mapped from YANG variable /access_points/access_point/system/logging/remote_servers/remote_server/config/host (oc-inet:host)

    YANG Description: IP address or hostname of the remote log server
    """
    return self.__host
      
  def _set_host(self, v, load=False):
    """
    Setter method for host, mapped from YANG variable /access_points/access_point/system/logging/remote_servers/remote_server/config/host (oc-inet:host)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_host is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_host() directly.

    YANG Description: IP address or hostname of the remote log server
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=[RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])$'}),RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))$'}),RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'((([a-zA-Z0-9_]([a-zA-Z0-9\\-_]){0,61})?[a-zA-Z0-9]\\.)*([a-zA-Z0-9_]([a-zA-Z0-9\\-_]){0,61})?[a-zA-Z0-9]\\.?)|\\.', u'length': [u'1..253']}),], is_leaf=True, yang_name="host", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-inet:host', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """host must be of a type compatible with oc-inet:host""",
          'defined-type': "oc-inet:host",
          'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])$'}),RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))$'}),RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'((([a-zA-Z0-9_]([a-zA-Z0-9\\-_]){0,61})?[a-zA-Z0-9]\\.)*([a-zA-Z0-9_]([a-zA-Z0-9\\-_]){0,61})?[a-zA-Z0-9]\\.?)|\\.', u'length': [u'1..253']}),], is_leaf=True, yang_name="host", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-inet:host', is_config=True)""",
        })

    self.__host = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_host(self):
    self.__host = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])$'}),RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))$'}),RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'((([a-zA-Z0-9_]([a-zA-Z0-9\\-_]){0,61})?[a-zA-Z0-9]\\.)*([a-zA-Z0-9_]([a-zA-Z0-9\\-_]){0,61})?[a-zA-Z0-9]\\.?)|\\.', u'length': [u'1..253']}),], is_leaf=True, yang_name="host", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-inet:host', is_config=True)


  def _get_source_address(self):
    """
    Getter method for source_address, mapped from YANG variable /access_points/access_point/system/logging/remote_servers/remote_server/config/source_address (oc-inet:ip-address)

    YANG Description: Source IP address for packets to the log server
    """
    return self.__source_address
      
  def _set_source_address(self, v, load=False):
    """
    Setter method for source_address, mapped from YANG variable /access_points/access_point/system/logging/remote_servers/remote_server/config/source_address (oc-inet:ip-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_source_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_source_address() directly.

    YANG Description: Source IP address for packets to the log server
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=[RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])$'}),RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))$'}),], is_leaf=True, yang_name="source-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-inet:ip-address', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """source_address must be of a type compatible with oc-inet:ip-address""",
          'defined-type': "oc-inet:ip-address",
          'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])$'}),RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))$'}),], is_leaf=True, yang_name="source-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-inet:ip-address', is_config=True)""",
        })

    self.__source_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_source_address(self):
    self.__source_address = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])$'}),RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))$'}),], is_leaf=True, yang_name="source-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-inet:ip-address', is_config=True)


  def _get_remote_port(self):
    """
    Getter method for remote_port, mapped from YANG variable /access_points/access_point/system/logging/remote_servers/remote_server/config/remote_port (oc-inet:port-number)

    YANG Description: Sets the destination port number for syslog UDP messages to
the server.  The default for syslog is 514.
    """
    return self.__remote_port
      
  def _set_remote_port(self, v, load=False):
    """
    Setter method for remote_port, mapped from YANG variable /access_points/access_point/system/logging/remote_servers/remote_server/config/remote_port (oc-inet:port-number)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_remote_port is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_remote_port() directly.

    YANG Description: Sets the destination port number for syslog UDP messages to
the server.  The default for syslog is 514.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(514), is_leaf=True, yang_name="remote-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-inet:port-number', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """remote_port must be of a type compatible with oc-inet:port-number""",
          'defined-type': "oc-inet:port-number",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(514), is_leaf=True, yang_name="remote-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-inet:port-number', is_config=True)""",
        })

    self.__remote_port = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_remote_port(self):
    self.__remote_port = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(514), is_leaf=True, yang_name="remote-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-inet:port-number', is_config=True)

  host = __builtin__.property(_get_host, _set_host)
  source_address = __builtin__.property(_get_source_address, _set_source_address)
  remote_port = __builtin__.property(_get_remote_port, _set_remote_port)


  _pyangbind_elements = OrderedDict([('host', host), ('source_address', source_address), ('remote_port', remote_port), ])


class yc_state_openconfig_access_points__access_points_access_point_system_logging_remote_servers_remote_server_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-access-points - based on the path /access-points/access-point/system/logging/remote-servers/remote-server/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Operational state data for remote log servers
  """
  __slots__ = ('_path_helper', '_extmethods', '__host','__source_address','__remote_port',)

  _yang_name = 'state'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__host = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])$'}),RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))$'}),RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'((([a-zA-Z0-9_]([a-zA-Z0-9\\-_]){0,61})?[a-zA-Z0-9]\\.)*([a-zA-Z0-9_]([a-zA-Z0-9\\-_]){0,61})?[a-zA-Z0-9]\\.?)|\\.', u'length': [u'1..253']}),], is_leaf=True, yang_name="host", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-inet:host', is_config=False)
    self.__source_address = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])$'}),RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))$'}),], is_leaf=True, yang_name="source-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-inet:ip-address', is_config=False)
    self.__remote_port = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(514), is_leaf=True, yang_name="remote-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-inet:port-number', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'access-points', u'access-point', u'system', u'logging', u'remote-servers', u'remote-server', u'state']

  def _get_host(self):
    """
    Getter method for host, mapped from YANG variable /access_points/access_point/system/logging/remote_servers/remote_server/state/host (oc-inet:host)

    YANG Description: IP address or hostname of the remote log server
    """
    return self.__host
      
  def _set_host(self, v, load=False):
    """
    Setter method for host, mapped from YANG variable /access_points/access_point/system/logging/remote_servers/remote_server/state/host (oc-inet:host)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_host is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_host() directly.

    YANG Description: IP address or hostname of the remote log server
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=[RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])$'}),RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))$'}),RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'((([a-zA-Z0-9_]([a-zA-Z0-9\\-_]){0,61})?[a-zA-Z0-9]\\.)*([a-zA-Z0-9_]([a-zA-Z0-9\\-_]){0,61})?[a-zA-Z0-9]\\.?)|\\.', u'length': [u'1..253']}),], is_leaf=True, yang_name="host", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-inet:host', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """host must be of a type compatible with oc-inet:host""",
          'defined-type': "oc-inet:host",
          'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])$'}),RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))$'}),RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'((([a-zA-Z0-9_]([a-zA-Z0-9\\-_]){0,61})?[a-zA-Z0-9]\\.)*([a-zA-Z0-9_]([a-zA-Z0-9\\-_]){0,61})?[a-zA-Z0-9]\\.?)|\\.', u'length': [u'1..253']}),], is_leaf=True, yang_name="host", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-inet:host', is_config=False)""",
        })

    self.__host = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_host(self):
    self.__host = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])$'}),RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))$'}),RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'((([a-zA-Z0-9_]([a-zA-Z0-9\\-_]){0,61})?[a-zA-Z0-9]\\.)*([a-zA-Z0-9_]([a-zA-Z0-9\\-_]){0,61})?[a-zA-Z0-9]\\.?)|\\.', u'length': [u'1..253']}),], is_leaf=True, yang_name="host", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-inet:host', is_config=False)


  def _get_source_address(self):
    """
    Getter method for source_address, mapped from YANG variable /access_points/access_point/system/logging/remote_servers/remote_server/state/source_address (oc-inet:ip-address)

    YANG Description: Source IP address for packets to the log server
    """
    return self.__source_address
      
  def _set_source_address(self, v, load=False):
    """
    Setter method for source_address, mapped from YANG variable /access_points/access_point/system/logging/remote_servers/remote_server/state/source_address (oc-inet:ip-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_source_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_source_address() directly.

    YANG Description: Source IP address for packets to the log server
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=[RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])$'}),RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))$'}),], is_leaf=True, yang_name="source-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-inet:ip-address', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """source_address must be of a type compatible with oc-inet:ip-address""",
          'defined-type': "oc-inet:ip-address",
          'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])$'}),RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))$'}),], is_leaf=True, yang_name="source-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-inet:ip-address', is_config=False)""",
        })

    self.__source_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_source_address(self):
    self.__source_address = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])$'}),RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))$'}),], is_leaf=True, yang_name="source-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-inet:ip-address', is_config=False)


  def _get_remote_port(self):
    """
    Getter method for remote_port, mapped from YANG variable /access_points/access_point/system/logging/remote_servers/remote_server/state/remote_port (oc-inet:port-number)

    YANG Description: Sets the destination port number for syslog UDP messages to
the server.  The default for syslog is 514.
    """
    return self.__remote_port
      
  def _set_remote_port(self, v, load=False):
    """
    Setter method for remote_port, mapped from YANG variable /access_points/access_point/system/logging/remote_servers/remote_server/state/remote_port (oc-inet:port-number)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_remote_port is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_remote_port() directly.

    YANG Description: Sets the destination port number for syslog UDP messages to
the server.  The default for syslog is 514.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(514), is_leaf=True, yang_name="remote-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-inet:port-number', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """remote_port must be of a type compatible with oc-inet:port-number""",
          'defined-type': "oc-inet:port-number",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(514), is_leaf=True, yang_name="remote-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-inet:port-number', is_config=False)""",
        })

    self.__remote_port = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_remote_port(self):
    self.__remote_port = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(514), is_leaf=True, yang_name="remote-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-inet:port-number', is_config=False)

  host = __builtin__.property(_get_host)
  source_address = __builtin__.property(_get_source_address)
  remote_port = __builtin__.property(_get_remote_port)


  _pyangbind_elements = OrderedDict([('host', host), ('source_address', source_address), ('remote_port', remote_port), ])


class yc_config_openconfig_access_points__access_points_access_point_system_logging_remote_servers_remote_server_selectors_selector_config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-access-points - based on the path /access-points/access-point/system/logging/remote-servers/remote-server/selectors/selector/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration data 
  """
  __slots__ = ('_path_helper', '_extmethods', '__facility','__severity',)

  _yang_name = 'config'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__severity = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'NOTICE': {}, u'WARNING': {}, u'EMERGENCY': {}, u'ALERT': {}, u'CRITICAL': {}, u'ERROR': {}, u'DEBUG': {}, u'INFORMATIONAL': {}},), is_leaf=True, yang_name="severity", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='syslog-severity', is_config=True)
    self.__facility = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'oc-log:AUDIT': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'KERNEL': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:NTP': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'SYSTEM_DAEMON': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'SYSLOG': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'USER': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:MAIL': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:ALL': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:LOCAL1': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:AUTHPRIV': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:LOCAL3': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:LOCAL2': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:LOCAL5': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:LOCAL4': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:LOCAL7': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:LOCAL6': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'AUDIT': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:KERNEL': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'CONSOLE': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'AUTH': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:USER': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:LOCAL0': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:SYSTEM_DAEMON': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'ALL': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'MAIL': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:CONSOLE': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:SYSLOG': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'LOCAL0': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:AUTH': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'NTP': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'LOCAL5': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'LOCAL4': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'LOCAL7': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'LOCAL6': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'LOCAL1': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'AUTHPRIV': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'LOCAL3': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'LOCAL2': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}},), is_leaf=True, yang_name="facility", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='identityref', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'access-points', u'access-point', u'system', u'logging', u'remote-servers', u'remote-server', u'selectors', u'selector', u'config']

  def _get_facility(self):
    """
    Getter method for facility, mapped from YANG variable /access_points/access_point/system/logging/remote_servers/remote_server/selectors/selector/config/facility (identityref)

    YANG Description: Specifies the facility, or class of messages to log
    """
    return self.__facility
      
  def _set_facility(self, v, load=False):
    """
    Setter method for facility, mapped from YANG variable /access_points/access_point/system/logging/remote_servers/remote_server/selectors/selector/config/facility (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_facility is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_facility() directly.

    YANG Description: Specifies the facility, or class of messages to log
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'oc-log:AUDIT': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'KERNEL': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:NTP': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'SYSTEM_DAEMON': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'SYSLOG': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'USER': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:MAIL': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:ALL': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:LOCAL1': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:AUTHPRIV': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:LOCAL3': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:LOCAL2': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:LOCAL5': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:LOCAL4': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:LOCAL7': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:LOCAL6': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'AUDIT': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:KERNEL': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'CONSOLE': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'AUTH': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:USER': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:LOCAL0': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:SYSTEM_DAEMON': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'ALL': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'MAIL': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:CONSOLE': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:SYSLOG': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'LOCAL0': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:AUTH': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'NTP': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'LOCAL5': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'LOCAL4': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'LOCAL7': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'LOCAL6': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'LOCAL1': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'AUTHPRIV': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'LOCAL3': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'LOCAL2': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}},), is_leaf=True, yang_name="facility", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='identityref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """facility must be of a type compatible with identityref""",
          'defined-type': "openconfig-access-points:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'oc-log:AUDIT': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'KERNEL': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:NTP': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'SYSTEM_DAEMON': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'SYSLOG': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'USER': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:MAIL': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:ALL': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:LOCAL1': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:AUTHPRIV': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:LOCAL3': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:LOCAL2': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:LOCAL5': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:LOCAL4': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:LOCAL7': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:LOCAL6': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'AUDIT': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:KERNEL': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'CONSOLE': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'AUTH': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:USER': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:LOCAL0': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:SYSTEM_DAEMON': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'ALL': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'MAIL': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:CONSOLE': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:SYSLOG': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'LOCAL0': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:AUTH': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'NTP': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'LOCAL5': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'LOCAL4': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'LOCAL7': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'LOCAL6': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'LOCAL1': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'AUTHPRIV': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'LOCAL3': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'LOCAL2': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}},), is_leaf=True, yang_name="facility", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='identityref', is_config=True)""",
        })

    self.__facility = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_facility(self):
    self.__facility = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'oc-log:AUDIT': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'KERNEL': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:NTP': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'SYSTEM_DAEMON': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'SYSLOG': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'USER': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:MAIL': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:ALL': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:LOCAL1': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:AUTHPRIV': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:LOCAL3': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:LOCAL2': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:LOCAL5': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:LOCAL4': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:LOCAL7': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:LOCAL6': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'AUDIT': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:KERNEL': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'CONSOLE': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'AUTH': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:USER': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:LOCAL0': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:SYSTEM_DAEMON': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'ALL': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'MAIL': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:CONSOLE': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:SYSLOG': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'LOCAL0': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:AUTH': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'NTP': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'LOCAL5': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'LOCAL4': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'LOCAL7': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'LOCAL6': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'LOCAL1': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'AUTHPRIV': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'LOCAL3': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'LOCAL2': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}},), is_leaf=True, yang_name="facility", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='identityref', is_config=True)


  def _get_severity(self):
    """
    Getter method for severity, mapped from YANG variable /access_points/access_point/system/logging/remote_servers/remote_server/selectors/selector/config/severity (syslog-severity)

    YANG Description: Specifies that only messages of the given severity (or
greater severity) for the corresonding facility are logged
    """
    return self.__severity
      
  def _set_severity(self, v, load=False):
    """
    Setter method for severity, mapped from YANG variable /access_points/access_point/system/logging/remote_servers/remote_server/selectors/selector/config/severity (syslog-severity)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_severity is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_severity() directly.

    YANG Description: Specifies that only messages of the given severity (or
greater severity) for the corresonding facility are logged
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'NOTICE': {}, u'WARNING': {}, u'EMERGENCY': {}, u'ALERT': {}, u'CRITICAL': {}, u'ERROR': {}, u'DEBUG': {}, u'INFORMATIONAL': {}},), is_leaf=True, yang_name="severity", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='syslog-severity', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """severity must be of a type compatible with syslog-severity""",
          'defined-type': "openconfig-access-points:syslog-severity",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'NOTICE': {}, u'WARNING': {}, u'EMERGENCY': {}, u'ALERT': {}, u'CRITICAL': {}, u'ERROR': {}, u'DEBUG': {}, u'INFORMATIONAL': {}},), is_leaf=True, yang_name="severity", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='syslog-severity', is_config=True)""",
        })

    self.__severity = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_severity(self):
    self.__severity = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'NOTICE': {}, u'WARNING': {}, u'EMERGENCY': {}, u'ALERT': {}, u'CRITICAL': {}, u'ERROR': {}, u'DEBUG': {}, u'INFORMATIONAL': {}},), is_leaf=True, yang_name="severity", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='syslog-severity', is_config=True)

  facility = __builtin__.property(_get_facility, _set_facility)
  severity = __builtin__.property(_get_severity, _set_severity)


  _pyangbind_elements = OrderedDict([('facility', facility), ('severity', severity), ])


class yc_state_openconfig_access_points__access_points_access_point_system_logging_remote_servers_remote_server_selectors_selector_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-access-points - based on the path /access-points/access-point/system/logging/remote-servers/remote-server/selectors/selector/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Operational state data 
  """
  __slots__ = ('_path_helper', '_extmethods', '__facility','__severity',)

  _yang_name = 'state'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__severity = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'NOTICE': {}, u'WARNING': {}, u'EMERGENCY': {}, u'ALERT': {}, u'CRITICAL': {}, u'ERROR': {}, u'DEBUG': {}, u'INFORMATIONAL': {}},), is_leaf=True, yang_name="severity", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='syslog-severity', is_config=False)
    self.__facility = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'oc-log:AUDIT': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'KERNEL': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:NTP': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'SYSTEM_DAEMON': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'SYSLOG': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'USER': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:MAIL': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:ALL': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:LOCAL1': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:AUTHPRIV': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:LOCAL3': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:LOCAL2': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:LOCAL5': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:LOCAL4': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:LOCAL7': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:LOCAL6': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'AUDIT': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:KERNEL': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'CONSOLE': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'AUTH': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:USER': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:LOCAL0': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:SYSTEM_DAEMON': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'ALL': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'MAIL': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:CONSOLE': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:SYSLOG': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'LOCAL0': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:AUTH': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'NTP': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'LOCAL5': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'LOCAL4': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'LOCAL7': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'LOCAL6': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'LOCAL1': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'AUTHPRIV': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'LOCAL3': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'LOCAL2': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}},), is_leaf=True, yang_name="facility", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='identityref', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'access-points', u'access-point', u'system', u'logging', u'remote-servers', u'remote-server', u'selectors', u'selector', u'state']

  def _get_facility(self):
    """
    Getter method for facility, mapped from YANG variable /access_points/access_point/system/logging/remote_servers/remote_server/selectors/selector/state/facility (identityref)

    YANG Description: Specifies the facility, or class of messages to log
    """
    return self.__facility
      
  def _set_facility(self, v, load=False):
    """
    Setter method for facility, mapped from YANG variable /access_points/access_point/system/logging/remote_servers/remote_server/selectors/selector/state/facility (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_facility is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_facility() directly.

    YANG Description: Specifies the facility, or class of messages to log
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'oc-log:AUDIT': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'KERNEL': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:NTP': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'SYSTEM_DAEMON': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'SYSLOG': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'USER': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:MAIL': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:ALL': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:LOCAL1': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:AUTHPRIV': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:LOCAL3': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:LOCAL2': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:LOCAL5': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:LOCAL4': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:LOCAL7': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:LOCAL6': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'AUDIT': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:KERNEL': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'CONSOLE': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'AUTH': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:USER': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:LOCAL0': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:SYSTEM_DAEMON': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'ALL': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'MAIL': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:CONSOLE': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:SYSLOG': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'LOCAL0': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:AUTH': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'NTP': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'LOCAL5': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'LOCAL4': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'LOCAL7': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'LOCAL6': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'LOCAL1': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'AUTHPRIV': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'LOCAL3': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'LOCAL2': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}},), is_leaf=True, yang_name="facility", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='identityref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """facility must be of a type compatible with identityref""",
          'defined-type': "openconfig-access-points:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'oc-log:AUDIT': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'KERNEL': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:NTP': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'SYSTEM_DAEMON': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'SYSLOG': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'USER': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:MAIL': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:ALL': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:LOCAL1': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:AUTHPRIV': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:LOCAL3': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:LOCAL2': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:LOCAL5': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:LOCAL4': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:LOCAL7': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:LOCAL6': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'AUDIT': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:KERNEL': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'CONSOLE': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'AUTH': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:USER': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:LOCAL0': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:SYSTEM_DAEMON': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'ALL': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'MAIL': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:CONSOLE': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:SYSLOG': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'LOCAL0': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:AUTH': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'NTP': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'LOCAL5': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'LOCAL4': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'LOCAL7': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'LOCAL6': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'LOCAL1': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'AUTHPRIV': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'LOCAL3': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'LOCAL2': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}},), is_leaf=True, yang_name="facility", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='identityref', is_config=False)""",
        })

    self.__facility = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_facility(self):
    self.__facility = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'oc-log:AUDIT': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'KERNEL': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:NTP': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'SYSTEM_DAEMON': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'SYSLOG': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'USER': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:MAIL': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:ALL': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:LOCAL1': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:AUTHPRIV': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:LOCAL3': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:LOCAL2': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:LOCAL5': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:LOCAL4': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:LOCAL7': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:LOCAL6': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'AUDIT': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:KERNEL': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'CONSOLE': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'AUTH': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:USER': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:LOCAL0': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:SYSTEM_DAEMON': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'ALL': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'MAIL': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:CONSOLE': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:SYSLOG': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'LOCAL0': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'oc-log:AUTH': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'NTP': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'LOCAL5': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'LOCAL4': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'LOCAL7': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'LOCAL6': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'LOCAL1': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'AUTHPRIV': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'LOCAL3': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}, u'LOCAL2': {u'@namespace': u'http://openconfig.net/yang/system/logging', u'@module': u'openconfig-system-logging'}},), is_leaf=True, yang_name="facility", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='identityref', is_config=False)


  def _get_severity(self):
    """
    Getter method for severity, mapped from YANG variable /access_points/access_point/system/logging/remote_servers/remote_server/selectors/selector/state/severity (syslog-severity)

    YANG Description: Specifies that only messages of the given severity (or
greater severity) for the corresonding facility are logged
    """
    return self.__severity
      
  def _set_severity(self, v, load=False):
    """
    Setter method for severity, mapped from YANG variable /access_points/access_point/system/logging/remote_servers/remote_server/selectors/selector/state/severity (syslog-severity)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_severity is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_severity() directly.

    YANG Description: Specifies that only messages of the given severity (or
greater severity) for the corresonding facility are logged
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'NOTICE': {}, u'WARNING': {}, u'EMERGENCY': {}, u'ALERT': {}, u'CRITICAL': {}, u'ERROR': {}, u'DEBUG': {}, u'INFORMATIONAL': {}},), is_leaf=True, yang_name="severity", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='syslog-severity', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """severity must be of a type compatible with syslog-severity""",
          'defined-type': "openconfig-access-points:syslog-severity",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'NOTICE': {}, u'WARNING': {}, u'EMERGENCY': {}, u'ALERT': {}, u'CRITICAL': {}, u'ERROR': {}, u'DEBUG': {}, u'INFORMATIONAL': {}},), is_leaf=True, yang_name="severity", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='syslog-severity', is_config=False)""",
        })

    self.__severity = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_severity(self):
    self.__severity = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'NOTICE': {}, u'WARNING': {}, u'EMERGENCY': {}, u'ALERT': {}, u'CRITICAL': {}, u'ERROR': {}, u'DEBUG': {}, u'INFORMATIONAL': {}},), is_leaf=True, yang_name="severity", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='syslog-severity', is_config=False)

  facility = __builtin__.property(_get_facility)
  severity = __builtin__.property(_get_severity)


  _pyangbind_elements = OrderedDict([('facility', facility), ('severity', severity), ])


class yc_selector_openconfig_access_points__access_points_access_point_system_logging_remote_servers_remote_server_selectors_selector(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-access-points - based on the path /access-points/access-point/system/logging/remote-servers/remote-server/selectors/selector. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of selectors for log messages
  """
  __slots__ = ('_path_helper', '_extmethods', '__facility','__severity','__config','__state',)

  _yang_name = 'selector'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__state = YANGDynClass(base=yc_state_openconfig_access_points__access_points_access_point_system_logging_remote_servers_remote_server_selectors_selector_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)
    self.__config = YANGDynClass(base=yc_config_openconfig_access_points__access_points_access_point_system_logging_remote_servers_remote_server_selectors_selector_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)
    self.__severity = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="severity", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='leafref', is_config=True)
    self.__facility = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="facility", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='leafref', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'access-points', u'access-point', u'system', u'logging', u'remote-servers', u'remote-server', u'selectors', u'selector']

  def _get_facility(self):
    """
    Getter method for facility, mapped from YANG variable /access_points/access_point/system/logging/remote_servers/remote_server/selectors/selector/facility (leafref)

    YANG Description: Reference to facility list key
    """
    return self.__facility
      
  def _set_facility(self, v, load=False):
    """
    Setter method for facility, mapped from YANG variable /access_points/access_point/system/logging/remote_servers/remote_server/selectors/selector/facility (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_facility is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_facility() directly.

    YANG Description: Reference to facility list key
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="facility", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """facility must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="facility", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='leafref', is_config=True)""",
        })

    self.__facility = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_facility(self):
    self.__facility = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="facility", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='leafref', is_config=True)


  def _get_severity(self):
    """
    Getter method for severity, mapped from YANG variable /access_points/access_point/system/logging/remote_servers/remote_server/selectors/selector/severity (leafref)

    YANG Description: Reference to severity list key
    """
    return self.__severity
      
  def _set_severity(self, v, load=False):
    """
    Setter method for severity, mapped from YANG variable /access_points/access_point/system/logging/remote_servers/remote_server/selectors/selector/severity (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_severity is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_severity() directly.

    YANG Description: Reference to severity list key
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="severity", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """severity must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="severity", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='leafref', is_config=True)""",
        })

    self.__severity = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_severity(self):
    self.__severity = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="severity", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='leafref', is_config=True)


  def _get_config(self):
    """
    Getter method for config, mapped from YANG variable /access_points/access_point/system/logging/remote_servers/remote_server/selectors/selector/config (container)

    YANG Description: Configuration data 
    """
    return self.__config
      
  def _set_config(self, v, load=False):
    """
    Setter method for config, mapped from YANG variable /access_points/access_point/system/logging/remote_servers/remote_server/selectors/selector/config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config() directly.

    YANG Description: Configuration data 
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_config_openconfig_access_points__access_points_access_point_system_logging_remote_servers_remote_server_selectors_selector_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_config_openconfig_access_points__access_points_access_point_system_logging_remote_servers_remote_server_selectors_selector_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)""",
        })

    self.__config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config(self):
    self.__config = YANGDynClass(base=yc_config_openconfig_access_points__access_points_access_point_system_logging_remote_servers_remote_server_selectors_selector_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /access_points/access_point/system/logging/remote_servers/remote_server/selectors/selector/state (container)

    YANG Description: Operational state data 
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /access_points/access_point/system/logging/remote_servers/remote_server/selectors/selector/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: Operational state data 
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_access_points__access_points_access_point_system_logging_remote_servers_remote_server_selectors_selector_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_access_points__access_points_access_point_system_logging_remote_servers_remote_server_selectors_selector_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_access_points__access_points_access_point_system_logging_remote_servers_remote_server_selectors_selector_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)

  facility = __builtin__.property(_get_facility, _set_facility)
  severity = __builtin__.property(_get_severity, _set_severity)
  config = __builtin__.property(_get_config, _set_config)
  state = __builtin__.property(_get_state, _set_state)


  _pyangbind_elements = OrderedDict([('facility', facility), ('severity', severity), ('config', config), ('state', state), ])


class yc_selectors_openconfig_access_points__access_points_access_point_system_logging_remote_servers_remote_server_selectors(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-access-points - based on the path /access-points/access-point/system/logging/remote-servers/remote-server/selectors. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Enclosing container 
  """
  __slots__ = ('_path_helper', '_extmethods', '__selector',)

  _yang_name = 'selectors'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__selector = YANGDynClass(base=YANGListType("facility severity",yc_selector_openconfig_access_points__access_points_access_point_system_logging_remote_servers_remote_server_selectors_selector, yang_name="selector", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='facility severity', extensions=None), is_container='list', yang_name="selector", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'access-points', u'access-point', u'system', u'logging', u'remote-servers', u'remote-server', u'selectors']

  def _get_selector(self):
    """
    Getter method for selector, mapped from YANG variable /access_points/access_point/system/logging/remote_servers/remote_server/selectors/selector (list)

    YANG Description: List of selectors for log messages
    """
    return self.__selector
      
  def _set_selector(self, v, load=False):
    """
    Setter method for selector, mapped from YANG variable /access_points/access_point/system/logging/remote_servers/remote_server/selectors/selector (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_selector is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_selector() directly.

    YANG Description: List of selectors for log messages
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("facility severity",yc_selector_openconfig_access_points__access_points_access_point_system_logging_remote_servers_remote_server_selectors_selector, yang_name="selector", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='facility severity', extensions=None), is_container='list', yang_name="selector", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """selector must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("facility severity",yc_selector_openconfig_access_points__access_points_access_point_system_logging_remote_servers_remote_server_selectors_selector, yang_name="selector", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='facility severity', extensions=None), is_container='list', yang_name="selector", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='list', is_config=True)""",
        })

    self.__selector = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_selector(self):
    self.__selector = YANGDynClass(base=YANGListType("facility severity",yc_selector_openconfig_access_points__access_points_access_point_system_logging_remote_servers_remote_server_selectors_selector, yang_name="selector", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='facility severity', extensions=None), is_container='list', yang_name="selector", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='list', is_config=True)

  selector = __builtin__.property(_get_selector, _set_selector)


  _pyangbind_elements = OrderedDict([('selector', selector), ])


class yc_remote_server_openconfig_access_points__access_points_access_point_system_logging_remote_servers_remote_server(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-access-points - based on the path /access-points/access-point/system/logging/remote-servers/remote-server. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of remote log servers
  """
  __slots__ = ('_path_helper', '_extmethods', '__host','__config','__state','__selectors',)

  _yang_name = 'remote-server'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__host = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="host", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='leafref', is_config=True)
    self.__config = YANGDynClass(base=yc_config_openconfig_access_points__access_points_access_point_system_logging_remote_servers_remote_server_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)
    self.__state = YANGDynClass(base=yc_state_openconfig_access_points__access_points_access_point_system_logging_remote_servers_remote_server_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)
    self.__selectors = YANGDynClass(base=yc_selectors_openconfig_access_points__access_points_access_point_system_logging_remote_servers_remote_server_selectors, is_container='container', yang_name="selectors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'access-points', u'access-point', u'system', u'logging', u'remote-servers', u'remote-server']

  def _get_host(self):
    """
    Getter method for host, mapped from YANG variable /access_points/access_point/system/logging/remote_servers/remote_server/host (leafref)

    YANG Description: Reference to the host list key
    """
    return self.__host
      
  def _set_host(self, v, load=False):
    """
    Setter method for host, mapped from YANG variable /access_points/access_point/system/logging/remote_servers/remote_server/host (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_host is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_host() directly.

    YANG Description: Reference to the host list key
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="host", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """host must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="host", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='leafref', is_config=True)""",
        })

    self.__host = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_host(self):
    self.__host = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="host", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='leafref', is_config=True)


  def _get_config(self):
    """
    Getter method for config, mapped from YANG variable /access_points/access_point/system/logging/remote_servers/remote_server/config (container)

    YANG Description: Configuration data for remote log servers
    """
    return self.__config
      
  def _set_config(self, v, load=False):
    """
    Setter method for config, mapped from YANG variable /access_points/access_point/system/logging/remote_servers/remote_server/config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config() directly.

    YANG Description: Configuration data for remote log servers
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_config_openconfig_access_points__access_points_access_point_system_logging_remote_servers_remote_server_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_config_openconfig_access_points__access_points_access_point_system_logging_remote_servers_remote_server_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)""",
        })

    self.__config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config(self):
    self.__config = YANGDynClass(base=yc_config_openconfig_access_points__access_points_access_point_system_logging_remote_servers_remote_server_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /access_points/access_point/system/logging/remote_servers/remote_server/state (container)

    YANG Description: Operational state data for remote log servers
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /access_points/access_point/system/logging/remote_servers/remote_server/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: Operational state data for remote log servers
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_access_points__access_points_access_point_system_logging_remote_servers_remote_server_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_access_points__access_points_access_point_system_logging_remote_servers_remote_server_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_access_points__access_points_access_point_system_logging_remote_servers_remote_server_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)


  def _get_selectors(self):
    """
    Getter method for selectors, mapped from YANG variable /access_points/access_point/system/logging/remote_servers/remote_server/selectors (container)

    YANG Description: Enclosing container 
    """
    return self.__selectors
      
  def _set_selectors(self, v, load=False):
    """
    Setter method for selectors, mapped from YANG variable /access_points/access_point/system/logging/remote_servers/remote_server/selectors (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_selectors is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_selectors() directly.

    YANG Description: Enclosing container 
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_selectors_openconfig_access_points__access_points_access_point_system_logging_remote_servers_remote_server_selectors, is_container='container', yang_name="selectors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """selectors must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_selectors_openconfig_access_points__access_points_access_point_system_logging_remote_servers_remote_server_selectors, is_container='container', yang_name="selectors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)""",
        })

    self.__selectors = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_selectors(self):
    self.__selectors = YANGDynClass(base=yc_selectors_openconfig_access_points__access_points_access_point_system_logging_remote_servers_remote_server_selectors, is_container='container', yang_name="selectors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)

  host = __builtin__.property(_get_host, _set_host)
  config = __builtin__.property(_get_config, _set_config)
  state = __builtin__.property(_get_state, _set_state)
  selectors = __builtin__.property(_get_selectors, _set_selectors)


  _pyangbind_elements = OrderedDict([('host', host), ('config', config), ('state', state), ('selectors', selectors), ])


class yc_remote_servers_openconfig_access_points__access_points_access_point_system_logging_remote_servers(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-access-points - based on the path /access-points/access-point/system/logging/remote-servers. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Enclosing container for the list of remote log servers
  """
  __slots__ = ('_path_helper', '_extmethods', '__remote_server',)

  _yang_name = 'remote-servers'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__remote_server = YANGDynClass(base=YANGListType("host",yc_remote_server_openconfig_access_points__access_points_access_point_system_logging_remote_servers_remote_server, yang_name="remote-server", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='host', extensions=None), is_container='list', yang_name="remote-server", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'access-points', u'access-point', u'system', u'logging', u'remote-servers']

  def _get_remote_server(self):
    """
    Getter method for remote_server, mapped from YANG variable /access_points/access_point/system/logging/remote_servers/remote_server (list)

    YANG Description: List of remote log servers
    """
    return self.__remote_server
      
  def _set_remote_server(self, v, load=False):
    """
    Setter method for remote_server, mapped from YANG variable /access_points/access_point/system/logging/remote_servers/remote_server (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_remote_server is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_remote_server() directly.

    YANG Description: List of remote log servers
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("host",yc_remote_server_openconfig_access_points__access_points_access_point_system_logging_remote_servers_remote_server, yang_name="remote-server", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='host', extensions=None), is_container='list', yang_name="remote-server", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """remote_server must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("host",yc_remote_server_openconfig_access_points__access_points_access_point_system_logging_remote_servers_remote_server, yang_name="remote-server", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='host', extensions=None), is_container='list', yang_name="remote-server", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='list', is_config=True)""",
        })

    self.__remote_server = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_remote_server(self):
    self.__remote_server = YANGDynClass(base=YANGListType("host",yc_remote_server_openconfig_access_points__access_points_access_point_system_logging_remote_servers_remote_server, yang_name="remote-server", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='host', extensions=None), is_container='list', yang_name="remote-server", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='list', is_config=True)

  remote_server = __builtin__.property(_get_remote_server, _set_remote_server)


  _pyangbind_elements = OrderedDict([('remote_server', remote_server), ])


class yc_logging_openconfig_access_points__access_points_access_point_system_logging(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-access-points - based on the path /access-points/access-point/system/logging. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Top-level container for data related to logging / syslog
  """
  __slots__ = ('_path_helper', '_extmethods', '__console','__remote_servers',)

  _yang_name = 'logging'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__console = YANGDynClass(base=yc_console_openconfig_access_points__access_points_access_point_system_logging_console, is_container='container', yang_name="console", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)
    self.__remote_servers = YANGDynClass(base=yc_remote_servers_openconfig_access_points__access_points_access_point_system_logging_remote_servers, is_container='container', yang_name="remote-servers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'access-points', u'access-point', u'system', u'logging']

  def _get_console(self):
    """
    Getter method for console, mapped from YANG variable /access_points/access_point/system/logging/console (container)

    YANG Description: Top-level container for data related to console-based
logging
    """
    return self.__console
      
  def _set_console(self, v, load=False):
    """
    Setter method for console, mapped from YANG variable /access_points/access_point/system/logging/console (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_console is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_console() directly.

    YANG Description: Top-level container for data related to console-based
logging
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_console_openconfig_access_points__access_points_access_point_system_logging_console, is_container='container', yang_name="console", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """console must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_console_openconfig_access_points__access_points_access_point_system_logging_console, is_container='container', yang_name="console", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)""",
        })

    self.__console = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_console(self):
    self.__console = YANGDynClass(base=yc_console_openconfig_access_points__access_points_access_point_system_logging_console, is_container='container', yang_name="console", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)


  def _get_remote_servers(self):
    """
    Getter method for remote_servers, mapped from YANG variable /access_points/access_point/system/logging/remote_servers (container)

    YANG Description: Enclosing container for the list of remote log servers
    """
    return self.__remote_servers
      
  def _set_remote_servers(self, v, load=False):
    """
    Setter method for remote_servers, mapped from YANG variable /access_points/access_point/system/logging/remote_servers (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_remote_servers is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_remote_servers() directly.

    YANG Description: Enclosing container for the list of remote log servers
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_remote_servers_openconfig_access_points__access_points_access_point_system_logging_remote_servers, is_container='container', yang_name="remote-servers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """remote_servers must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_remote_servers_openconfig_access_points__access_points_access_point_system_logging_remote_servers, is_container='container', yang_name="remote-servers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)""",
        })

    self.__remote_servers = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_remote_servers(self):
    self.__remote_servers = YANGDynClass(base=yc_remote_servers_openconfig_access_points__access_points_access_point_system_logging_remote_servers, is_container='container', yang_name="remote-servers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)

  console = __builtin__.property(_get_console, _set_console)
  remote_servers = __builtin__.property(_get_remote_servers, _set_remote_servers)


  _pyangbind_elements = OrderedDict([('console', console), ('remote_servers', remote_servers), ])


class yc_config_openconfig_access_points__access_points_access_point_system_aaa_authentication_config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-access-points - based on the path /access-points/access-point/system/aaa/authentication/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration data for global authentication services
  """
  __slots__ = ('_path_helper', '_extmethods', '__authentication_method',)

  _yang_name = 'config'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__authentication_method = YANGDynClass(unique=True, base=TypedListType(allowed_type=[RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'RADIUS_ALL': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}, u'oc-aaa-types:LOCAL': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}, u'oc-aaa-types:TACACS_ALL': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}, u'oc-aaa-types:RADIUS_ALL': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}, u'LOCAL': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}, u'TACACS_ALL': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}},),six.text_type,]), is_leaf=False, yang_name="authentication-method", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='union', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'access-points', u'access-point', u'system', u'aaa', u'authentication', u'config']

  def _get_authentication_method(self):
    """
    Getter method for authentication_method, mapped from YANG variable /access_points/access_point/system/aaa/authentication/config/authentication_method (union)

    YANG Description: Ordered list of authentication methods for users.  This
can be either a reference to a server group, or a well-
defined designation in the AAA_METHOD_TYPE identity.  If
authentication fails with one method, the next defined
method is tried -- failure of all methods results in the
user being denied access.
    """
    return self.__authentication_method
      
  def _set_authentication_method(self, v, load=False):
    """
    Setter method for authentication_method, mapped from YANG variable /access_points/access_point/system/aaa/authentication/config/authentication_method (union)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_authentication_method is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_authentication_method() directly.

    YANG Description: Ordered list of authentication methods for users.  This
can be either a reference to a server group, or a well-
defined designation in the AAA_METHOD_TYPE identity.  If
authentication fails with one method, the next defined
method is tried -- failure of all methods results in the
user being denied access.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=[RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'RADIUS_ALL': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}, u'oc-aaa-types:LOCAL': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}, u'oc-aaa-types:TACACS_ALL': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}, u'oc-aaa-types:RADIUS_ALL': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}, u'LOCAL': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}, u'TACACS_ALL': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}},),six.text_type,]), is_leaf=False, yang_name="authentication-method", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='union', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """authentication_method must be of a type compatible with union""",
          'defined-type': "openconfig-access-points:union",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=[RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'RADIUS_ALL': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}, u'oc-aaa-types:LOCAL': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}, u'oc-aaa-types:TACACS_ALL': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}, u'oc-aaa-types:RADIUS_ALL': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}, u'LOCAL': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}, u'TACACS_ALL': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}},),six.text_type,]), is_leaf=False, yang_name="authentication-method", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='union', is_config=True)""",
        })

    self.__authentication_method = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_authentication_method(self):
    self.__authentication_method = YANGDynClass(unique=True, base=TypedListType(allowed_type=[RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'RADIUS_ALL': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}, u'oc-aaa-types:LOCAL': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}, u'oc-aaa-types:TACACS_ALL': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}, u'oc-aaa-types:RADIUS_ALL': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}, u'LOCAL': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}, u'TACACS_ALL': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}},),six.text_type,]), is_leaf=False, yang_name="authentication-method", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='union', is_config=True)

  authentication_method = __builtin__.property(_get_authentication_method, _set_authentication_method)


  _pyangbind_elements = OrderedDict([('authentication_method', authentication_method), ])


class yc_state_openconfig_access_points__access_points_access_point_system_aaa_authentication_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-access-points - based on the path /access-points/access-point/system/aaa/authentication/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Operational state data for global authentication
services
  """
  __slots__ = ('_path_helper', '_extmethods', '__authentication_method',)

  _yang_name = 'state'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__authentication_method = YANGDynClass(unique=True, base=TypedListType(allowed_type=[RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'RADIUS_ALL': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}, u'oc-aaa-types:LOCAL': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}, u'oc-aaa-types:TACACS_ALL': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}, u'oc-aaa-types:RADIUS_ALL': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}, u'LOCAL': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}, u'TACACS_ALL': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}},),six.text_type,]), is_leaf=False, yang_name="authentication-method", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='union', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'access-points', u'access-point', u'system', u'aaa', u'authentication', u'state']

  def _get_authentication_method(self):
    """
    Getter method for authentication_method, mapped from YANG variable /access_points/access_point/system/aaa/authentication/state/authentication_method (union)

    YANG Description: Ordered list of authentication methods for users.  This
can be either a reference to a server group, or a well-
defined designation in the AAA_METHOD_TYPE identity.  If
authentication fails with one method, the next defined
method is tried -- failure of all methods results in the
user being denied access.
    """
    return self.__authentication_method
      
  def _set_authentication_method(self, v, load=False):
    """
    Setter method for authentication_method, mapped from YANG variable /access_points/access_point/system/aaa/authentication/state/authentication_method (union)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_authentication_method is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_authentication_method() directly.

    YANG Description: Ordered list of authentication methods for users.  This
can be either a reference to a server group, or a well-
defined designation in the AAA_METHOD_TYPE identity.  If
authentication fails with one method, the next defined
method is tried -- failure of all methods results in the
user being denied access.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=[RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'RADIUS_ALL': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}, u'oc-aaa-types:LOCAL': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}, u'oc-aaa-types:TACACS_ALL': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}, u'oc-aaa-types:RADIUS_ALL': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}, u'LOCAL': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}, u'TACACS_ALL': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}},),six.text_type,]), is_leaf=False, yang_name="authentication-method", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='union', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """authentication_method must be of a type compatible with union""",
          'defined-type': "openconfig-access-points:union",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=[RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'RADIUS_ALL': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}, u'oc-aaa-types:LOCAL': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}, u'oc-aaa-types:TACACS_ALL': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}, u'oc-aaa-types:RADIUS_ALL': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}, u'LOCAL': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}, u'TACACS_ALL': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}},),six.text_type,]), is_leaf=False, yang_name="authentication-method", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='union', is_config=False)""",
        })

    self.__authentication_method = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_authentication_method(self):
    self.__authentication_method = YANGDynClass(unique=True, base=TypedListType(allowed_type=[RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'RADIUS_ALL': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}, u'oc-aaa-types:LOCAL': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}, u'oc-aaa-types:TACACS_ALL': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}, u'oc-aaa-types:RADIUS_ALL': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}, u'LOCAL': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}, u'TACACS_ALL': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}},),six.text_type,]), is_leaf=False, yang_name="authentication-method", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='union', is_config=False)

  authentication_method = __builtin__.property(_get_authentication_method)


  _pyangbind_elements = OrderedDict([('authentication_method', authentication_method), ])


class yc_config_openconfig_access_points__access_points_access_point_system_aaa_authentication_admin_user_config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-access-points - based on the path /access-points/access-point/system/aaa/authentication/admin-user/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration data for the root user account
  """
  __slots__ = ('_path_helper', '_extmethods', '__admin_password','__admin_password_hashed',)

  _yang_name = 'config'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__admin_password_hashed = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="admin-password-hashed", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-aaa-types:crypt-password-type', is_config=True)
    self.__admin_password = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="admin-password", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'access-points', u'access-point', u'system', u'aaa', u'authentication', u'admin-user', u'config']

  def _get_admin_password(self):
    """
    Getter method for admin_password, mapped from YANG variable /access_points/access_point/system/aaa/authentication/admin_user/config/admin_password (string)

    YANG Description: The admin/root password, supplied as a cleartext string.
The system should hash and only store the password as a
hashed value.
    """
    return self.__admin_password
      
  def _set_admin_password(self, v, load=False):
    """
    Setter method for admin_password, mapped from YANG variable /access_points/access_point/system/aaa/authentication/admin_user/config/admin_password (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_admin_password is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_admin_password() directly.

    YANG Description: The admin/root password, supplied as a cleartext string.
The system should hash and only store the password as a
hashed value.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="admin-password", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """admin_password must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="admin-password", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='string', is_config=True)""",
        })

    self.__admin_password = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_admin_password(self):
    self.__admin_password = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="admin-password", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='string', is_config=True)


  def _get_admin_password_hashed(self):
    """
    Getter method for admin_password_hashed, mapped from YANG variable /access_points/access_point/system/aaa/authentication/admin_user/config/admin_password_hashed (oc-aaa-types:crypt-password-type)

    YANG Description: The admin/root password, supplied as a hashed value
using the notation described in the definition of the
crypt-password-type.
    """
    return self.__admin_password_hashed
      
  def _set_admin_password_hashed(self, v, load=False):
    """
    Setter method for admin_password_hashed, mapped from YANG variable /access_points/access_point/system/aaa/authentication/admin_user/config/admin_password_hashed (oc-aaa-types:crypt-password-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_admin_password_hashed is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_admin_password_hashed() directly.

    YANG Description: The admin/root password, supplied as a hashed value
using the notation described in the definition of the
crypt-password-type.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="admin-password-hashed", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-aaa-types:crypt-password-type', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """admin_password_hashed must be of a type compatible with oc-aaa-types:crypt-password-type""",
          'defined-type': "oc-aaa-types:crypt-password-type",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="admin-password-hashed", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-aaa-types:crypt-password-type', is_config=True)""",
        })

    self.__admin_password_hashed = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_admin_password_hashed(self):
    self.__admin_password_hashed = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="admin-password-hashed", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-aaa-types:crypt-password-type', is_config=True)

  admin_password = __builtin__.property(_get_admin_password, _set_admin_password)
  admin_password_hashed = __builtin__.property(_get_admin_password_hashed, _set_admin_password_hashed)


  _pyangbind_elements = OrderedDict([('admin_password', admin_password), ('admin_password_hashed', admin_password_hashed), ])


class yc_state_openconfig_access_points__access_points_access_point_system_aaa_authentication_admin_user_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-access-points - based on the path /access-points/access-point/system/aaa/authentication/admin-user/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Operational state data for the root user account
  """
  __slots__ = ('_path_helper', '_extmethods', '__admin_password','__admin_password_hashed','__admin_username',)

  _yang_name = 'state'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__admin_password_hashed = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="admin-password-hashed", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-aaa-types:crypt-password-type', is_config=False)
    self.__admin_password = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="admin-password", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='string', is_config=False)
    self.__admin_username = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="admin-username", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='string', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'access-points', u'access-point', u'system', u'aaa', u'authentication', u'admin-user', u'state']

  def _get_admin_password(self):
    """
    Getter method for admin_password, mapped from YANG variable /access_points/access_point/system/aaa/authentication/admin_user/state/admin_password (string)

    YANG Description: The admin/root password, supplied as a cleartext string.
The system should hash and only store the password as a
hashed value.
    """
    return self.__admin_password
      
  def _set_admin_password(self, v, load=False):
    """
    Setter method for admin_password, mapped from YANG variable /access_points/access_point/system/aaa/authentication/admin_user/state/admin_password (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_admin_password is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_admin_password() directly.

    YANG Description: The admin/root password, supplied as a cleartext string.
The system should hash and only store the password as a
hashed value.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="admin-password", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """admin_password must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="admin-password", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='string', is_config=False)""",
        })

    self.__admin_password = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_admin_password(self):
    self.__admin_password = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="admin-password", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='string', is_config=False)


  def _get_admin_password_hashed(self):
    """
    Getter method for admin_password_hashed, mapped from YANG variable /access_points/access_point/system/aaa/authentication/admin_user/state/admin_password_hashed (oc-aaa-types:crypt-password-type)

    YANG Description: The admin/root password, supplied as a hashed value
using the notation described in the definition of the
crypt-password-type.
    """
    return self.__admin_password_hashed
      
  def _set_admin_password_hashed(self, v, load=False):
    """
    Setter method for admin_password_hashed, mapped from YANG variable /access_points/access_point/system/aaa/authentication/admin_user/state/admin_password_hashed (oc-aaa-types:crypt-password-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_admin_password_hashed is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_admin_password_hashed() directly.

    YANG Description: The admin/root password, supplied as a hashed value
using the notation described in the definition of the
crypt-password-type.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="admin-password-hashed", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-aaa-types:crypt-password-type', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """admin_password_hashed must be of a type compatible with oc-aaa-types:crypt-password-type""",
          'defined-type': "oc-aaa-types:crypt-password-type",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="admin-password-hashed", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-aaa-types:crypt-password-type', is_config=False)""",
        })

    self.__admin_password_hashed = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_admin_password_hashed(self):
    self.__admin_password_hashed = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="admin-password-hashed", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-aaa-types:crypt-password-type', is_config=False)


  def _get_admin_username(self):
    """
    Getter method for admin_username, mapped from YANG variable /access_points/access_point/system/aaa/authentication/admin_user/state/admin_username (string)

    YANG Description: Name of the administrator user account, e.g., admin, root,
etc.
    """
    return self.__admin_username
      
  def _set_admin_username(self, v, load=False):
    """
    Setter method for admin_username, mapped from YANG variable /access_points/access_point/system/aaa/authentication/admin_user/state/admin_username (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_admin_username is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_admin_username() directly.

    YANG Description: Name of the administrator user account, e.g., admin, root,
etc.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="admin-username", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """admin_username must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="admin-username", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='string', is_config=False)""",
        })

    self.__admin_username = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_admin_username(self):
    self.__admin_username = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="admin-username", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='string', is_config=False)

  admin_password = __builtin__.property(_get_admin_password)
  admin_password_hashed = __builtin__.property(_get_admin_password_hashed)
  admin_username = __builtin__.property(_get_admin_username)


  _pyangbind_elements = OrderedDict([('admin_password', admin_password), ('admin_password_hashed', admin_password_hashed), ('admin_username', admin_username), ])


class yc_admin_user_openconfig_access_points__access_points_access_point_system_aaa_authentication_admin_user(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-access-points - based on the path /access-points/access-point/system/aaa/authentication/admin-user. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Top-level container for the system root or admin user
configuration and operational state
  """
  __slots__ = ('_path_helper', '_extmethods', '__config','__state',)

  _yang_name = 'admin-user'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__state = YANGDynClass(base=yc_state_openconfig_access_points__access_points_access_point_system_aaa_authentication_admin_user_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)
    self.__config = YANGDynClass(base=yc_config_openconfig_access_points__access_points_access_point_system_aaa_authentication_admin_user_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'access-points', u'access-point', u'system', u'aaa', u'authentication', u'admin-user']

  def _get_config(self):
    """
    Getter method for config, mapped from YANG variable /access_points/access_point/system/aaa/authentication/admin_user/config (container)

    YANG Description: Configuration data for the root user account
    """
    return self.__config
      
  def _set_config(self, v, load=False):
    """
    Setter method for config, mapped from YANG variable /access_points/access_point/system/aaa/authentication/admin_user/config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config() directly.

    YANG Description: Configuration data for the root user account
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_config_openconfig_access_points__access_points_access_point_system_aaa_authentication_admin_user_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_config_openconfig_access_points__access_points_access_point_system_aaa_authentication_admin_user_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)""",
        })

    self.__config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config(self):
    self.__config = YANGDynClass(base=yc_config_openconfig_access_points__access_points_access_point_system_aaa_authentication_admin_user_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /access_points/access_point/system/aaa/authentication/admin_user/state (container)

    YANG Description: Operational state data for the root user account
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /access_points/access_point/system/aaa/authentication/admin_user/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: Operational state data for the root user account
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_access_points__access_points_access_point_system_aaa_authentication_admin_user_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_access_points__access_points_access_point_system_aaa_authentication_admin_user_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_access_points__access_points_access_point_system_aaa_authentication_admin_user_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)

  config = __builtin__.property(_get_config, _set_config)
  state = __builtin__.property(_get_state, _set_state)


  _pyangbind_elements = OrderedDict([('config', config), ('state', state), ])


class yc_config_openconfig_access_points__access_points_access_point_system_aaa_authentication_users_user_config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-access-points - based on the path /access-points/access-point/system/aaa/authentication/users/user/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration data for local users
  """
  __slots__ = ('_path_helper', '_extmethods', '__username','__password','__password_hashed','__ssh_key','__role',)

  _yang_name = 'config'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__username = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="username", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='string', is_config=True)
    self.__password_hashed = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="password-hashed", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-aaa-types:crypt-password-type', is_config=True)
    self.__password = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="password", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='string', is_config=True)
    self.__role = YANGDynClass(base=[six.text_type,RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'SYSTEM_ROLE_ADMIN': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}, u'oc-aaa-types:SYSTEM_ROLE_ADMIN': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}},),], is_leaf=True, yang_name="role", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='union', is_config=True)
    self.__ssh_key = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ssh-key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'access-points', u'access-point', u'system', u'aaa', u'authentication', u'users', u'user', u'config']

  def _get_username(self):
    """
    Getter method for username, mapped from YANG variable /access_points/access_point/system/aaa/authentication/users/user/config/username (string)

    YANG Description: Assigned username for this user
    """
    return self.__username
      
  def _set_username(self, v, load=False):
    """
    Setter method for username, mapped from YANG variable /access_points/access_point/system/aaa/authentication/users/user/config/username (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_username is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_username() directly.

    YANG Description: Assigned username for this user
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="username", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """username must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="username", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='string', is_config=True)""",
        })

    self.__username = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_username(self):
    self.__username = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="username", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='string', is_config=True)


  def _get_password(self):
    """
    Getter method for password, mapped from YANG variable /access_points/access_point/system/aaa/authentication/users/user/config/password (string)

    YANG Description: The user password, supplied as cleartext.  The system
must hash the value and only store the hashed value.
    """
    return self.__password
      
  def _set_password(self, v, load=False):
    """
    Setter method for password, mapped from YANG variable /access_points/access_point/system/aaa/authentication/users/user/config/password (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_password is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_password() directly.

    YANG Description: The user password, supplied as cleartext.  The system
must hash the value and only store the hashed value.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="password", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """password must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="password", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='string', is_config=True)""",
        })

    self.__password = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_password(self):
    self.__password = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="password", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='string', is_config=True)


  def _get_password_hashed(self):
    """
    Getter method for password_hashed, mapped from YANG variable /access_points/access_point/system/aaa/authentication/users/user/config/password_hashed (oc-aaa-types:crypt-password-type)

    YANG Description: The user password, supplied as a hashed value
using the notation described in the definition of the
crypt-password-type.
    """
    return self.__password_hashed
      
  def _set_password_hashed(self, v, load=False):
    """
    Setter method for password_hashed, mapped from YANG variable /access_points/access_point/system/aaa/authentication/users/user/config/password_hashed (oc-aaa-types:crypt-password-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_password_hashed is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_password_hashed() directly.

    YANG Description: The user password, supplied as a hashed value
using the notation described in the definition of the
crypt-password-type.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="password-hashed", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-aaa-types:crypt-password-type', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """password_hashed must be of a type compatible with oc-aaa-types:crypt-password-type""",
          'defined-type': "oc-aaa-types:crypt-password-type",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="password-hashed", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-aaa-types:crypt-password-type', is_config=True)""",
        })

    self.__password_hashed = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_password_hashed(self):
    self.__password_hashed = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="password-hashed", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-aaa-types:crypt-password-type', is_config=True)


  def _get_ssh_key(self):
    """
    Getter method for ssh_key, mapped from YANG variable /access_points/access_point/system/aaa/authentication/users/user/config/ssh_key (string)

    YANG Description: SSH public key for the user (RSA or DSA)
    """
    return self.__ssh_key
      
  def _set_ssh_key(self, v, load=False):
    """
    Setter method for ssh_key, mapped from YANG variable /access_points/access_point/system/aaa/authentication/users/user/config/ssh_key (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ssh_key is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ssh_key() directly.

    YANG Description: SSH public key for the user (RSA or DSA)
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="ssh-key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ssh_key must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ssh-key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='string', is_config=True)""",
        })

    self.__ssh_key = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ssh_key(self):
    self.__ssh_key = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ssh-key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='string', is_config=True)


  def _get_role(self):
    """
    Getter method for role, mapped from YANG variable /access_points/access_point/system/aaa/authentication/users/user/config/role (union)

    YANG Description: Role assigned to the user.  The role may be supplied
as a string or a role defined by the SYSTEM_DEFINED_ROLES
identity.
    """
    return self.__role
      
  def _set_role(self, v, load=False):
    """
    Setter method for role, mapped from YANG variable /access_points/access_point/system/aaa/authentication/users/user/config/role (union)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_role is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_role() directly.

    YANG Description: Role assigned to the user.  The role may be supplied
as a string or a role defined by the SYSTEM_DEFINED_ROLES
identity.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=[six.text_type,RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'SYSTEM_ROLE_ADMIN': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}, u'oc-aaa-types:SYSTEM_ROLE_ADMIN': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}},),], is_leaf=True, yang_name="role", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='union', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """role must be of a type compatible with union""",
          'defined-type': "openconfig-access-points:union",
          'generated-type': """YANGDynClass(base=[six.text_type,RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'SYSTEM_ROLE_ADMIN': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}, u'oc-aaa-types:SYSTEM_ROLE_ADMIN': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}},),], is_leaf=True, yang_name="role", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='union', is_config=True)""",
        })

    self.__role = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_role(self):
    self.__role = YANGDynClass(base=[six.text_type,RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'SYSTEM_ROLE_ADMIN': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}, u'oc-aaa-types:SYSTEM_ROLE_ADMIN': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}},),], is_leaf=True, yang_name="role", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='union', is_config=True)

  username = __builtin__.property(_get_username, _set_username)
  password = __builtin__.property(_get_password, _set_password)
  password_hashed = __builtin__.property(_get_password_hashed, _set_password_hashed)
  ssh_key = __builtin__.property(_get_ssh_key, _set_ssh_key)
  role = __builtin__.property(_get_role, _set_role)


  _pyangbind_elements = OrderedDict([('username', username), ('password', password), ('password_hashed', password_hashed), ('ssh_key', ssh_key), ('role', role), ])


class yc_state_openconfig_access_points__access_points_access_point_system_aaa_authentication_users_user_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-access-points - based on the path /access-points/access-point/system/aaa/authentication/users/user/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Operational state data for local users
  """
  __slots__ = ('_path_helper', '_extmethods', '__username','__password','__password_hashed','__ssh_key','__role',)

  _yang_name = 'state'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__username = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="username", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='string', is_config=False)
    self.__password_hashed = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="password-hashed", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-aaa-types:crypt-password-type', is_config=False)
    self.__password = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="password", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='string', is_config=False)
    self.__role = YANGDynClass(base=[six.text_type,RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'SYSTEM_ROLE_ADMIN': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}, u'oc-aaa-types:SYSTEM_ROLE_ADMIN': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}},),], is_leaf=True, yang_name="role", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='union', is_config=False)
    self.__ssh_key = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ssh-key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='string', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'access-points', u'access-point', u'system', u'aaa', u'authentication', u'users', u'user', u'state']

  def _get_username(self):
    """
    Getter method for username, mapped from YANG variable /access_points/access_point/system/aaa/authentication/users/user/state/username (string)

    YANG Description: Assigned username for this user
    """
    return self.__username
      
  def _set_username(self, v, load=False):
    """
    Setter method for username, mapped from YANG variable /access_points/access_point/system/aaa/authentication/users/user/state/username (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_username is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_username() directly.

    YANG Description: Assigned username for this user
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="username", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """username must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="username", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='string', is_config=False)""",
        })

    self.__username = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_username(self):
    self.__username = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="username", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='string', is_config=False)


  def _get_password(self):
    """
    Getter method for password, mapped from YANG variable /access_points/access_point/system/aaa/authentication/users/user/state/password (string)

    YANG Description: The user password, supplied as cleartext.  The system
must hash the value and only store the hashed value.
    """
    return self.__password
      
  def _set_password(self, v, load=False):
    """
    Setter method for password, mapped from YANG variable /access_points/access_point/system/aaa/authentication/users/user/state/password (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_password is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_password() directly.

    YANG Description: The user password, supplied as cleartext.  The system
must hash the value and only store the hashed value.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="password", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """password must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="password", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='string', is_config=False)""",
        })

    self.__password = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_password(self):
    self.__password = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="password", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='string', is_config=False)


  def _get_password_hashed(self):
    """
    Getter method for password_hashed, mapped from YANG variable /access_points/access_point/system/aaa/authentication/users/user/state/password_hashed (oc-aaa-types:crypt-password-type)

    YANG Description: The user password, supplied as a hashed value
using the notation described in the definition of the
crypt-password-type.
    """
    return self.__password_hashed
      
  def _set_password_hashed(self, v, load=False):
    """
    Setter method for password_hashed, mapped from YANG variable /access_points/access_point/system/aaa/authentication/users/user/state/password_hashed (oc-aaa-types:crypt-password-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_password_hashed is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_password_hashed() directly.

    YANG Description: The user password, supplied as a hashed value
using the notation described in the definition of the
crypt-password-type.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="password-hashed", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-aaa-types:crypt-password-type', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """password_hashed must be of a type compatible with oc-aaa-types:crypt-password-type""",
          'defined-type': "oc-aaa-types:crypt-password-type",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="password-hashed", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-aaa-types:crypt-password-type', is_config=False)""",
        })

    self.__password_hashed = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_password_hashed(self):
    self.__password_hashed = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="password-hashed", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-aaa-types:crypt-password-type', is_config=False)


  def _get_ssh_key(self):
    """
    Getter method for ssh_key, mapped from YANG variable /access_points/access_point/system/aaa/authentication/users/user/state/ssh_key (string)

    YANG Description: SSH public key for the user (RSA or DSA)
    """
    return self.__ssh_key
      
  def _set_ssh_key(self, v, load=False):
    """
    Setter method for ssh_key, mapped from YANG variable /access_points/access_point/system/aaa/authentication/users/user/state/ssh_key (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ssh_key is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ssh_key() directly.

    YANG Description: SSH public key for the user (RSA or DSA)
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="ssh-key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ssh_key must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ssh-key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='string', is_config=False)""",
        })

    self.__ssh_key = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ssh_key(self):
    self.__ssh_key = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ssh-key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='string', is_config=False)


  def _get_role(self):
    """
    Getter method for role, mapped from YANG variable /access_points/access_point/system/aaa/authentication/users/user/state/role (union)

    YANG Description: Role assigned to the user.  The role may be supplied
as a string or a role defined by the SYSTEM_DEFINED_ROLES
identity.
    """
    return self.__role
      
  def _set_role(self, v, load=False):
    """
    Setter method for role, mapped from YANG variable /access_points/access_point/system/aaa/authentication/users/user/state/role (union)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_role is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_role() directly.

    YANG Description: Role assigned to the user.  The role may be supplied
as a string or a role defined by the SYSTEM_DEFINED_ROLES
identity.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=[six.text_type,RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'SYSTEM_ROLE_ADMIN': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}, u'oc-aaa-types:SYSTEM_ROLE_ADMIN': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}},),], is_leaf=True, yang_name="role", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='union', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """role must be of a type compatible with union""",
          'defined-type': "openconfig-access-points:union",
          'generated-type': """YANGDynClass(base=[six.text_type,RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'SYSTEM_ROLE_ADMIN': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}, u'oc-aaa-types:SYSTEM_ROLE_ADMIN': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}},),], is_leaf=True, yang_name="role", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='union', is_config=False)""",
        })

    self.__role = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_role(self):
    self.__role = YANGDynClass(base=[six.text_type,RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'SYSTEM_ROLE_ADMIN': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}, u'oc-aaa-types:SYSTEM_ROLE_ADMIN': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}},),], is_leaf=True, yang_name="role", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='union', is_config=False)

  username = __builtin__.property(_get_username)
  password = __builtin__.property(_get_password)
  password_hashed = __builtin__.property(_get_password_hashed)
  ssh_key = __builtin__.property(_get_ssh_key)
  role = __builtin__.property(_get_role)


  _pyangbind_elements = OrderedDict([('username', username), ('password', password), ('password_hashed', password_hashed), ('ssh_key', ssh_key), ('role', role), ])


class yc_user_openconfig_access_points__access_points_access_point_system_aaa_authentication_users_user(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-access-points - based on the path /access-points/access-point/system/aaa/authentication/users/user. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of local users on the system
  """
  __slots__ = ('_path_helper', '_extmethods', '__username','__config','__state',)

  _yang_name = 'user'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__username = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="username", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='leafref', is_config=True)
    self.__state = YANGDynClass(base=yc_state_openconfig_access_points__access_points_access_point_system_aaa_authentication_users_user_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)
    self.__config = YANGDynClass(base=yc_config_openconfig_access_points__access_points_access_point_system_aaa_authentication_users_user_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'access-points', u'access-point', u'system', u'aaa', u'authentication', u'users', u'user']

  def _get_username(self):
    """
    Getter method for username, mapped from YANG variable /access_points/access_point/system/aaa/authentication/users/user/username (leafref)

    YANG Description: References the configured username for the user
    """
    return self.__username
      
  def _set_username(self, v, load=False):
    """
    Setter method for username, mapped from YANG variable /access_points/access_point/system/aaa/authentication/users/user/username (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_username is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_username() directly.

    YANG Description: References the configured username for the user
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="username", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """username must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="username", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='leafref', is_config=True)""",
        })

    self.__username = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_username(self):
    self.__username = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="username", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='leafref', is_config=True)


  def _get_config(self):
    """
    Getter method for config, mapped from YANG variable /access_points/access_point/system/aaa/authentication/users/user/config (container)

    YANG Description: Configuration data for local users
    """
    return self.__config
      
  def _set_config(self, v, load=False):
    """
    Setter method for config, mapped from YANG variable /access_points/access_point/system/aaa/authentication/users/user/config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config() directly.

    YANG Description: Configuration data for local users
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_config_openconfig_access_points__access_points_access_point_system_aaa_authentication_users_user_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_config_openconfig_access_points__access_points_access_point_system_aaa_authentication_users_user_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)""",
        })

    self.__config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config(self):
    self.__config = YANGDynClass(base=yc_config_openconfig_access_points__access_points_access_point_system_aaa_authentication_users_user_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /access_points/access_point/system/aaa/authentication/users/user/state (container)

    YANG Description: Operational state data for local users
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /access_points/access_point/system/aaa/authentication/users/user/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: Operational state data for local users
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_access_points__access_points_access_point_system_aaa_authentication_users_user_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_access_points__access_points_access_point_system_aaa_authentication_users_user_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_access_points__access_points_access_point_system_aaa_authentication_users_user_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)

  username = __builtin__.property(_get_username, _set_username)
  config = __builtin__.property(_get_config, _set_config)
  state = __builtin__.property(_get_state, _set_state)


  _pyangbind_elements = OrderedDict([('username', username), ('config', config), ('state', state), ])


class yc_users_openconfig_access_points__access_points_access_point_system_aaa_authentication_users(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-access-points - based on the path /access-points/access-point/system/aaa/authentication/users. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Enclosing container list of local users
  """
  __slots__ = ('_path_helper', '_extmethods', '__user',)

  _yang_name = 'users'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__user = YANGDynClass(base=YANGListType("username",yc_user_openconfig_access_points__access_points_access_point_system_aaa_authentication_users_user, yang_name="user", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='username', extensions=None), is_container='list', yang_name="user", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'access-points', u'access-point', u'system', u'aaa', u'authentication', u'users']

  def _get_user(self):
    """
    Getter method for user, mapped from YANG variable /access_points/access_point/system/aaa/authentication/users/user (list)

    YANG Description: List of local users on the system
    """
    return self.__user
      
  def _set_user(self, v, load=False):
    """
    Setter method for user, mapped from YANG variable /access_points/access_point/system/aaa/authentication/users/user (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_user is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_user() directly.

    YANG Description: List of local users on the system
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("username",yc_user_openconfig_access_points__access_points_access_point_system_aaa_authentication_users_user, yang_name="user", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='username', extensions=None), is_container='list', yang_name="user", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """user must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("username",yc_user_openconfig_access_points__access_points_access_point_system_aaa_authentication_users_user, yang_name="user", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='username', extensions=None), is_container='list', yang_name="user", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='list', is_config=True)""",
        })

    self.__user = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_user(self):
    self.__user = YANGDynClass(base=YANGListType("username",yc_user_openconfig_access_points__access_points_access_point_system_aaa_authentication_users_user, yang_name="user", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='username', extensions=None), is_container='list', yang_name="user", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='list', is_config=True)

  user = __builtin__.property(_get_user, _set_user)


  _pyangbind_elements = OrderedDict([('user', user), ])


class yc_authentication_openconfig_access_points__access_points_access_point_system_aaa_authentication(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-access-points - based on the path /access-points/access-point/system/aaa/authentication. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Top-level container for global authentication data
  """
  __slots__ = ('_path_helper', '_extmethods', '__config','__state','__admin_user','__users',)

  _yang_name = 'authentication'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__state = YANGDynClass(base=yc_state_openconfig_access_points__access_points_access_point_system_aaa_authentication_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)
    self.__admin_user = YANGDynClass(base=yc_admin_user_openconfig_access_points__access_points_access_point_system_aaa_authentication_admin_user, is_container='container', yang_name="admin-user", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)
    self.__config = YANGDynClass(base=yc_config_openconfig_access_points__access_points_access_point_system_aaa_authentication_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)
    self.__users = YANGDynClass(base=yc_users_openconfig_access_points__access_points_access_point_system_aaa_authentication_users, is_container='container', yang_name="users", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'access-points', u'access-point', u'system', u'aaa', u'authentication']

  def _get_config(self):
    """
    Getter method for config, mapped from YANG variable /access_points/access_point/system/aaa/authentication/config (container)

    YANG Description: Configuration data for global authentication services
    """
    return self.__config
      
  def _set_config(self, v, load=False):
    """
    Setter method for config, mapped from YANG variable /access_points/access_point/system/aaa/authentication/config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config() directly.

    YANG Description: Configuration data for global authentication services
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_config_openconfig_access_points__access_points_access_point_system_aaa_authentication_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_config_openconfig_access_points__access_points_access_point_system_aaa_authentication_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)""",
        })

    self.__config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config(self):
    self.__config = YANGDynClass(base=yc_config_openconfig_access_points__access_points_access_point_system_aaa_authentication_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /access_points/access_point/system/aaa/authentication/state (container)

    YANG Description: Operational state data for global authentication
services
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /access_points/access_point/system/aaa/authentication/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: Operational state data for global authentication
services
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_access_points__access_points_access_point_system_aaa_authentication_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_access_points__access_points_access_point_system_aaa_authentication_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_access_points__access_points_access_point_system_aaa_authentication_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)


  def _get_admin_user(self):
    """
    Getter method for admin_user, mapped from YANG variable /access_points/access_point/system/aaa/authentication/admin_user (container)

    YANG Description: Top-level container for the system root or admin user
configuration and operational state
    """
    return self.__admin_user
      
  def _set_admin_user(self, v, load=False):
    """
    Setter method for admin_user, mapped from YANG variable /access_points/access_point/system/aaa/authentication/admin_user (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_admin_user is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_admin_user() directly.

    YANG Description: Top-level container for the system root or admin user
configuration and operational state
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_admin_user_openconfig_access_points__access_points_access_point_system_aaa_authentication_admin_user, is_container='container', yang_name="admin-user", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """admin_user must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_admin_user_openconfig_access_points__access_points_access_point_system_aaa_authentication_admin_user, is_container='container', yang_name="admin-user", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)""",
        })

    self.__admin_user = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_admin_user(self):
    self.__admin_user = YANGDynClass(base=yc_admin_user_openconfig_access_points__access_points_access_point_system_aaa_authentication_admin_user, is_container='container', yang_name="admin-user", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)


  def _get_users(self):
    """
    Getter method for users, mapped from YANG variable /access_points/access_point/system/aaa/authentication/users (container)

    YANG Description: Enclosing container list of local users
    """
    return self.__users
      
  def _set_users(self, v, load=False):
    """
    Setter method for users, mapped from YANG variable /access_points/access_point/system/aaa/authentication/users (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_users is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_users() directly.

    YANG Description: Enclosing container list of local users
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_users_openconfig_access_points__access_points_access_point_system_aaa_authentication_users, is_container='container', yang_name="users", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """users must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_users_openconfig_access_points__access_points_access_point_system_aaa_authentication_users, is_container='container', yang_name="users", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)""",
        })

    self.__users = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_users(self):
    self.__users = YANGDynClass(base=yc_users_openconfig_access_points__access_points_access_point_system_aaa_authentication_users, is_container='container', yang_name="users", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)

  config = __builtin__.property(_get_config, _set_config)
  state = __builtin__.property(_get_state, _set_state)
  admin_user = __builtin__.property(_get_admin_user, _set_admin_user)
  users = __builtin__.property(_get_users, _set_users)


  _pyangbind_elements = OrderedDict([('config', config), ('state', state), ('admin_user', admin_user), ('users', users), ])


class yc_config_openconfig_access_points__access_points_access_point_system_aaa_authorization_config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-access-points - based on the path /access-points/access-point/system/aaa/authorization/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration data for authorization based on AAA
methods
  """
  __slots__ = ('_path_helper', '_extmethods', '__authorization_method',)

  _yang_name = 'config'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__authorization_method = YANGDynClass(unique=True, base=TypedListType(allowed_type=[RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'RADIUS_ALL': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}, u'oc-aaa-types:LOCAL': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}, u'oc-aaa-types:TACACS_ALL': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}, u'oc-aaa-types:RADIUS_ALL': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}, u'LOCAL': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}, u'TACACS_ALL': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}},),six.text_type,]), is_leaf=False, yang_name="authorization-method", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='union', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'access-points', u'access-point', u'system', u'aaa', u'authorization', u'config']

  def _get_authorization_method(self):
    """
    Getter method for authorization_method, mapped from YANG variable /access_points/access_point/system/aaa/authorization/config/authorization_method (union)

    YANG Description: Ordered list of methods for authorizing commands.  The first
method that provides a response (positive or negative) should
be used.  The list may contain a well-defined method such
as the set of all TACACS or RADIUS servers, or the name of
a defined AAA server group.  The system must validate
that the named server group exists.
    """
    return self.__authorization_method
      
  def _set_authorization_method(self, v, load=False):
    """
    Setter method for authorization_method, mapped from YANG variable /access_points/access_point/system/aaa/authorization/config/authorization_method (union)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_authorization_method is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_authorization_method() directly.

    YANG Description: Ordered list of methods for authorizing commands.  The first
method that provides a response (positive or negative) should
be used.  The list may contain a well-defined method such
as the set of all TACACS or RADIUS servers, or the name of
a defined AAA server group.  The system must validate
that the named server group exists.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=[RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'RADIUS_ALL': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}, u'oc-aaa-types:LOCAL': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}, u'oc-aaa-types:TACACS_ALL': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}, u'oc-aaa-types:RADIUS_ALL': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}, u'LOCAL': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}, u'TACACS_ALL': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}},),six.text_type,]), is_leaf=False, yang_name="authorization-method", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='union', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """authorization_method must be of a type compatible with union""",
          'defined-type': "openconfig-access-points:union",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=[RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'RADIUS_ALL': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}, u'oc-aaa-types:LOCAL': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}, u'oc-aaa-types:TACACS_ALL': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}, u'oc-aaa-types:RADIUS_ALL': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}, u'LOCAL': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}, u'TACACS_ALL': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}},),six.text_type,]), is_leaf=False, yang_name="authorization-method", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='union', is_config=True)""",
        })

    self.__authorization_method = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_authorization_method(self):
    self.__authorization_method = YANGDynClass(unique=True, base=TypedListType(allowed_type=[RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'RADIUS_ALL': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}, u'oc-aaa-types:LOCAL': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}, u'oc-aaa-types:TACACS_ALL': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}, u'oc-aaa-types:RADIUS_ALL': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}, u'LOCAL': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}, u'TACACS_ALL': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}},),six.text_type,]), is_leaf=False, yang_name="authorization-method", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='union', is_config=True)

  authorization_method = __builtin__.property(_get_authorization_method, _set_authorization_method)


  _pyangbind_elements = OrderedDict([('authorization_method', authorization_method), ])


class yc_state_openconfig_access_points__access_points_access_point_system_aaa_authorization_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-access-points - based on the path /access-points/access-point/system/aaa/authorization/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Operational state data for authorization based on AAA
  """
  __slots__ = ('_path_helper', '_extmethods', '__authorization_method',)

  _yang_name = 'state'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__authorization_method = YANGDynClass(unique=True, base=TypedListType(allowed_type=[RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'RADIUS_ALL': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}, u'oc-aaa-types:LOCAL': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}, u'oc-aaa-types:TACACS_ALL': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}, u'oc-aaa-types:RADIUS_ALL': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}, u'LOCAL': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}, u'TACACS_ALL': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}},),six.text_type,]), is_leaf=False, yang_name="authorization-method", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='union', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'access-points', u'access-point', u'system', u'aaa', u'authorization', u'state']

  def _get_authorization_method(self):
    """
    Getter method for authorization_method, mapped from YANG variable /access_points/access_point/system/aaa/authorization/state/authorization_method (union)

    YANG Description: Ordered list of methods for authorizing commands.  The first
method that provides a response (positive or negative) should
be used.  The list may contain a well-defined method such
as the set of all TACACS or RADIUS servers, or the name of
a defined AAA server group.  The system must validate
that the named server group exists.
    """
    return self.__authorization_method
      
  def _set_authorization_method(self, v, load=False):
    """
    Setter method for authorization_method, mapped from YANG variable /access_points/access_point/system/aaa/authorization/state/authorization_method (union)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_authorization_method is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_authorization_method() directly.

    YANG Description: Ordered list of methods for authorizing commands.  The first
method that provides a response (positive or negative) should
be used.  The list may contain a well-defined method such
as the set of all TACACS or RADIUS servers, or the name of
a defined AAA server group.  The system must validate
that the named server group exists.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=[RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'RADIUS_ALL': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}, u'oc-aaa-types:LOCAL': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}, u'oc-aaa-types:TACACS_ALL': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}, u'oc-aaa-types:RADIUS_ALL': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}, u'LOCAL': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}, u'TACACS_ALL': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}},),six.text_type,]), is_leaf=False, yang_name="authorization-method", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='union', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """authorization_method must be of a type compatible with union""",
          'defined-type': "openconfig-access-points:union",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=[RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'RADIUS_ALL': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}, u'oc-aaa-types:LOCAL': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}, u'oc-aaa-types:TACACS_ALL': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}, u'oc-aaa-types:RADIUS_ALL': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}, u'LOCAL': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}, u'TACACS_ALL': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}},),six.text_type,]), is_leaf=False, yang_name="authorization-method", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='union', is_config=False)""",
        })

    self.__authorization_method = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_authorization_method(self):
    self.__authorization_method = YANGDynClass(unique=True, base=TypedListType(allowed_type=[RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'RADIUS_ALL': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}, u'oc-aaa-types:LOCAL': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}, u'oc-aaa-types:TACACS_ALL': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}, u'oc-aaa-types:RADIUS_ALL': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}, u'LOCAL': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}, u'TACACS_ALL': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}},),six.text_type,]), is_leaf=False, yang_name="authorization-method", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='union', is_config=False)

  authorization_method = __builtin__.property(_get_authorization_method)


  _pyangbind_elements = OrderedDict([('authorization_method', authorization_method), ])


class yc_config_openconfig_access_points__access_points_access_point_system_aaa_authorization_events_event_config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-access-points - based on the path /access-points/access-point/system/aaa/authorization/events/event/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration data for each authorized event
  """
  __slots__ = ('_path_helper', '_extmethods', '__event_type',)

  _yang_name = 'config'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__event_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'AAA_AUTHORIZATION_EVENT_COMMAND': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}, u'oc-aaa-types:AAA_AUTHORIZATION_EVENT_COMMAND': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}, u'AAA_AUTHORIZATION_EVENT_CONFIG': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}, u'oc-aaa-types:AAA_AUTHORIZATION_EVENT_CONFIG': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}},), is_leaf=True, yang_name="event-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='identityref', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'access-points', u'access-point', u'system', u'aaa', u'authorization', u'events', u'event', u'config']

  def _get_event_type(self):
    """
    Getter method for event_type, mapped from YANG variable /access_points/access_point/system/aaa/authorization/events/event/config/event_type (identityref)

    YANG Description: The type of event to record at the AAA authorization
server
    """
    return self.__event_type
      
  def _set_event_type(self, v, load=False):
    """
    Setter method for event_type, mapped from YANG variable /access_points/access_point/system/aaa/authorization/events/event/config/event_type (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_event_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_event_type() directly.

    YANG Description: The type of event to record at the AAA authorization
server
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'AAA_AUTHORIZATION_EVENT_COMMAND': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}, u'oc-aaa-types:AAA_AUTHORIZATION_EVENT_COMMAND': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}, u'AAA_AUTHORIZATION_EVENT_CONFIG': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}, u'oc-aaa-types:AAA_AUTHORIZATION_EVENT_CONFIG': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}},), is_leaf=True, yang_name="event-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='identityref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """event_type must be of a type compatible with identityref""",
          'defined-type': "openconfig-access-points:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'AAA_AUTHORIZATION_EVENT_COMMAND': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}, u'oc-aaa-types:AAA_AUTHORIZATION_EVENT_COMMAND': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}, u'AAA_AUTHORIZATION_EVENT_CONFIG': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}, u'oc-aaa-types:AAA_AUTHORIZATION_EVENT_CONFIG': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}},), is_leaf=True, yang_name="event-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='identityref', is_config=True)""",
        })

    self.__event_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_event_type(self):
    self.__event_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'AAA_AUTHORIZATION_EVENT_COMMAND': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}, u'oc-aaa-types:AAA_AUTHORIZATION_EVENT_COMMAND': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}, u'AAA_AUTHORIZATION_EVENT_CONFIG': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}, u'oc-aaa-types:AAA_AUTHORIZATION_EVENT_CONFIG': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}},), is_leaf=True, yang_name="event-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='identityref', is_config=True)

  event_type = __builtin__.property(_get_event_type, _set_event_type)


  _pyangbind_elements = OrderedDict([('event_type', event_type), ])


class yc_state_openconfig_access_points__access_points_access_point_system_aaa_authorization_events_event_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-access-points - based on the path /access-points/access-point/system/aaa/authorization/events/event/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Operational state data for each authorized activity
  """
  __slots__ = ('_path_helper', '_extmethods', '__event_type',)

  _yang_name = 'state'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__event_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'AAA_AUTHORIZATION_EVENT_COMMAND': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}, u'oc-aaa-types:AAA_AUTHORIZATION_EVENT_COMMAND': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}, u'AAA_AUTHORIZATION_EVENT_CONFIG': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}, u'oc-aaa-types:AAA_AUTHORIZATION_EVENT_CONFIG': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}},), is_leaf=True, yang_name="event-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='identityref', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'access-points', u'access-point', u'system', u'aaa', u'authorization', u'events', u'event', u'state']

  def _get_event_type(self):
    """
    Getter method for event_type, mapped from YANG variable /access_points/access_point/system/aaa/authorization/events/event/state/event_type (identityref)

    YANG Description: The type of event to record at the AAA authorization
server
    """
    return self.__event_type
      
  def _set_event_type(self, v, load=False):
    """
    Setter method for event_type, mapped from YANG variable /access_points/access_point/system/aaa/authorization/events/event/state/event_type (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_event_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_event_type() directly.

    YANG Description: The type of event to record at the AAA authorization
server
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'AAA_AUTHORIZATION_EVENT_COMMAND': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}, u'oc-aaa-types:AAA_AUTHORIZATION_EVENT_COMMAND': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}, u'AAA_AUTHORIZATION_EVENT_CONFIG': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}, u'oc-aaa-types:AAA_AUTHORIZATION_EVENT_CONFIG': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}},), is_leaf=True, yang_name="event-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='identityref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """event_type must be of a type compatible with identityref""",
          'defined-type': "openconfig-access-points:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'AAA_AUTHORIZATION_EVENT_COMMAND': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}, u'oc-aaa-types:AAA_AUTHORIZATION_EVENT_COMMAND': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}, u'AAA_AUTHORIZATION_EVENT_CONFIG': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}, u'oc-aaa-types:AAA_AUTHORIZATION_EVENT_CONFIG': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}},), is_leaf=True, yang_name="event-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='identityref', is_config=False)""",
        })

    self.__event_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_event_type(self):
    self.__event_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'AAA_AUTHORIZATION_EVENT_COMMAND': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}, u'oc-aaa-types:AAA_AUTHORIZATION_EVENT_COMMAND': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}, u'AAA_AUTHORIZATION_EVENT_CONFIG': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}, u'oc-aaa-types:AAA_AUTHORIZATION_EVENT_CONFIG': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}},), is_leaf=True, yang_name="event-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='identityref', is_config=False)

  event_type = __builtin__.property(_get_event_type)


  _pyangbind_elements = OrderedDict([('event_type', event_type), ])


class yc_event_openconfig_access_points__access_points_access_point_system_aaa_authorization_events_event(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-access-points - based on the path /access-points/access-point/system/aaa/authorization/events/event. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of events subject to AAA authorization
  """
  __slots__ = ('_path_helper', '_extmethods', '__event_type','__config','__state',)

  _yang_name = 'event'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__state = YANGDynClass(base=yc_state_openconfig_access_points__access_points_access_point_system_aaa_authorization_events_event_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)
    self.__config = YANGDynClass(base=yc_config_openconfig_access_points__access_points_access_point_system_aaa_authorization_events_event_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)
    self.__event_type = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="event-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='leafref', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'access-points', u'access-point', u'system', u'aaa', u'authorization', u'events', u'event']

  def _get_event_type(self):
    """
    Getter method for event_type, mapped from YANG variable /access_points/access_point/system/aaa/authorization/events/event/event_type (leafref)

    YANG Description: Reference to the event-type list key
    """
    return self.__event_type
      
  def _set_event_type(self, v, load=False):
    """
    Setter method for event_type, mapped from YANG variable /access_points/access_point/system/aaa/authorization/events/event/event_type (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_event_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_event_type() directly.

    YANG Description: Reference to the event-type list key
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="event-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """event_type must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="event-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='leafref', is_config=True)""",
        })

    self.__event_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_event_type(self):
    self.__event_type = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="event-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='leafref', is_config=True)


  def _get_config(self):
    """
    Getter method for config, mapped from YANG variable /access_points/access_point/system/aaa/authorization/events/event/config (container)

    YANG Description: Configuration data for each authorized event
    """
    return self.__config
      
  def _set_config(self, v, load=False):
    """
    Setter method for config, mapped from YANG variable /access_points/access_point/system/aaa/authorization/events/event/config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config() directly.

    YANG Description: Configuration data for each authorized event
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_config_openconfig_access_points__access_points_access_point_system_aaa_authorization_events_event_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_config_openconfig_access_points__access_points_access_point_system_aaa_authorization_events_event_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)""",
        })

    self.__config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config(self):
    self.__config = YANGDynClass(base=yc_config_openconfig_access_points__access_points_access_point_system_aaa_authorization_events_event_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /access_points/access_point/system/aaa/authorization/events/event/state (container)

    YANG Description: Operational state data for each authorized activity
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /access_points/access_point/system/aaa/authorization/events/event/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: Operational state data for each authorized activity
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_access_points__access_points_access_point_system_aaa_authorization_events_event_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_access_points__access_points_access_point_system_aaa_authorization_events_event_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_access_points__access_points_access_point_system_aaa_authorization_events_event_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)

  event_type = __builtin__.property(_get_event_type, _set_event_type)
  config = __builtin__.property(_get_config, _set_config)
  state = __builtin__.property(_get_state, _set_state)


  _pyangbind_elements = OrderedDict([('event_type', event_type), ('config', config), ('state', state), ])


class yc_events_openconfig_access_points__access_points_access_point_system_aaa_authorization_events(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-access-points - based on the path /access-points/access-point/system/aaa/authorization/events. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Enclosing container for the set of events subject
to authorization
  """
  __slots__ = ('_path_helper', '_extmethods', '__event',)

  _yang_name = 'events'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__event = YANGDynClass(base=YANGListType("event_type",yc_event_openconfig_access_points__access_points_access_point_system_aaa_authorization_events_event, yang_name="event", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='event-type', extensions=None), is_container='list', yang_name="event", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'access-points', u'access-point', u'system', u'aaa', u'authorization', u'events']

  def _get_event(self):
    """
    Getter method for event, mapped from YANG variable /access_points/access_point/system/aaa/authorization/events/event (list)

    YANG Description: List of events subject to AAA authorization
    """
    return self.__event
      
  def _set_event(self, v, load=False):
    """
    Setter method for event, mapped from YANG variable /access_points/access_point/system/aaa/authorization/events/event (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_event is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_event() directly.

    YANG Description: List of events subject to AAA authorization
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("event_type",yc_event_openconfig_access_points__access_points_access_point_system_aaa_authorization_events_event, yang_name="event", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='event-type', extensions=None), is_container='list', yang_name="event", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """event must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("event_type",yc_event_openconfig_access_points__access_points_access_point_system_aaa_authorization_events_event, yang_name="event", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='event-type', extensions=None), is_container='list', yang_name="event", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='list', is_config=True)""",
        })

    self.__event = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_event(self):
    self.__event = YANGDynClass(base=YANGListType("event_type",yc_event_openconfig_access_points__access_points_access_point_system_aaa_authorization_events_event, yang_name="event", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='event-type', extensions=None), is_container='list', yang_name="event", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='list', is_config=True)

  event = __builtin__.property(_get_event, _set_event)


  _pyangbind_elements = OrderedDict([('event', event), ])


class yc_authorization_openconfig_access_points__access_points_access_point_system_aaa_authorization(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-access-points - based on the path /access-points/access-point/system/aaa/authorization. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Top-level container for AAA authorization configuration
and operational state data
  """
  __slots__ = ('_path_helper', '_extmethods', '__config','__state','__events',)

  _yang_name = 'authorization'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__state = YANGDynClass(base=yc_state_openconfig_access_points__access_points_access_point_system_aaa_authorization_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)
    self.__config = YANGDynClass(base=yc_config_openconfig_access_points__access_points_access_point_system_aaa_authorization_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)
    self.__events = YANGDynClass(base=yc_events_openconfig_access_points__access_points_access_point_system_aaa_authorization_events, is_container='container', yang_name="events", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'access-points', u'access-point', u'system', u'aaa', u'authorization']

  def _get_config(self):
    """
    Getter method for config, mapped from YANG variable /access_points/access_point/system/aaa/authorization/config (container)

    YANG Description: Configuration data for authorization based on AAA
methods
    """
    return self.__config
      
  def _set_config(self, v, load=False):
    """
    Setter method for config, mapped from YANG variable /access_points/access_point/system/aaa/authorization/config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config() directly.

    YANG Description: Configuration data for authorization based on AAA
methods
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_config_openconfig_access_points__access_points_access_point_system_aaa_authorization_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_config_openconfig_access_points__access_points_access_point_system_aaa_authorization_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)""",
        })

    self.__config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config(self):
    self.__config = YANGDynClass(base=yc_config_openconfig_access_points__access_points_access_point_system_aaa_authorization_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /access_points/access_point/system/aaa/authorization/state (container)

    YANG Description: Operational state data for authorization based on AAA
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /access_points/access_point/system/aaa/authorization/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: Operational state data for authorization based on AAA
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_access_points__access_points_access_point_system_aaa_authorization_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_access_points__access_points_access_point_system_aaa_authorization_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_access_points__access_points_access_point_system_aaa_authorization_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)


  def _get_events(self):
    """
    Getter method for events, mapped from YANG variable /access_points/access_point/system/aaa/authorization/events (container)

    YANG Description: Enclosing container for the set of events subject
to authorization
    """
    return self.__events
      
  def _set_events(self, v, load=False):
    """
    Setter method for events, mapped from YANG variable /access_points/access_point/system/aaa/authorization/events (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_events is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_events() directly.

    YANG Description: Enclosing container for the set of events subject
to authorization
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_events_openconfig_access_points__access_points_access_point_system_aaa_authorization_events, is_container='container', yang_name="events", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """events must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_events_openconfig_access_points__access_points_access_point_system_aaa_authorization_events, is_container='container', yang_name="events", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)""",
        })

    self.__events = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_events(self):
    self.__events = YANGDynClass(base=yc_events_openconfig_access_points__access_points_access_point_system_aaa_authorization_events, is_container='container', yang_name="events", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)

  config = __builtin__.property(_get_config, _set_config)
  state = __builtin__.property(_get_state, _set_state)
  events = __builtin__.property(_get_events, _set_events)


  _pyangbind_elements = OrderedDict([('config', config), ('state', state), ('events', events), ])


class yc_config_openconfig_access_points__access_points_access_point_system_aaa_accounting_config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-access-points - based on the path /access-points/access-point/system/aaa/accounting/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration data for user activity accounting.
  """
  __slots__ = ('_path_helper', '_extmethods', '__accounting_method',)

  _yang_name = 'config'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__accounting_method = YANGDynClass(unique=True, base=TypedListType(allowed_type=[RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'RADIUS_ALL': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}, u'oc-aaa-types:LOCAL': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}, u'oc-aaa-types:TACACS_ALL': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}, u'oc-aaa-types:RADIUS_ALL': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}, u'LOCAL': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}, u'TACACS_ALL': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}},),six.text_type,]), is_leaf=False, yang_name="accounting-method", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='union', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'access-points', u'access-point', u'system', u'aaa', u'accounting', u'config']

  def _get_accounting_method(self):
    """
    Getter method for accounting_method, mapped from YANG variable /access_points/access_point/system/aaa/accounting/config/accounting_method (union)

    YANG Description: An ordered list of methods used for AAA accounting for this
event type.  The method is defined by the destination for
accounting data, which may be specified as the group of
all TACACS+/RADIUS servers, a defined server group, or
the local system.
    """
    return self.__accounting_method
      
  def _set_accounting_method(self, v, load=False):
    """
    Setter method for accounting_method, mapped from YANG variable /access_points/access_point/system/aaa/accounting/config/accounting_method (union)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_accounting_method is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_accounting_method() directly.

    YANG Description: An ordered list of methods used for AAA accounting for this
event type.  The method is defined by the destination for
accounting data, which may be specified as the group of
all TACACS+/RADIUS servers, a defined server group, or
the local system.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=[RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'RADIUS_ALL': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}, u'oc-aaa-types:LOCAL': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}, u'oc-aaa-types:TACACS_ALL': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}, u'oc-aaa-types:RADIUS_ALL': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}, u'LOCAL': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}, u'TACACS_ALL': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}},),six.text_type,]), is_leaf=False, yang_name="accounting-method", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='union', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """accounting_method must be of a type compatible with union""",
          'defined-type': "openconfig-access-points:union",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=[RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'RADIUS_ALL': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}, u'oc-aaa-types:LOCAL': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}, u'oc-aaa-types:TACACS_ALL': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}, u'oc-aaa-types:RADIUS_ALL': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}, u'LOCAL': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}, u'TACACS_ALL': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}},),six.text_type,]), is_leaf=False, yang_name="accounting-method", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='union', is_config=True)""",
        })

    self.__accounting_method = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_accounting_method(self):
    self.__accounting_method = YANGDynClass(unique=True, base=TypedListType(allowed_type=[RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'RADIUS_ALL': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}, u'oc-aaa-types:LOCAL': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}, u'oc-aaa-types:TACACS_ALL': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}, u'oc-aaa-types:RADIUS_ALL': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}, u'LOCAL': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}, u'TACACS_ALL': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}},),six.text_type,]), is_leaf=False, yang_name="accounting-method", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='union', is_config=True)

  accounting_method = __builtin__.property(_get_accounting_method, _set_accounting_method)


  _pyangbind_elements = OrderedDict([('accounting_method', accounting_method), ])


class yc_state_openconfig_access_points__access_points_access_point_system_aaa_accounting_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-access-points - based on the path /access-points/access-point/system/aaa/accounting/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Operational state data for user accounting.
  """
  __slots__ = ('_path_helper', '_extmethods', '__accounting_method',)

  _yang_name = 'state'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__accounting_method = YANGDynClass(unique=True, base=TypedListType(allowed_type=[RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'RADIUS_ALL': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}, u'oc-aaa-types:LOCAL': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}, u'oc-aaa-types:TACACS_ALL': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}, u'oc-aaa-types:RADIUS_ALL': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}, u'LOCAL': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}, u'TACACS_ALL': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}},),six.text_type,]), is_leaf=False, yang_name="accounting-method", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='union', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'access-points', u'access-point', u'system', u'aaa', u'accounting', u'state']

  def _get_accounting_method(self):
    """
    Getter method for accounting_method, mapped from YANG variable /access_points/access_point/system/aaa/accounting/state/accounting_method (union)

    YANG Description: An ordered list of methods used for AAA accounting for this
event type.  The method is defined by the destination for
accounting data, which may be specified as the group of
all TACACS+/RADIUS servers, a defined server group, or
the local system.
    """
    return self.__accounting_method
      
  def _set_accounting_method(self, v, load=False):
    """
    Setter method for accounting_method, mapped from YANG variable /access_points/access_point/system/aaa/accounting/state/accounting_method (union)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_accounting_method is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_accounting_method() directly.

    YANG Description: An ordered list of methods used for AAA accounting for this
event type.  The method is defined by the destination for
accounting data, which may be specified as the group of
all TACACS+/RADIUS servers, a defined server group, or
the local system.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=[RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'RADIUS_ALL': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}, u'oc-aaa-types:LOCAL': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}, u'oc-aaa-types:TACACS_ALL': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}, u'oc-aaa-types:RADIUS_ALL': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}, u'LOCAL': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}, u'TACACS_ALL': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}},),six.text_type,]), is_leaf=False, yang_name="accounting-method", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='union', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """accounting_method must be of a type compatible with union""",
          'defined-type': "openconfig-access-points:union",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=[RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'RADIUS_ALL': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}, u'oc-aaa-types:LOCAL': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}, u'oc-aaa-types:TACACS_ALL': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}, u'oc-aaa-types:RADIUS_ALL': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}, u'LOCAL': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}, u'TACACS_ALL': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}},),six.text_type,]), is_leaf=False, yang_name="accounting-method", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='union', is_config=False)""",
        })

    self.__accounting_method = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_accounting_method(self):
    self.__accounting_method = YANGDynClass(unique=True, base=TypedListType(allowed_type=[RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'RADIUS_ALL': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}, u'oc-aaa-types:LOCAL': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}, u'oc-aaa-types:TACACS_ALL': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}, u'oc-aaa-types:RADIUS_ALL': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}, u'LOCAL': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}, u'TACACS_ALL': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}},),six.text_type,]), is_leaf=False, yang_name="accounting-method", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='union', is_config=False)

  accounting_method = __builtin__.property(_get_accounting_method)


  _pyangbind_elements = OrderedDict([('accounting_method', accounting_method), ])


class yc_config_openconfig_access_points__access_points_access_point_system_aaa_accounting_events_event_config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-access-points - based on the path /access-points/access-point/system/aaa/accounting/events/event/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration data for accounting events
  """
  __slots__ = ('_path_helper', '_extmethods', '__event_type','__record',)

  _yang_name = 'config'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__record = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'START_STOP': {}, u'STOP': {}},), is_leaf=True, yang_name="record", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='enumeration', is_config=True)
    self.__event_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'oc-aaa-types:AAA_ACCOUNTING_EVENT_LOGIN': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}, u'AAA_ACCOUNTING_EVENT_COMMAND': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}, u'AAA_ACCOUNTING_EVENT_LOGIN': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}, u'oc-aaa-types:AAA_ACCOUNTING_EVENT_COMMAND': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}},), is_leaf=True, yang_name="event-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='identityref', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'access-points', u'access-point', u'system', u'aaa', u'accounting', u'events', u'event', u'config']

  def _get_event_type(self):
    """
    Getter method for event_type, mapped from YANG variable /access_points/access_point/system/aaa/accounting/events/event/config/event_type (identityref)

    YANG Description: The type of activity to record at the AAA accounting
server
    """
    return self.__event_type
      
  def _set_event_type(self, v, load=False):
    """
    Setter method for event_type, mapped from YANG variable /access_points/access_point/system/aaa/accounting/events/event/config/event_type (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_event_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_event_type() directly.

    YANG Description: The type of activity to record at the AAA accounting
server
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'oc-aaa-types:AAA_ACCOUNTING_EVENT_LOGIN': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}, u'AAA_ACCOUNTING_EVENT_COMMAND': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}, u'AAA_ACCOUNTING_EVENT_LOGIN': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}, u'oc-aaa-types:AAA_ACCOUNTING_EVENT_COMMAND': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}},), is_leaf=True, yang_name="event-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='identityref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """event_type must be of a type compatible with identityref""",
          'defined-type': "openconfig-access-points:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'oc-aaa-types:AAA_ACCOUNTING_EVENT_LOGIN': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}, u'AAA_ACCOUNTING_EVENT_COMMAND': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}, u'AAA_ACCOUNTING_EVENT_LOGIN': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}, u'oc-aaa-types:AAA_ACCOUNTING_EVENT_COMMAND': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}},), is_leaf=True, yang_name="event-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='identityref', is_config=True)""",
        })

    self.__event_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_event_type(self):
    self.__event_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'oc-aaa-types:AAA_ACCOUNTING_EVENT_LOGIN': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}, u'AAA_ACCOUNTING_EVENT_COMMAND': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}, u'AAA_ACCOUNTING_EVENT_LOGIN': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}, u'oc-aaa-types:AAA_ACCOUNTING_EVENT_COMMAND': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}},), is_leaf=True, yang_name="event-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='identityref', is_config=True)


  def _get_record(self):
    """
    Getter method for record, mapped from YANG variable /access_points/access_point/system/aaa/accounting/events/event/config/record (enumeration)

    YANG Description: Type of record to send to the accounting server for this
activity type
    """
    return self.__record
      
  def _set_record(self, v, load=False):
    """
    Setter method for record, mapped from YANG variable /access_points/access_point/system/aaa/accounting/events/event/config/record (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_record is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_record() directly.

    YANG Description: Type of record to send to the accounting server for this
activity type
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'START_STOP': {}, u'STOP': {}},), is_leaf=True, yang_name="record", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """record must be of a type compatible with enumeration""",
          'defined-type': "openconfig-access-points:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'START_STOP': {}, u'STOP': {}},), is_leaf=True, yang_name="record", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='enumeration', is_config=True)""",
        })

    self.__record = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_record(self):
    self.__record = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'START_STOP': {}, u'STOP': {}},), is_leaf=True, yang_name="record", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='enumeration', is_config=True)

  event_type = __builtin__.property(_get_event_type, _set_event_type)
  record = __builtin__.property(_get_record, _set_record)


  _pyangbind_elements = OrderedDict([('event_type', event_type), ('record', record), ])


class yc_state_openconfig_access_points__access_points_access_point_system_aaa_accounting_events_event_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-access-points - based on the path /access-points/access-point/system/aaa/accounting/events/event/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Operational state data for accounting events
  """
  __slots__ = ('_path_helper', '_extmethods', '__event_type','__record',)

  _yang_name = 'state'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__record = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'START_STOP': {}, u'STOP': {}},), is_leaf=True, yang_name="record", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='enumeration', is_config=False)
    self.__event_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'oc-aaa-types:AAA_ACCOUNTING_EVENT_LOGIN': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}, u'AAA_ACCOUNTING_EVENT_COMMAND': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}, u'AAA_ACCOUNTING_EVENT_LOGIN': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}, u'oc-aaa-types:AAA_ACCOUNTING_EVENT_COMMAND': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}},), is_leaf=True, yang_name="event-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='identityref', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'access-points', u'access-point', u'system', u'aaa', u'accounting', u'events', u'event', u'state']

  def _get_event_type(self):
    """
    Getter method for event_type, mapped from YANG variable /access_points/access_point/system/aaa/accounting/events/event/state/event_type (identityref)

    YANG Description: The type of activity to record at the AAA accounting
server
    """
    return self.__event_type
      
  def _set_event_type(self, v, load=False):
    """
    Setter method for event_type, mapped from YANG variable /access_points/access_point/system/aaa/accounting/events/event/state/event_type (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_event_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_event_type() directly.

    YANG Description: The type of activity to record at the AAA accounting
server
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'oc-aaa-types:AAA_ACCOUNTING_EVENT_LOGIN': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}, u'AAA_ACCOUNTING_EVENT_COMMAND': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}, u'AAA_ACCOUNTING_EVENT_LOGIN': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}, u'oc-aaa-types:AAA_ACCOUNTING_EVENT_COMMAND': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}},), is_leaf=True, yang_name="event-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='identityref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """event_type must be of a type compatible with identityref""",
          'defined-type': "openconfig-access-points:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'oc-aaa-types:AAA_ACCOUNTING_EVENT_LOGIN': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}, u'AAA_ACCOUNTING_EVENT_COMMAND': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}, u'AAA_ACCOUNTING_EVENT_LOGIN': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}, u'oc-aaa-types:AAA_ACCOUNTING_EVENT_COMMAND': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}},), is_leaf=True, yang_name="event-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='identityref', is_config=False)""",
        })

    self.__event_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_event_type(self):
    self.__event_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'oc-aaa-types:AAA_ACCOUNTING_EVENT_LOGIN': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}, u'AAA_ACCOUNTING_EVENT_COMMAND': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}, u'AAA_ACCOUNTING_EVENT_LOGIN': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}, u'oc-aaa-types:AAA_ACCOUNTING_EVENT_COMMAND': {u'@namespace': u'http://openconfig.net/yang/aaa/types', u'@module': u'openconfig-aaa-types'}},), is_leaf=True, yang_name="event-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='identityref', is_config=False)


  def _get_record(self):
    """
    Getter method for record, mapped from YANG variable /access_points/access_point/system/aaa/accounting/events/event/state/record (enumeration)

    YANG Description: Type of record to send to the accounting server for this
activity type
    """
    return self.__record
      
  def _set_record(self, v, load=False):
    """
    Setter method for record, mapped from YANG variable /access_points/access_point/system/aaa/accounting/events/event/state/record (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_record is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_record() directly.

    YANG Description: Type of record to send to the accounting server for this
activity type
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'START_STOP': {}, u'STOP': {}},), is_leaf=True, yang_name="record", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='enumeration', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """record must be of a type compatible with enumeration""",
          'defined-type': "openconfig-access-points:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'START_STOP': {}, u'STOP': {}},), is_leaf=True, yang_name="record", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='enumeration', is_config=False)""",
        })

    self.__record = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_record(self):
    self.__record = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'START_STOP': {}, u'STOP': {}},), is_leaf=True, yang_name="record", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='enumeration', is_config=False)

  event_type = __builtin__.property(_get_event_type)
  record = __builtin__.property(_get_record)


  _pyangbind_elements = OrderedDict([('event_type', event_type), ('record', record), ])


class yc_event_openconfig_access_points__access_points_access_point_system_aaa_accounting_events_event(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-access-points - based on the path /access-points/access-point/system/aaa/accounting/events/event. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of events subject to accounting
  """
  __slots__ = ('_path_helper', '_extmethods', '__event_type','__config','__state',)

  _yang_name = 'event'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__state = YANGDynClass(base=yc_state_openconfig_access_points__access_points_access_point_system_aaa_accounting_events_event_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)
    self.__config = YANGDynClass(base=yc_config_openconfig_access_points__access_points_access_point_system_aaa_accounting_events_event_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)
    self.__event_type = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="event-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='leafref', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'access-points', u'access-point', u'system', u'aaa', u'accounting', u'events', u'event']

  def _get_event_type(self):
    """
    Getter method for event_type, mapped from YANG variable /access_points/access_point/system/aaa/accounting/events/event/event_type (leafref)

    YANG Description: Reference to the event-type being logged at the
accounting server
    """
    return self.__event_type
      
  def _set_event_type(self, v, load=False):
    """
    Setter method for event_type, mapped from YANG variable /access_points/access_point/system/aaa/accounting/events/event/event_type (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_event_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_event_type() directly.

    YANG Description: Reference to the event-type being logged at the
accounting server
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="event-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """event_type must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="event-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='leafref', is_config=True)""",
        })

    self.__event_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_event_type(self):
    self.__event_type = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="event-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='leafref', is_config=True)


  def _get_config(self):
    """
    Getter method for config, mapped from YANG variable /access_points/access_point/system/aaa/accounting/events/event/config (container)

    YANG Description: Configuration data for accounting events
    """
    return self.__config
      
  def _set_config(self, v, load=False):
    """
    Setter method for config, mapped from YANG variable /access_points/access_point/system/aaa/accounting/events/event/config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config() directly.

    YANG Description: Configuration data for accounting events
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_config_openconfig_access_points__access_points_access_point_system_aaa_accounting_events_event_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_config_openconfig_access_points__access_points_access_point_system_aaa_accounting_events_event_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)""",
        })

    self.__config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config(self):
    self.__config = YANGDynClass(base=yc_config_openconfig_access_points__access_points_access_point_system_aaa_accounting_events_event_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /access_points/access_point/system/aaa/accounting/events/event/state (container)

    YANG Description: Operational state data for accounting events
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /access_points/access_point/system/aaa/accounting/events/event/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: Operational state data for accounting events
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_access_points__access_points_access_point_system_aaa_accounting_events_event_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_access_points__access_points_access_point_system_aaa_accounting_events_event_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_access_points__access_points_access_point_system_aaa_accounting_events_event_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)

  event_type = __builtin__.property(_get_event_type, _set_event_type)
  config = __builtin__.property(_get_config, _set_config)
  state = __builtin__.property(_get_state, _set_state)


  _pyangbind_elements = OrderedDict([('event_type', event_type), ('config', config), ('state', state), ])


class yc_events_openconfig_access_points__access_points_access_point_system_aaa_accounting_events(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-access-points - based on the path /access-points/access-point/system/aaa/accounting/events. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Enclosing container for defining handling of events
for accounting
  """
  __slots__ = ('_path_helper', '_extmethods', '__event',)

  _yang_name = 'events'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__event = YANGDynClass(base=YANGListType("event_type",yc_event_openconfig_access_points__access_points_access_point_system_aaa_accounting_events_event, yang_name="event", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='event-type', extensions=None), is_container='list', yang_name="event", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'access-points', u'access-point', u'system', u'aaa', u'accounting', u'events']

  def _get_event(self):
    """
    Getter method for event, mapped from YANG variable /access_points/access_point/system/aaa/accounting/events/event (list)

    YANG Description: List of events subject to accounting
    """
    return self.__event
      
  def _set_event(self, v, load=False):
    """
    Setter method for event, mapped from YANG variable /access_points/access_point/system/aaa/accounting/events/event (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_event is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_event() directly.

    YANG Description: List of events subject to accounting
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("event_type",yc_event_openconfig_access_points__access_points_access_point_system_aaa_accounting_events_event, yang_name="event", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='event-type', extensions=None), is_container='list', yang_name="event", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """event must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("event_type",yc_event_openconfig_access_points__access_points_access_point_system_aaa_accounting_events_event, yang_name="event", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='event-type', extensions=None), is_container='list', yang_name="event", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='list', is_config=True)""",
        })

    self.__event = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_event(self):
    self.__event = YANGDynClass(base=YANGListType("event_type",yc_event_openconfig_access_points__access_points_access_point_system_aaa_accounting_events_event, yang_name="event", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='event-type', extensions=None), is_container='list', yang_name="event", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='list', is_config=True)

  event = __builtin__.property(_get_event, _set_event)


  _pyangbind_elements = OrderedDict([('event', event), ])


class yc_accounting_openconfig_access_points__access_points_access_point_system_aaa_accounting(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-access-points - based on the path /access-points/access-point/system/aaa/accounting. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Top-level container for AAA accounting
  """
  __slots__ = ('_path_helper', '_extmethods', '__config','__state','__events',)

  _yang_name = 'accounting'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__state = YANGDynClass(base=yc_state_openconfig_access_points__access_points_access_point_system_aaa_accounting_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)
    self.__config = YANGDynClass(base=yc_config_openconfig_access_points__access_points_access_point_system_aaa_accounting_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)
    self.__events = YANGDynClass(base=yc_events_openconfig_access_points__access_points_access_point_system_aaa_accounting_events, is_container='container', yang_name="events", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'access-points', u'access-point', u'system', u'aaa', u'accounting']

  def _get_config(self):
    """
    Getter method for config, mapped from YANG variable /access_points/access_point/system/aaa/accounting/config (container)

    YANG Description: Configuration data for user activity accounting.
    """
    return self.__config
      
  def _set_config(self, v, load=False):
    """
    Setter method for config, mapped from YANG variable /access_points/access_point/system/aaa/accounting/config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config() directly.

    YANG Description: Configuration data for user activity accounting.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_config_openconfig_access_points__access_points_access_point_system_aaa_accounting_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_config_openconfig_access_points__access_points_access_point_system_aaa_accounting_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)""",
        })

    self.__config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config(self):
    self.__config = YANGDynClass(base=yc_config_openconfig_access_points__access_points_access_point_system_aaa_accounting_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /access_points/access_point/system/aaa/accounting/state (container)

    YANG Description: Operational state data for user accounting.
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /access_points/access_point/system/aaa/accounting/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: Operational state data for user accounting.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_access_points__access_points_access_point_system_aaa_accounting_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_access_points__access_points_access_point_system_aaa_accounting_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_access_points__access_points_access_point_system_aaa_accounting_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)


  def _get_events(self):
    """
    Getter method for events, mapped from YANG variable /access_points/access_point/system/aaa/accounting/events (container)

    YANG Description: Enclosing container for defining handling of events
for accounting
    """
    return self.__events
      
  def _set_events(self, v, load=False):
    """
    Setter method for events, mapped from YANG variable /access_points/access_point/system/aaa/accounting/events (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_events is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_events() directly.

    YANG Description: Enclosing container for defining handling of events
for accounting
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_events_openconfig_access_points__access_points_access_point_system_aaa_accounting_events, is_container='container', yang_name="events", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """events must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_events_openconfig_access_points__access_points_access_point_system_aaa_accounting_events, is_container='container', yang_name="events", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)""",
        })

    self.__events = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_events(self):
    self.__events = YANGDynClass(base=yc_events_openconfig_access_points__access_points_access_point_system_aaa_accounting_events, is_container='container', yang_name="events", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)

  config = __builtin__.property(_get_config, _set_config)
  state = __builtin__.property(_get_state, _set_state)
  events = __builtin__.property(_get_events, _set_events)


  _pyangbind_elements = OrderedDict([('config', config), ('state', state), ('events', events), ])


class yc_config_openconfig_access_points__access_points_access_point_system_aaa_server_groups_server_group_config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-access-points - based on the path /access-points/access-point/system/aaa/server-groups/server-group/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration data for each server group
  """
  __slots__ = ('_path_helper', '_extmethods', '__name','__type',)

  _yang_name = 'config'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'TACACS': {u'@namespace': u'http://openconfig.net/yang/aaa', u'@module': u'openconfig-aaa'}, u'oc-aaa:TACACS': {u'@namespace': u'http://openconfig.net/yang/aaa', u'@module': u'openconfig-aaa'}, u'RADIUS': {u'@namespace': u'http://openconfig.net/yang/aaa', u'@module': u'openconfig-aaa'}, u'oc-aaa:RADIUS': {u'@namespace': u'http://openconfig.net/yang/aaa', u'@module': u'openconfig-aaa'}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='identityref', is_config=True)
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'access-points', u'access-point', u'system', u'aaa', u'server-groups', u'server-group', u'config']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /access_points/access_point/system/aaa/server_groups/server_group/config/name (string)

    YANG Description: Name for the server group
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /access_points/access_point/system/aaa/server_groups/server_group/config/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Name for the server group
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='string', is_config=True)


  def _get_type(self):
    """
    Getter method for type, mapped from YANG variable /access_points/access_point/system/aaa/server_groups/server_group/config/type (identityref)

    YANG Description: AAA server type -- all servers in the group must be of this
type
    """
    return self.__type
      
  def _set_type(self, v, load=False):
    """
    Setter method for type, mapped from YANG variable /access_points/access_point/system/aaa/server_groups/server_group/config/type (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_type() directly.

    YANG Description: AAA server type -- all servers in the group must be of this
type
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'TACACS': {u'@namespace': u'http://openconfig.net/yang/aaa', u'@module': u'openconfig-aaa'}, u'oc-aaa:TACACS': {u'@namespace': u'http://openconfig.net/yang/aaa', u'@module': u'openconfig-aaa'}, u'RADIUS': {u'@namespace': u'http://openconfig.net/yang/aaa', u'@module': u'openconfig-aaa'}, u'oc-aaa:RADIUS': {u'@namespace': u'http://openconfig.net/yang/aaa', u'@module': u'openconfig-aaa'}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='identityref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """type must be of a type compatible with identityref""",
          'defined-type': "openconfig-access-points:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'TACACS': {u'@namespace': u'http://openconfig.net/yang/aaa', u'@module': u'openconfig-aaa'}, u'oc-aaa:TACACS': {u'@namespace': u'http://openconfig.net/yang/aaa', u'@module': u'openconfig-aaa'}, u'RADIUS': {u'@namespace': u'http://openconfig.net/yang/aaa', u'@module': u'openconfig-aaa'}, u'oc-aaa:RADIUS': {u'@namespace': u'http://openconfig.net/yang/aaa', u'@module': u'openconfig-aaa'}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='identityref', is_config=True)""",
        })

    self.__type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_type(self):
    self.__type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'TACACS': {u'@namespace': u'http://openconfig.net/yang/aaa', u'@module': u'openconfig-aaa'}, u'oc-aaa:TACACS': {u'@namespace': u'http://openconfig.net/yang/aaa', u'@module': u'openconfig-aaa'}, u'RADIUS': {u'@namespace': u'http://openconfig.net/yang/aaa', u'@module': u'openconfig-aaa'}, u'oc-aaa:RADIUS': {u'@namespace': u'http://openconfig.net/yang/aaa', u'@module': u'openconfig-aaa'}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='identityref', is_config=True)

  name = __builtin__.property(_get_name, _set_name)
  type = __builtin__.property(_get_type, _set_type)


  _pyangbind_elements = OrderedDict([('name', name), ('type', type), ])


class yc_state_openconfig_access_points__access_points_access_point_system_aaa_server_groups_server_group_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-access-points - based on the path /access-points/access-point/system/aaa/server-groups/server-group/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Operational state data for each server group
  """
  __slots__ = ('_path_helper', '_extmethods', '__name','__type',)

  _yang_name = 'state'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'TACACS': {u'@namespace': u'http://openconfig.net/yang/aaa', u'@module': u'openconfig-aaa'}, u'oc-aaa:TACACS': {u'@namespace': u'http://openconfig.net/yang/aaa', u'@module': u'openconfig-aaa'}, u'RADIUS': {u'@namespace': u'http://openconfig.net/yang/aaa', u'@module': u'openconfig-aaa'}, u'oc-aaa:RADIUS': {u'@namespace': u'http://openconfig.net/yang/aaa', u'@module': u'openconfig-aaa'}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='identityref', is_config=False)
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='string', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'access-points', u'access-point', u'system', u'aaa', u'server-groups', u'server-group', u'state']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /access_points/access_point/system/aaa/server_groups/server_group/state/name (string)

    YANG Description: Name for the server group
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /access_points/access_point/system/aaa/server_groups/server_group/state/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Name for the server group
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='string', is_config=False)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='string', is_config=False)


  def _get_type(self):
    """
    Getter method for type, mapped from YANG variable /access_points/access_point/system/aaa/server_groups/server_group/state/type (identityref)

    YANG Description: AAA server type -- all servers in the group must be of this
type
    """
    return self.__type
      
  def _set_type(self, v, load=False):
    """
    Setter method for type, mapped from YANG variable /access_points/access_point/system/aaa/server_groups/server_group/state/type (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_type() directly.

    YANG Description: AAA server type -- all servers in the group must be of this
type
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'TACACS': {u'@namespace': u'http://openconfig.net/yang/aaa', u'@module': u'openconfig-aaa'}, u'oc-aaa:TACACS': {u'@namespace': u'http://openconfig.net/yang/aaa', u'@module': u'openconfig-aaa'}, u'RADIUS': {u'@namespace': u'http://openconfig.net/yang/aaa', u'@module': u'openconfig-aaa'}, u'oc-aaa:RADIUS': {u'@namespace': u'http://openconfig.net/yang/aaa', u'@module': u'openconfig-aaa'}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='identityref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """type must be of a type compatible with identityref""",
          'defined-type': "openconfig-access-points:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'TACACS': {u'@namespace': u'http://openconfig.net/yang/aaa', u'@module': u'openconfig-aaa'}, u'oc-aaa:TACACS': {u'@namespace': u'http://openconfig.net/yang/aaa', u'@module': u'openconfig-aaa'}, u'RADIUS': {u'@namespace': u'http://openconfig.net/yang/aaa', u'@module': u'openconfig-aaa'}, u'oc-aaa:RADIUS': {u'@namespace': u'http://openconfig.net/yang/aaa', u'@module': u'openconfig-aaa'}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='identityref', is_config=False)""",
        })

    self.__type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_type(self):
    self.__type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'TACACS': {u'@namespace': u'http://openconfig.net/yang/aaa', u'@module': u'openconfig-aaa'}, u'oc-aaa:TACACS': {u'@namespace': u'http://openconfig.net/yang/aaa', u'@module': u'openconfig-aaa'}, u'RADIUS': {u'@namespace': u'http://openconfig.net/yang/aaa', u'@module': u'openconfig-aaa'}, u'oc-aaa:RADIUS': {u'@namespace': u'http://openconfig.net/yang/aaa', u'@module': u'openconfig-aaa'}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='identityref', is_config=False)

  name = __builtin__.property(_get_name)
  type = __builtin__.property(_get_type)


  _pyangbind_elements = OrderedDict([('name', name), ('type', type), ])


class yc_config_openconfig_access_points__access_points_access_point_system_aaa_server_groups_server_group_servers_server_config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-access-points - based on the path /access-points/access-point/system/aaa/server-groups/server-group/servers/server/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration data 
  """
  __slots__ = ('_path_helper', '_extmethods', '__name','__address','__timeout',)

  _yang_name = 'config'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='string', is_config=True)
    self.__timeout = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="timeout", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint16', is_config=True)
    self.__address = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])$'}),RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))$'}),], is_leaf=True, yang_name="address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-inet:ip-address', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'access-points', u'access-point', u'system', u'aaa', u'server-groups', u'server-group', u'servers', u'server', u'config']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /access_points/access_point/system/aaa/server_groups/server_group/servers/server/config/name (string)

    YANG Description: Name assigned to the server
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /access_points/access_point/system/aaa/server_groups/server_group/servers/server/config/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Name assigned to the server
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='string', is_config=True)


  def _get_address(self):
    """
    Getter method for address, mapped from YANG variable /access_points/access_point/system/aaa/server_groups/server_group/servers/server/config/address (oc-inet:ip-address)

    YANG Description: Address of the authentication server
    """
    return self.__address
      
  def _set_address(self, v, load=False):
    """
    Setter method for address, mapped from YANG variable /access_points/access_point/system/aaa/server_groups/server_group/servers/server/config/address (oc-inet:ip-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_address() directly.

    YANG Description: Address of the authentication server
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=[RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])$'}),RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))$'}),], is_leaf=True, yang_name="address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-inet:ip-address', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """address must be of a type compatible with oc-inet:ip-address""",
          'defined-type': "oc-inet:ip-address",
          'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])$'}),RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))$'}),], is_leaf=True, yang_name="address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-inet:ip-address', is_config=True)""",
        })

    self.__address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_address(self):
    self.__address = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])$'}),RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))$'}),], is_leaf=True, yang_name="address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-inet:ip-address', is_config=True)


  def _get_timeout(self):
    """
    Getter method for timeout, mapped from YANG variable /access_points/access_point/system/aaa/server_groups/server_group/servers/server/config/timeout (uint16)

    YANG Description: Set the timeout in seconds on responses from the AAA
server
    """
    return self.__timeout
      
  def _set_timeout(self, v, load=False):
    """
    Setter method for timeout, mapped from YANG variable /access_points/access_point/system/aaa/server_groups/server_group/servers/server/config/timeout (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_timeout is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_timeout() directly.

    YANG Description: Set the timeout in seconds on responses from the AAA
server
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="timeout", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """timeout must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="timeout", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint16', is_config=True)""",
        })

    self.__timeout = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_timeout(self):
    self.__timeout = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="timeout", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint16', is_config=True)

  name = __builtin__.property(_get_name, _set_name)
  address = __builtin__.property(_get_address, _set_address)
  timeout = __builtin__.property(_get_timeout, _set_timeout)


  _pyangbind_elements = OrderedDict([('name', name), ('address', address), ('timeout', timeout), ])


class yc_state_openconfig_access_points__access_points_access_point_system_aaa_server_groups_server_group_servers_server_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-access-points - based on the path /access-points/access-point/system/aaa/server-groups/server-group/servers/server/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Operational state data 
  """
  __slots__ = ('_path_helper', '_extmethods', '__name','__address','__timeout','__connection_opens','__connection_closes','__connection_aborts','__connection_failures','__connection_timeouts','__messages_sent','__messages_received','__errors_received',)

  _yang_name = 'state'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__connection_closes = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="connection-closes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)
    self.__errors_received = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="errors-received", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)
    self.__messages_received = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="messages-received", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)
    self.__messages_sent = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="messages-sent", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='string', is_config=False)
    self.__connection_opens = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="connection-opens", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)
    self.__connection_aborts = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="connection-aborts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)
    self.__connection_failures = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="connection-failures", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)
    self.__timeout = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="timeout", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint16', is_config=False)
    self.__address = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])$'}),RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))$'}),], is_leaf=True, yang_name="address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-inet:ip-address', is_config=False)
    self.__connection_timeouts = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="connection-timeouts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'access-points', u'access-point', u'system', u'aaa', u'server-groups', u'server-group', u'servers', u'server', u'state']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /access_points/access_point/system/aaa/server_groups/server_group/servers/server/state/name (string)

    YANG Description: Name assigned to the server
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /access_points/access_point/system/aaa/server_groups/server_group/servers/server/state/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Name assigned to the server
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='string', is_config=False)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='string', is_config=False)


  def _get_address(self):
    """
    Getter method for address, mapped from YANG variable /access_points/access_point/system/aaa/server_groups/server_group/servers/server/state/address (oc-inet:ip-address)

    YANG Description: Address of the authentication server
    """
    return self.__address
      
  def _set_address(self, v, load=False):
    """
    Setter method for address, mapped from YANG variable /access_points/access_point/system/aaa/server_groups/server_group/servers/server/state/address (oc-inet:ip-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_address() directly.

    YANG Description: Address of the authentication server
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=[RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])$'}),RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))$'}),], is_leaf=True, yang_name="address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-inet:ip-address', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """address must be of a type compatible with oc-inet:ip-address""",
          'defined-type': "oc-inet:ip-address",
          'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])$'}),RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))$'}),], is_leaf=True, yang_name="address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-inet:ip-address', is_config=False)""",
        })

    self.__address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_address(self):
    self.__address = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])$'}),RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))$'}),], is_leaf=True, yang_name="address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-inet:ip-address', is_config=False)


  def _get_timeout(self):
    """
    Getter method for timeout, mapped from YANG variable /access_points/access_point/system/aaa/server_groups/server_group/servers/server/state/timeout (uint16)

    YANG Description: Set the timeout in seconds on responses from the AAA
server
    """
    return self.__timeout
      
  def _set_timeout(self, v, load=False):
    """
    Setter method for timeout, mapped from YANG variable /access_points/access_point/system/aaa/server_groups/server_group/servers/server/state/timeout (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_timeout is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_timeout() directly.

    YANG Description: Set the timeout in seconds on responses from the AAA
server
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="timeout", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint16', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """timeout must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="timeout", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint16', is_config=False)""",
        })

    self.__timeout = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_timeout(self):
    self.__timeout = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="timeout", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint16', is_config=False)


  def _get_connection_opens(self):
    """
    Getter method for connection_opens, mapped from YANG variable /access_points/access_point/system/aaa/server_groups/server_group/servers/server/state/connection_opens (oc-yang:counter64)

    YANG Description: Number of new connection requests sent to the server, e.g.
socket open
    """
    return self.__connection_opens
      
  def _set_connection_opens(self, v, load=False):
    """
    Setter method for connection_opens, mapped from YANG variable /access_points/access_point/system/aaa/server_groups/server_group/servers/server/state/connection_opens (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_connection_opens is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_connection_opens() directly.

    YANG Description: Number of new connection requests sent to the server, e.g.
socket open
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="connection-opens", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """connection_opens must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="connection-opens", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__connection_opens = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_connection_opens(self):
    self.__connection_opens = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="connection-opens", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)


  def _get_connection_closes(self):
    """
    Getter method for connection_closes, mapped from YANG variable /access_points/access_point/system/aaa/server_groups/server_group/servers/server/state/connection_closes (oc-yang:counter64)

    YANG Description: Number of connection close requests sent to the server, e.g.
socket close
    """
    return self.__connection_closes
      
  def _set_connection_closes(self, v, load=False):
    """
    Setter method for connection_closes, mapped from YANG variable /access_points/access_point/system/aaa/server_groups/server_group/servers/server/state/connection_closes (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_connection_closes is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_connection_closes() directly.

    YANG Description: Number of connection close requests sent to the server, e.g.
socket close
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="connection-closes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """connection_closes must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="connection-closes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__connection_closes = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_connection_closes(self):
    self.__connection_closes = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="connection-closes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)


  def _get_connection_aborts(self):
    """
    Getter method for connection_aborts, mapped from YANG variable /access_points/access_point/system/aaa/server_groups/server_group/servers/server/state/connection_aborts (oc-yang:counter64)

    YANG Description: Number of aborted connections to the server.  These do
not include connections that are close gracefully.
    """
    return self.__connection_aborts
      
  def _set_connection_aborts(self, v, load=False):
    """
    Setter method for connection_aborts, mapped from YANG variable /access_points/access_point/system/aaa/server_groups/server_group/servers/server/state/connection_aborts (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_connection_aborts is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_connection_aborts() directly.

    YANG Description: Number of aborted connections to the server.  These do
not include connections that are close gracefully.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="connection-aborts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """connection_aborts must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="connection-aborts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__connection_aborts = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_connection_aborts(self):
    self.__connection_aborts = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="connection-aborts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)


  def _get_connection_failures(self):
    """
    Getter method for connection_failures, mapped from YANG variable /access_points/access_point/system/aaa/server_groups/server_group/servers/server/state/connection_failures (oc-yang:counter64)

    YANG Description: Number of connection failures to the server
    """
    return self.__connection_failures
      
  def _set_connection_failures(self, v, load=False):
    """
    Setter method for connection_failures, mapped from YANG variable /access_points/access_point/system/aaa/server_groups/server_group/servers/server/state/connection_failures (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_connection_failures is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_connection_failures() directly.

    YANG Description: Number of connection failures to the server
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="connection-failures", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """connection_failures must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="connection-failures", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__connection_failures = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_connection_failures(self):
    self.__connection_failures = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="connection-failures", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)


  def _get_connection_timeouts(self):
    """
    Getter method for connection_timeouts, mapped from YANG variable /access_points/access_point/system/aaa/server_groups/server_group/servers/server/state/connection_timeouts (oc-yang:counter64)

    YANG Description: Number of connection timeouts to the server
    """
    return self.__connection_timeouts
      
  def _set_connection_timeouts(self, v, load=False):
    """
    Setter method for connection_timeouts, mapped from YANG variable /access_points/access_point/system/aaa/server_groups/server_group/servers/server/state/connection_timeouts (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_connection_timeouts is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_connection_timeouts() directly.

    YANG Description: Number of connection timeouts to the server
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="connection-timeouts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """connection_timeouts must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="connection-timeouts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__connection_timeouts = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_connection_timeouts(self):
    self.__connection_timeouts = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="connection-timeouts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)


  def _get_messages_sent(self):
    """
    Getter method for messages_sent, mapped from YANG variable /access_points/access_point/system/aaa/server_groups/server_group/servers/server/state/messages_sent (oc-yang:counter64)

    YANG Description: Number of messages sent to the server
    """
    return self.__messages_sent
      
  def _set_messages_sent(self, v, load=False):
    """
    Setter method for messages_sent, mapped from YANG variable /access_points/access_point/system/aaa/server_groups/server_group/servers/server/state/messages_sent (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_messages_sent is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_messages_sent() directly.

    YANG Description: Number of messages sent to the server
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="messages-sent", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """messages_sent must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="messages-sent", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__messages_sent = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_messages_sent(self):
    self.__messages_sent = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="messages-sent", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)


  def _get_messages_received(self):
    """
    Getter method for messages_received, mapped from YANG variable /access_points/access_point/system/aaa/server_groups/server_group/servers/server/state/messages_received (oc-yang:counter64)

    YANG Description: Number of messages received by the server
    """
    return self.__messages_received
      
  def _set_messages_received(self, v, load=False):
    """
    Setter method for messages_received, mapped from YANG variable /access_points/access_point/system/aaa/server_groups/server_group/servers/server/state/messages_received (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_messages_received is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_messages_received() directly.

    YANG Description: Number of messages received by the server
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="messages-received", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """messages_received must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="messages-received", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__messages_received = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_messages_received(self):
    self.__messages_received = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="messages-received", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)


  def _get_errors_received(self):
    """
    Getter method for errors_received, mapped from YANG variable /access_points/access_point/system/aaa/server_groups/server_group/servers/server/state/errors_received (oc-yang:counter64)

    YANG Description: Number of error messages received from the server
    """
    return self.__errors_received
      
  def _set_errors_received(self, v, load=False):
    """
    Setter method for errors_received, mapped from YANG variable /access_points/access_point/system/aaa/server_groups/server_group/servers/server/state/errors_received (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_errors_received is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_errors_received() directly.

    YANG Description: Number of error messages received from the server
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="errors-received", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """errors_received must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="errors-received", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__errors_received = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_errors_received(self):
    self.__errors_received = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="errors-received", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)

  name = __builtin__.property(_get_name)
  address = __builtin__.property(_get_address)
  timeout = __builtin__.property(_get_timeout)
  connection_opens = __builtin__.property(_get_connection_opens)
  connection_closes = __builtin__.property(_get_connection_closes)
  connection_aborts = __builtin__.property(_get_connection_aborts)
  connection_failures = __builtin__.property(_get_connection_failures)
  connection_timeouts = __builtin__.property(_get_connection_timeouts)
  messages_sent = __builtin__.property(_get_messages_sent)
  messages_received = __builtin__.property(_get_messages_received)
  errors_received = __builtin__.property(_get_errors_received)


  _pyangbind_elements = OrderedDict([('name', name), ('address', address), ('timeout', timeout), ('connection_opens', connection_opens), ('connection_closes', connection_closes), ('connection_aborts', connection_aborts), ('connection_failures', connection_failures), ('connection_timeouts', connection_timeouts), ('messages_sent', messages_sent), ('messages_received', messages_received), ('errors_received', errors_received), ])


class yc_config_openconfig_access_points__access_points_access_point_system_aaa_server_groups_server_group_servers_server_tacacs_config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-access-points - based on the path /access-points/access-point/system/aaa/server-groups/server-group/servers/server/tacacs/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration data for TACACS+ server
  """
  __slots__ = ('_path_helper', '_extmethods', '__port','__secret_key','__source_address',)

  _yang_name = 'config'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__secret_key = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="secret-key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:routing-password', is_config=True)
    self.__source_address = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])$'}),RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))$'}),], is_leaf=True, yang_name="source-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-inet:ip-address', is_config=True)
    self.__port = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(49), is_leaf=True, yang_name="port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-inet:port-number', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'access-points', u'access-point', u'system', u'aaa', u'server-groups', u'server-group', u'servers', u'server', u'tacacs', u'config']

  def _get_port(self):
    """
    Getter method for port, mapped from YANG variable /access_points/access_point/system/aaa/server_groups/server_group/servers/server/tacacs/config/port (oc-inet:port-number)

    YANG Description: The port number on which to contact the TACACS server
    """
    return self.__port
      
  def _set_port(self, v, load=False):
    """
    Setter method for port, mapped from YANG variable /access_points/access_point/system/aaa/server_groups/server_group/servers/server/tacacs/config/port (oc-inet:port-number)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_port is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_port() directly.

    YANG Description: The port number on which to contact the TACACS server
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(49), is_leaf=True, yang_name="port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-inet:port-number', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """port must be of a type compatible with oc-inet:port-number""",
          'defined-type': "oc-inet:port-number",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(49), is_leaf=True, yang_name="port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-inet:port-number', is_config=True)""",
        })

    self.__port = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_port(self):
    self.__port = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(49), is_leaf=True, yang_name="port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-inet:port-number', is_config=True)


  def _get_secret_key(self):
    """
    Getter method for secret_key, mapped from YANG variable /access_points/access_point/system/aaa/server_groups/server_group/servers/server/tacacs/config/secret_key (oc-types:routing-password)

    YANG Description: The unencrypted shared key used between the authentication
server and the device.
    """
    return self.__secret_key
      
  def _set_secret_key(self, v, load=False):
    """
    Setter method for secret_key, mapped from YANG variable /access_points/access_point/system/aaa/server_groups/server_group/servers/server/tacacs/config/secret_key (oc-types:routing-password)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_secret_key is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_secret_key() directly.

    YANG Description: The unencrypted shared key used between the authentication
server and the device.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="secret-key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:routing-password', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """secret_key must be of a type compatible with oc-types:routing-password""",
          'defined-type': "oc-types:routing-password",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="secret-key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:routing-password', is_config=True)""",
        })

    self.__secret_key = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_secret_key(self):
    self.__secret_key = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="secret-key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:routing-password', is_config=True)


  def _get_source_address(self):
    """
    Getter method for source_address, mapped from YANG variable /access_points/access_point/system/aaa/server_groups/server_group/servers/server/tacacs/config/source_address (oc-inet:ip-address)

    YANG Description: Source IP address to use in messages to the TACACS server
    """
    return self.__source_address
      
  def _set_source_address(self, v, load=False):
    """
    Setter method for source_address, mapped from YANG variable /access_points/access_point/system/aaa/server_groups/server_group/servers/server/tacacs/config/source_address (oc-inet:ip-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_source_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_source_address() directly.

    YANG Description: Source IP address to use in messages to the TACACS server
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=[RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])$'}),RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))$'}),], is_leaf=True, yang_name="source-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-inet:ip-address', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """source_address must be of a type compatible with oc-inet:ip-address""",
          'defined-type': "oc-inet:ip-address",
          'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])$'}),RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))$'}),], is_leaf=True, yang_name="source-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-inet:ip-address', is_config=True)""",
        })

    self.__source_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_source_address(self):
    self.__source_address = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])$'}),RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))$'}),], is_leaf=True, yang_name="source-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-inet:ip-address', is_config=True)

  port = __builtin__.property(_get_port, _set_port)
  secret_key = __builtin__.property(_get_secret_key, _set_secret_key)
  source_address = __builtin__.property(_get_source_address, _set_source_address)


  _pyangbind_elements = OrderedDict([('port', port), ('secret_key', secret_key), ('source_address', source_address), ])


class yc_state_openconfig_access_points__access_points_access_point_system_aaa_server_groups_server_group_servers_server_tacacs_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-access-points - based on the path /access-points/access-point/system/aaa/server-groups/server-group/servers/server/tacacs/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Operational state data for TACACS+ server
  """
  __slots__ = ('_path_helper', '_extmethods', '__port','__secret_key','__source_address',)

  _yang_name = 'state'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__secret_key = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="secret-key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:routing-password', is_config=False)
    self.__source_address = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])$'}),RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))$'}),], is_leaf=True, yang_name="source-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-inet:ip-address', is_config=False)
    self.__port = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(49), is_leaf=True, yang_name="port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-inet:port-number', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'access-points', u'access-point', u'system', u'aaa', u'server-groups', u'server-group', u'servers', u'server', u'tacacs', u'state']

  def _get_port(self):
    """
    Getter method for port, mapped from YANG variable /access_points/access_point/system/aaa/server_groups/server_group/servers/server/tacacs/state/port (oc-inet:port-number)

    YANG Description: The port number on which to contact the TACACS server
    """
    return self.__port
      
  def _set_port(self, v, load=False):
    """
    Setter method for port, mapped from YANG variable /access_points/access_point/system/aaa/server_groups/server_group/servers/server/tacacs/state/port (oc-inet:port-number)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_port is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_port() directly.

    YANG Description: The port number on which to contact the TACACS server
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(49), is_leaf=True, yang_name="port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-inet:port-number', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """port must be of a type compatible with oc-inet:port-number""",
          'defined-type': "oc-inet:port-number",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(49), is_leaf=True, yang_name="port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-inet:port-number', is_config=False)""",
        })

    self.__port = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_port(self):
    self.__port = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(49), is_leaf=True, yang_name="port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-inet:port-number', is_config=False)


  def _get_secret_key(self):
    """
    Getter method for secret_key, mapped from YANG variable /access_points/access_point/system/aaa/server_groups/server_group/servers/server/tacacs/state/secret_key (oc-types:routing-password)

    YANG Description: The unencrypted shared key used between the authentication
server and the device.
    """
    return self.__secret_key
      
  def _set_secret_key(self, v, load=False):
    """
    Setter method for secret_key, mapped from YANG variable /access_points/access_point/system/aaa/server_groups/server_group/servers/server/tacacs/state/secret_key (oc-types:routing-password)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_secret_key is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_secret_key() directly.

    YANG Description: The unencrypted shared key used between the authentication
server and the device.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="secret-key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:routing-password', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """secret_key must be of a type compatible with oc-types:routing-password""",
          'defined-type': "oc-types:routing-password",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="secret-key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:routing-password', is_config=False)""",
        })

    self.__secret_key = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_secret_key(self):
    self.__secret_key = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="secret-key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:routing-password', is_config=False)


  def _get_source_address(self):
    """
    Getter method for source_address, mapped from YANG variable /access_points/access_point/system/aaa/server_groups/server_group/servers/server/tacacs/state/source_address (oc-inet:ip-address)

    YANG Description: Source IP address to use in messages to the TACACS server
    """
    return self.__source_address
      
  def _set_source_address(self, v, load=False):
    """
    Setter method for source_address, mapped from YANG variable /access_points/access_point/system/aaa/server_groups/server_group/servers/server/tacacs/state/source_address (oc-inet:ip-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_source_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_source_address() directly.

    YANG Description: Source IP address to use in messages to the TACACS server
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=[RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])$'}),RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))$'}),], is_leaf=True, yang_name="source-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-inet:ip-address', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """source_address must be of a type compatible with oc-inet:ip-address""",
          'defined-type': "oc-inet:ip-address",
          'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])$'}),RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))$'}),], is_leaf=True, yang_name="source-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-inet:ip-address', is_config=False)""",
        })

    self.__source_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_source_address(self):
    self.__source_address = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])$'}),RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))$'}),], is_leaf=True, yang_name="source-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-inet:ip-address', is_config=False)

  port = __builtin__.property(_get_port)
  secret_key = __builtin__.property(_get_secret_key)
  source_address = __builtin__.property(_get_source_address)


  _pyangbind_elements = OrderedDict([('port', port), ('secret_key', secret_key), ('source_address', source_address), ])


class yc_tacacs_openconfig_access_points__access_points_access_point_system_aaa_server_groups_server_group_servers_server_tacacs(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-access-points - based on the path /access-points/access-point/system/aaa/server-groups/server-group/servers/server/tacacs. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Top-level container for TACACS+ server data
  """
  __slots__ = ('_path_helper', '_extmethods', '__config','__state',)

  _yang_name = 'tacacs'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__state = YANGDynClass(base=yc_state_openconfig_access_points__access_points_access_point_system_aaa_server_groups_server_group_servers_server_tacacs_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)
    self.__config = YANGDynClass(base=yc_config_openconfig_access_points__access_points_access_point_system_aaa_server_groups_server_group_servers_server_tacacs_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'access-points', u'access-point', u'system', u'aaa', u'server-groups', u'server-group', u'servers', u'server', u'tacacs']

  def _get_config(self):
    """
    Getter method for config, mapped from YANG variable /access_points/access_point/system/aaa/server_groups/server_group/servers/server/tacacs/config (container)

    YANG Description: Configuration data for TACACS+ server
    """
    return self.__config
      
  def _set_config(self, v, load=False):
    """
    Setter method for config, mapped from YANG variable /access_points/access_point/system/aaa/server_groups/server_group/servers/server/tacacs/config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config() directly.

    YANG Description: Configuration data for TACACS+ server
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_config_openconfig_access_points__access_points_access_point_system_aaa_server_groups_server_group_servers_server_tacacs_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_config_openconfig_access_points__access_points_access_point_system_aaa_server_groups_server_group_servers_server_tacacs_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)""",
        })

    self.__config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config(self):
    self.__config = YANGDynClass(base=yc_config_openconfig_access_points__access_points_access_point_system_aaa_server_groups_server_group_servers_server_tacacs_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /access_points/access_point/system/aaa/server_groups/server_group/servers/server/tacacs/state (container)

    YANG Description: Operational state data for TACACS+ server
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /access_points/access_point/system/aaa/server_groups/server_group/servers/server/tacacs/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: Operational state data for TACACS+ server
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_access_points__access_points_access_point_system_aaa_server_groups_server_group_servers_server_tacacs_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_access_points__access_points_access_point_system_aaa_server_groups_server_group_servers_server_tacacs_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_access_points__access_points_access_point_system_aaa_server_groups_server_group_servers_server_tacacs_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)

  config = __builtin__.property(_get_config, _set_config)
  state = __builtin__.property(_get_state, _set_state)


  _pyangbind_elements = OrderedDict([('config', config), ('state', state), ])


class yc_config_openconfig_access_points__access_points_access_point_system_aaa_server_groups_server_group_servers_server_radius_config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-access-points - based on the path /access-points/access-point/system/aaa/server-groups/server-group/servers/server/radius/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration data for RADIUS servers
  """
  __slots__ = ('_path_helper', '_extmethods', '__auth_port','__acct_port','__secret_key','__source_address','__retransmit_attempts',)

  _yang_name = 'config'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__acct_port = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(1813), is_leaf=True, yang_name="acct-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-inet:port-number', is_config=True)
    self.__secret_key = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="secret-key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:routing-password', is_config=True)
    self.__retransmit_attempts = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="retransmit-attempts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint8', is_config=True)
    self.__source_address = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])$'}),RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))$'}),], is_leaf=True, yang_name="source-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-inet:ip-address', is_config=True)
    self.__auth_port = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(1812), is_leaf=True, yang_name="auth-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-inet:port-number', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'access-points', u'access-point', u'system', u'aaa', u'server-groups', u'server-group', u'servers', u'server', u'radius', u'config']

  def _get_auth_port(self):
    """
    Getter method for auth_port, mapped from YANG variable /access_points/access_point/system/aaa/server_groups/server_group/servers/server/radius/config/auth_port (oc-inet:port-number)

    YANG Description: Port number for authentication requests
    """
    return self.__auth_port
      
  def _set_auth_port(self, v, load=False):
    """
    Setter method for auth_port, mapped from YANG variable /access_points/access_point/system/aaa/server_groups/server_group/servers/server/radius/config/auth_port (oc-inet:port-number)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_auth_port is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_auth_port() directly.

    YANG Description: Port number for authentication requests
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(1812), is_leaf=True, yang_name="auth-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-inet:port-number', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """auth_port must be of a type compatible with oc-inet:port-number""",
          'defined-type': "oc-inet:port-number",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(1812), is_leaf=True, yang_name="auth-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-inet:port-number', is_config=True)""",
        })

    self.__auth_port = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_auth_port(self):
    self.__auth_port = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(1812), is_leaf=True, yang_name="auth-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-inet:port-number', is_config=True)


  def _get_acct_port(self):
    """
    Getter method for acct_port, mapped from YANG variable /access_points/access_point/system/aaa/server_groups/server_group/servers/server/radius/config/acct_port (oc-inet:port-number)

    YANG Description: Port number for accounting requests
    """
    return self.__acct_port
      
  def _set_acct_port(self, v, load=False):
    """
    Setter method for acct_port, mapped from YANG variable /access_points/access_point/system/aaa/server_groups/server_group/servers/server/radius/config/acct_port (oc-inet:port-number)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_acct_port is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_acct_port() directly.

    YANG Description: Port number for accounting requests
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(1813), is_leaf=True, yang_name="acct-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-inet:port-number', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """acct_port must be of a type compatible with oc-inet:port-number""",
          'defined-type': "oc-inet:port-number",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(1813), is_leaf=True, yang_name="acct-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-inet:port-number', is_config=True)""",
        })

    self.__acct_port = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_acct_port(self):
    self.__acct_port = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(1813), is_leaf=True, yang_name="acct-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-inet:port-number', is_config=True)


  def _get_secret_key(self):
    """
    Getter method for secret_key, mapped from YANG variable /access_points/access_point/system/aaa/server_groups/server_group/servers/server/radius/config/secret_key (oc-types:routing-password)

    YANG Description: The unencrypted shared key used between the authentication
server and the device.
    """
    return self.__secret_key
      
  def _set_secret_key(self, v, load=False):
    """
    Setter method for secret_key, mapped from YANG variable /access_points/access_point/system/aaa/server_groups/server_group/servers/server/radius/config/secret_key (oc-types:routing-password)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_secret_key is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_secret_key() directly.

    YANG Description: The unencrypted shared key used between the authentication
server and the device.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="secret-key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:routing-password', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """secret_key must be of a type compatible with oc-types:routing-password""",
          'defined-type': "oc-types:routing-password",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="secret-key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:routing-password', is_config=True)""",
        })

    self.__secret_key = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_secret_key(self):
    self.__secret_key = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="secret-key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:routing-password', is_config=True)


  def _get_source_address(self):
    """
    Getter method for source_address, mapped from YANG variable /access_points/access_point/system/aaa/server_groups/server_group/servers/server/radius/config/source_address (oc-inet:ip-address)

    YANG Description: Source IP address to use in messages to the RADIUS server
    """
    return self.__source_address
      
  def _set_source_address(self, v, load=False):
    """
    Setter method for source_address, mapped from YANG variable /access_points/access_point/system/aaa/server_groups/server_group/servers/server/radius/config/source_address (oc-inet:ip-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_source_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_source_address() directly.

    YANG Description: Source IP address to use in messages to the RADIUS server
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=[RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])$'}),RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))$'}),], is_leaf=True, yang_name="source-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-inet:ip-address', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """source_address must be of a type compatible with oc-inet:ip-address""",
          'defined-type': "oc-inet:ip-address",
          'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])$'}),RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))$'}),], is_leaf=True, yang_name="source-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-inet:ip-address', is_config=True)""",
        })

    self.__source_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_source_address(self):
    self.__source_address = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])$'}),RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))$'}),], is_leaf=True, yang_name="source-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-inet:ip-address', is_config=True)


  def _get_retransmit_attempts(self):
    """
    Getter method for retransmit_attempts, mapped from YANG variable /access_points/access_point/system/aaa/server_groups/server_group/servers/server/radius/config/retransmit_attempts (uint8)

    YANG Description: Number of times the system may resend a request to the
RADIUS server when it is unresponsive
    """
    return self.__retransmit_attempts
      
  def _set_retransmit_attempts(self, v, load=False):
    """
    Setter method for retransmit_attempts, mapped from YANG variable /access_points/access_point/system/aaa/server_groups/server_group/servers/server/radius/config/retransmit_attempts (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_retransmit_attempts is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_retransmit_attempts() directly.

    YANG Description: Number of times the system may resend a request to the
RADIUS server when it is unresponsive
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="retransmit-attempts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """retransmit_attempts must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="retransmit-attempts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint8', is_config=True)""",
        })

    self.__retransmit_attempts = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_retransmit_attempts(self):
    self.__retransmit_attempts = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="retransmit-attempts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint8', is_config=True)

  auth_port = __builtin__.property(_get_auth_port, _set_auth_port)
  acct_port = __builtin__.property(_get_acct_port, _set_acct_port)
  secret_key = __builtin__.property(_get_secret_key, _set_secret_key)
  source_address = __builtin__.property(_get_source_address, _set_source_address)
  retransmit_attempts = __builtin__.property(_get_retransmit_attempts, _set_retransmit_attempts)


  _pyangbind_elements = OrderedDict([('auth_port', auth_port), ('acct_port', acct_port), ('secret_key', secret_key), ('source_address', source_address), ('retransmit_attempts', retransmit_attempts), ])


class yc_counters_openconfig_access_points__access_points_access_point_system_aaa_server_groups_server_group_servers_server_radius_state_counters(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-access-points - based on the path /access-points/access-point/system/aaa/server-groups/server-group/servers/server/radius/state/counters. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: A collection of RADIUS related state objects.
  """
  __slots__ = ('_path_helper', '_extmethods', '__retried_access_requests','__access_accepts','__access_rejects','__timeout_access_requests',)

  _yang_name = 'counters'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__retried_access_requests = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="retried-access-requests", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)
    self.__access_rejects = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="access-rejects", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)
    self.__timeout_access_requests = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="timeout-access-requests", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)
    self.__access_accepts = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="access-accepts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'access-points', u'access-point', u'system', u'aaa', u'server-groups', u'server-group', u'servers', u'server', u'radius', u'state', u'counters']

  def _get_retried_access_requests(self):
    """
    Getter method for retried_access_requests, mapped from YANG variable /access_points/access_point/system/aaa/server_groups/server_group/servers/server/radius/state/counters/retried_access_requests (oc-yang:counter64)

    YANG Description: Retransmitted Access-Request messages.
    """
    return self.__retried_access_requests
      
  def _set_retried_access_requests(self, v, load=False):
    """
    Setter method for retried_access_requests, mapped from YANG variable /access_points/access_point/system/aaa/server_groups/server_group/servers/server/radius/state/counters/retried_access_requests (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_retried_access_requests is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_retried_access_requests() directly.

    YANG Description: Retransmitted Access-Request messages.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="retried-access-requests", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """retried_access_requests must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="retried-access-requests", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__retried_access_requests = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_retried_access_requests(self):
    self.__retried_access_requests = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="retried-access-requests", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)


  def _get_access_accepts(self):
    """
    Getter method for access_accepts, mapped from YANG variable /access_points/access_point/system/aaa/server_groups/server_group/servers/server/radius/state/counters/access_accepts (oc-yang:counter64)

    YANG Description: Received Access-Accept messages.
    """
    return self.__access_accepts
      
  def _set_access_accepts(self, v, load=False):
    """
    Setter method for access_accepts, mapped from YANG variable /access_points/access_point/system/aaa/server_groups/server_group/servers/server/radius/state/counters/access_accepts (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_access_accepts is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_access_accepts() directly.

    YANG Description: Received Access-Accept messages.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="access-accepts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """access_accepts must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="access-accepts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__access_accepts = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_access_accepts(self):
    self.__access_accepts = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="access-accepts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)


  def _get_access_rejects(self):
    """
    Getter method for access_rejects, mapped from YANG variable /access_points/access_point/system/aaa/server_groups/server_group/servers/server/radius/state/counters/access_rejects (oc-yang:counter64)

    YANG Description: Received Access-Reject messages.
    """
    return self.__access_rejects
      
  def _set_access_rejects(self, v, load=False):
    """
    Setter method for access_rejects, mapped from YANG variable /access_points/access_point/system/aaa/server_groups/server_group/servers/server/radius/state/counters/access_rejects (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_access_rejects is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_access_rejects() directly.

    YANG Description: Received Access-Reject messages.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="access-rejects", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """access_rejects must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="access-rejects", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__access_rejects = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_access_rejects(self):
    self.__access_rejects = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="access-rejects", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)


  def _get_timeout_access_requests(self):
    """
    Getter method for timeout_access_requests, mapped from YANG variable /access_points/access_point/system/aaa/server_groups/server_group/servers/server/radius/state/counters/timeout_access_requests (oc-yang:counter64)

    YANG Description: Access-Request messages that have timed-out,
requiring retransmission.
    """
    return self.__timeout_access_requests
      
  def _set_timeout_access_requests(self, v, load=False):
    """
    Setter method for timeout_access_requests, mapped from YANG variable /access_points/access_point/system/aaa/server_groups/server_group/servers/server/radius/state/counters/timeout_access_requests (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_timeout_access_requests is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_timeout_access_requests() directly.

    YANG Description: Access-Request messages that have timed-out,
requiring retransmission.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="timeout-access-requests", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """timeout_access_requests must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="timeout-access-requests", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__timeout_access_requests = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_timeout_access_requests(self):
    self.__timeout_access_requests = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="timeout-access-requests", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:counter64', is_config=False)

  retried_access_requests = __builtin__.property(_get_retried_access_requests)
  access_accepts = __builtin__.property(_get_access_accepts)
  access_rejects = __builtin__.property(_get_access_rejects)
  timeout_access_requests = __builtin__.property(_get_timeout_access_requests)


  _pyangbind_elements = OrderedDict([('retried_access_requests', retried_access_requests), ('access_accepts', access_accepts), ('access_rejects', access_rejects), ('timeout_access_requests', timeout_access_requests), ])


class yc_state_openconfig_access_points__access_points_access_point_system_aaa_server_groups_server_group_servers_server_radius_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-access-points - based on the path /access-points/access-point/system/aaa/server-groups/server-group/servers/server/radius/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Operational state data for RADIUS servers
  """
  __slots__ = ('_path_helper', '_extmethods', '__auth_port','__acct_port','__secret_key','__source_address','__retransmit_attempts','__counters',)

  _yang_name = 'state'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__retransmit_attempts = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="retransmit-attempts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint8', is_config=False)
    self.__auth_port = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(1812), is_leaf=True, yang_name="auth-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-inet:port-number', is_config=False)
    self.__acct_port = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(1813), is_leaf=True, yang_name="acct-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-inet:port-number', is_config=False)
    self.__secret_key = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="secret-key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:routing-password', is_config=False)
    self.__source_address = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])$'}),RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))$'}),], is_leaf=True, yang_name="source-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-inet:ip-address', is_config=False)
    self.__counters = YANGDynClass(base=yc_counters_openconfig_access_points__access_points_access_point_system_aaa_server_groups_server_group_servers_server_radius_state_counters, is_container='container', yang_name="counters", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'access-points', u'access-point', u'system', u'aaa', u'server-groups', u'server-group', u'servers', u'server', u'radius', u'state']

  def _get_auth_port(self):
    """
    Getter method for auth_port, mapped from YANG variable /access_points/access_point/system/aaa/server_groups/server_group/servers/server/radius/state/auth_port (oc-inet:port-number)

    YANG Description: Port number for authentication requests
    """
    return self.__auth_port
      
  def _set_auth_port(self, v, load=False):
    """
    Setter method for auth_port, mapped from YANG variable /access_points/access_point/system/aaa/server_groups/server_group/servers/server/radius/state/auth_port (oc-inet:port-number)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_auth_port is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_auth_port() directly.

    YANG Description: Port number for authentication requests
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(1812), is_leaf=True, yang_name="auth-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-inet:port-number', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """auth_port must be of a type compatible with oc-inet:port-number""",
          'defined-type': "oc-inet:port-number",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(1812), is_leaf=True, yang_name="auth-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-inet:port-number', is_config=False)""",
        })

    self.__auth_port = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_auth_port(self):
    self.__auth_port = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(1812), is_leaf=True, yang_name="auth-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-inet:port-number', is_config=False)


  def _get_acct_port(self):
    """
    Getter method for acct_port, mapped from YANG variable /access_points/access_point/system/aaa/server_groups/server_group/servers/server/radius/state/acct_port (oc-inet:port-number)

    YANG Description: Port number for accounting requests
    """
    return self.__acct_port
      
  def _set_acct_port(self, v, load=False):
    """
    Setter method for acct_port, mapped from YANG variable /access_points/access_point/system/aaa/server_groups/server_group/servers/server/radius/state/acct_port (oc-inet:port-number)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_acct_port is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_acct_port() directly.

    YANG Description: Port number for accounting requests
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(1813), is_leaf=True, yang_name="acct-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-inet:port-number', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """acct_port must be of a type compatible with oc-inet:port-number""",
          'defined-type': "oc-inet:port-number",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(1813), is_leaf=True, yang_name="acct-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-inet:port-number', is_config=False)""",
        })

    self.__acct_port = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_acct_port(self):
    self.__acct_port = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(1813), is_leaf=True, yang_name="acct-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-inet:port-number', is_config=False)


  def _get_secret_key(self):
    """
    Getter method for secret_key, mapped from YANG variable /access_points/access_point/system/aaa/server_groups/server_group/servers/server/radius/state/secret_key (oc-types:routing-password)

    YANG Description: The unencrypted shared key used between the authentication
server and the device.
    """
    return self.__secret_key
      
  def _set_secret_key(self, v, load=False):
    """
    Setter method for secret_key, mapped from YANG variable /access_points/access_point/system/aaa/server_groups/server_group/servers/server/radius/state/secret_key (oc-types:routing-password)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_secret_key is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_secret_key() directly.

    YANG Description: The unencrypted shared key used between the authentication
server and the device.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="secret-key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:routing-password', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """secret_key must be of a type compatible with oc-types:routing-password""",
          'defined-type': "oc-types:routing-password",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="secret-key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:routing-password', is_config=False)""",
        })

    self.__secret_key = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_secret_key(self):
    self.__secret_key = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="secret-key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:routing-password', is_config=False)


  def _get_source_address(self):
    """
    Getter method for source_address, mapped from YANG variable /access_points/access_point/system/aaa/server_groups/server_group/servers/server/radius/state/source_address (oc-inet:ip-address)

    YANG Description: Source IP address to use in messages to the RADIUS server
    """
    return self.__source_address
      
  def _set_source_address(self, v, load=False):
    """
    Setter method for source_address, mapped from YANG variable /access_points/access_point/system/aaa/server_groups/server_group/servers/server/radius/state/source_address (oc-inet:ip-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_source_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_source_address() directly.

    YANG Description: Source IP address to use in messages to the RADIUS server
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=[RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])$'}),RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))$'}),], is_leaf=True, yang_name="source-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-inet:ip-address', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """source_address must be of a type compatible with oc-inet:ip-address""",
          'defined-type': "oc-inet:ip-address",
          'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])$'}),RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))$'}),], is_leaf=True, yang_name="source-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-inet:ip-address', is_config=False)""",
        })

    self.__source_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_source_address(self):
    self.__source_address = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])$'}),RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))$'}),], is_leaf=True, yang_name="source-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-inet:ip-address', is_config=False)


  def _get_retransmit_attempts(self):
    """
    Getter method for retransmit_attempts, mapped from YANG variable /access_points/access_point/system/aaa/server_groups/server_group/servers/server/radius/state/retransmit_attempts (uint8)

    YANG Description: Number of times the system may resend a request to the
RADIUS server when it is unresponsive
    """
    return self.__retransmit_attempts
      
  def _set_retransmit_attempts(self, v, load=False):
    """
    Setter method for retransmit_attempts, mapped from YANG variable /access_points/access_point/system/aaa/server_groups/server_group/servers/server/radius/state/retransmit_attempts (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_retransmit_attempts is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_retransmit_attempts() directly.

    YANG Description: Number of times the system may resend a request to the
RADIUS server when it is unresponsive
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="retransmit-attempts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint8', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """retransmit_attempts must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="retransmit-attempts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint8', is_config=False)""",
        })

    self.__retransmit_attempts = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_retransmit_attempts(self):
    self.__retransmit_attempts = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="retransmit-attempts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint8', is_config=False)


  def _get_counters(self):
    """
    Getter method for counters, mapped from YANG variable /access_points/access_point/system/aaa/server_groups/server_group/servers/server/radius/state/counters (container)

    YANG Description: A collection of RADIUS related state objects.
    """
    return self.__counters
      
  def _set_counters(self, v, load=False):
    """
    Setter method for counters, mapped from YANG variable /access_points/access_point/system/aaa/server_groups/server_group/servers/server/radius/state/counters (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_counters is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_counters() directly.

    YANG Description: A collection of RADIUS related state objects.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_counters_openconfig_access_points__access_points_access_point_system_aaa_server_groups_server_group_servers_server_radius_state_counters, is_container='container', yang_name="counters", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """counters must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_counters_openconfig_access_points__access_points_access_point_system_aaa_server_groups_server_group_servers_server_radius_state_counters, is_container='container', yang_name="counters", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=False)""",
        })

    self.__counters = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_counters(self):
    self.__counters = YANGDynClass(base=yc_counters_openconfig_access_points__access_points_access_point_system_aaa_server_groups_server_group_servers_server_radius_state_counters, is_container='container', yang_name="counters", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=False)

  auth_port = __builtin__.property(_get_auth_port)
  acct_port = __builtin__.property(_get_acct_port)
  secret_key = __builtin__.property(_get_secret_key)
  source_address = __builtin__.property(_get_source_address)
  retransmit_attempts = __builtin__.property(_get_retransmit_attempts)
  counters = __builtin__.property(_get_counters)


  _pyangbind_elements = OrderedDict([('auth_port', auth_port), ('acct_port', acct_port), ('secret_key', secret_key), ('source_address', source_address), ('retransmit_attempts', retransmit_attempts), ('counters', counters), ])


class yc_radius_openconfig_access_points__access_points_access_point_system_aaa_server_groups_server_group_servers_server_radius(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-access-points - based on the path /access-points/access-point/system/aaa/server-groups/server-group/servers/server/radius. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Top-level container for RADIUS server data
  """
  __slots__ = ('_path_helper', '_extmethods', '__config','__state',)

  _yang_name = 'radius'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__state = YANGDynClass(base=yc_state_openconfig_access_points__access_points_access_point_system_aaa_server_groups_server_group_servers_server_radius_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)
    self.__config = YANGDynClass(base=yc_config_openconfig_access_points__access_points_access_point_system_aaa_server_groups_server_group_servers_server_radius_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'access-points', u'access-point', u'system', u'aaa', u'server-groups', u'server-group', u'servers', u'server', u'radius']

  def _get_config(self):
    """
    Getter method for config, mapped from YANG variable /access_points/access_point/system/aaa/server_groups/server_group/servers/server/radius/config (container)

    YANG Description: Configuration data for RADIUS servers
    """
    return self.__config
      
  def _set_config(self, v, load=False):
    """
    Setter method for config, mapped from YANG variable /access_points/access_point/system/aaa/server_groups/server_group/servers/server/radius/config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config() directly.

    YANG Description: Configuration data for RADIUS servers
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_config_openconfig_access_points__access_points_access_point_system_aaa_server_groups_server_group_servers_server_radius_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_config_openconfig_access_points__access_points_access_point_system_aaa_server_groups_server_group_servers_server_radius_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)""",
        })

    self.__config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config(self):
    self.__config = YANGDynClass(base=yc_config_openconfig_access_points__access_points_access_point_system_aaa_server_groups_server_group_servers_server_radius_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /access_points/access_point/system/aaa/server_groups/server_group/servers/server/radius/state (container)

    YANG Description: Operational state data for RADIUS servers
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /access_points/access_point/system/aaa/server_groups/server_group/servers/server/radius/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: Operational state data for RADIUS servers
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_access_points__access_points_access_point_system_aaa_server_groups_server_group_servers_server_radius_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_access_points__access_points_access_point_system_aaa_server_groups_server_group_servers_server_radius_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_access_points__access_points_access_point_system_aaa_server_groups_server_group_servers_server_radius_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)

  config = __builtin__.property(_get_config, _set_config)
  state = __builtin__.property(_get_state, _set_state)


  _pyangbind_elements = OrderedDict([('config', config), ('state', state), ])


class yc_server_openconfig_access_points__access_points_access_point_system_aaa_server_groups_server_group_servers_server(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-access-points - based on the path /access-points/access-point/system/aaa/server-groups/server-group/servers/server. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of AAA servers
  """
  __slots__ = ('_path_helper', '_extmethods', '__address','__config','__state','__tacacs','__radius',)

  _yang_name = 'server'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__tacacs = YANGDynClass(base=yc_tacacs_openconfig_access_points__access_points_access_point_system_aaa_server_groups_server_group_servers_server_tacacs, is_container='container', yang_name="tacacs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)
    self.__state = YANGDynClass(base=yc_state_openconfig_access_points__access_points_access_point_system_aaa_server_groups_server_group_servers_server_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)
    self.__radius = YANGDynClass(base=yc_radius_openconfig_access_points__access_points_access_point_system_aaa_server_groups_server_group_servers_server_radius, is_container='container', yang_name="radius", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)
    self.__config = YANGDynClass(base=yc_config_openconfig_access_points__access_points_access_point_system_aaa_server_groups_server_group_servers_server_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)
    self.__address = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='leafref', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'access-points', u'access-point', u'system', u'aaa', u'server-groups', u'server-group', u'servers', u'server']

  def _get_address(self):
    """
    Getter method for address, mapped from YANG variable /access_points/access_point/system/aaa/server_groups/server_group/servers/server/address (leafref)

    YANG Description: Reference to the configured address of the AAA server
    """
    return self.__address
      
  def _set_address(self, v, load=False):
    """
    Setter method for address, mapped from YANG variable /access_points/access_point/system/aaa/server_groups/server_group/servers/server/address (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_address() directly.

    YANG Description: Reference to the configured address of the AAA server
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """address must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='leafref', is_config=True)""",
        })

    self.__address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_address(self):
    self.__address = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='leafref', is_config=True)


  def _get_config(self):
    """
    Getter method for config, mapped from YANG variable /access_points/access_point/system/aaa/server_groups/server_group/servers/server/config (container)

    YANG Description: Configuration data 
    """
    return self.__config
      
  def _set_config(self, v, load=False):
    """
    Setter method for config, mapped from YANG variable /access_points/access_point/system/aaa/server_groups/server_group/servers/server/config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config() directly.

    YANG Description: Configuration data 
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_config_openconfig_access_points__access_points_access_point_system_aaa_server_groups_server_group_servers_server_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_config_openconfig_access_points__access_points_access_point_system_aaa_server_groups_server_group_servers_server_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)""",
        })

    self.__config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config(self):
    self.__config = YANGDynClass(base=yc_config_openconfig_access_points__access_points_access_point_system_aaa_server_groups_server_group_servers_server_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /access_points/access_point/system/aaa/server_groups/server_group/servers/server/state (container)

    YANG Description: Operational state data 
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /access_points/access_point/system/aaa/server_groups/server_group/servers/server/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: Operational state data 
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_access_points__access_points_access_point_system_aaa_server_groups_server_group_servers_server_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_access_points__access_points_access_point_system_aaa_server_groups_server_group_servers_server_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_access_points__access_points_access_point_system_aaa_server_groups_server_group_servers_server_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)


  def _get_tacacs(self):
    """
    Getter method for tacacs, mapped from YANG variable /access_points/access_point/system/aaa/server_groups/server_group/servers/server/tacacs (container)

    YANG Description: Top-level container for TACACS+ server data
    """
    return self.__tacacs
      
  def _set_tacacs(self, v, load=False):
    """
    Setter method for tacacs, mapped from YANG variable /access_points/access_point/system/aaa/server_groups/server_group/servers/server/tacacs (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tacacs is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tacacs() directly.

    YANG Description: Top-level container for TACACS+ server data
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_tacacs_openconfig_access_points__access_points_access_point_system_aaa_server_groups_server_group_servers_server_tacacs, is_container='container', yang_name="tacacs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tacacs must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_tacacs_openconfig_access_points__access_points_access_point_system_aaa_server_groups_server_group_servers_server_tacacs, is_container='container', yang_name="tacacs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)""",
        })

    self.__tacacs = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tacacs(self):
    self.__tacacs = YANGDynClass(base=yc_tacacs_openconfig_access_points__access_points_access_point_system_aaa_server_groups_server_group_servers_server_tacacs, is_container='container', yang_name="tacacs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)


  def _get_radius(self):
    """
    Getter method for radius, mapped from YANG variable /access_points/access_point/system/aaa/server_groups/server_group/servers/server/radius (container)

    YANG Description: Top-level container for RADIUS server data
    """
    return self.__radius
      
  def _set_radius(self, v, load=False):
    """
    Setter method for radius, mapped from YANG variable /access_points/access_point/system/aaa/server_groups/server_group/servers/server/radius (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_radius is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_radius() directly.

    YANG Description: Top-level container for RADIUS server data
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_radius_openconfig_access_points__access_points_access_point_system_aaa_server_groups_server_group_servers_server_radius, is_container='container', yang_name="radius", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """radius must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_radius_openconfig_access_points__access_points_access_point_system_aaa_server_groups_server_group_servers_server_radius, is_container='container', yang_name="radius", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)""",
        })

    self.__radius = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_radius(self):
    self.__radius = YANGDynClass(base=yc_radius_openconfig_access_points__access_points_access_point_system_aaa_server_groups_server_group_servers_server_radius, is_container='container', yang_name="radius", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)

  address = __builtin__.property(_get_address, _set_address)
  config = __builtin__.property(_get_config, _set_config)
  state = __builtin__.property(_get_state, _set_state)
  tacacs = __builtin__.property(_get_tacacs, _set_tacacs)
  radius = __builtin__.property(_get_radius, _set_radius)


  _pyangbind_elements = OrderedDict([('address', address), ('config', config), ('state', state), ('tacacs', tacacs), ('radius', radius), ])


class yc_servers_openconfig_access_points__access_points_access_point_system_aaa_server_groups_server_group_servers(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-access-points - based on the path /access-points/access-point/system/aaa/server-groups/server-group/servers. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Enclosing container the list of servers
  """
  __slots__ = ('_path_helper', '_extmethods', '__server',)

  _yang_name = 'servers'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__server = YANGDynClass(base=YANGListType("address",yc_server_openconfig_access_points__access_points_access_point_system_aaa_server_groups_server_group_servers_server, yang_name="server", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='address', extensions=None), is_container='list', yang_name="server", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'access-points', u'access-point', u'system', u'aaa', u'server-groups', u'server-group', u'servers']

  def _get_server(self):
    """
    Getter method for server, mapped from YANG variable /access_points/access_point/system/aaa/server_groups/server_group/servers/server (list)

    YANG Description: List of AAA servers
    """
    return self.__server
      
  def _set_server(self, v, load=False):
    """
    Setter method for server, mapped from YANG variable /access_points/access_point/system/aaa/server_groups/server_group/servers/server (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_server is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_server() directly.

    YANG Description: List of AAA servers
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("address",yc_server_openconfig_access_points__access_points_access_point_system_aaa_server_groups_server_group_servers_server, yang_name="server", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='address', extensions=None), is_container='list', yang_name="server", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """server must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("address",yc_server_openconfig_access_points__access_points_access_point_system_aaa_server_groups_server_group_servers_server, yang_name="server", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='address', extensions=None), is_container='list', yang_name="server", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='list', is_config=True)""",
        })

    self.__server = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_server(self):
    self.__server = YANGDynClass(base=YANGListType("address",yc_server_openconfig_access_points__access_points_access_point_system_aaa_server_groups_server_group_servers_server, yang_name="server", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='address', extensions=None), is_container='list', yang_name="server", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='list', is_config=True)

  server = __builtin__.property(_get_server, _set_server)


  _pyangbind_elements = OrderedDict([('server', server), ])


class yc_server_group_openconfig_access_points__access_points_access_point_system_aaa_server_groups_server_group(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-access-points - based on the path /access-points/access-point/system/aaa/server-groups/server-group. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of AAA server groups.  All servers in a group
must have the same type as indicated by the server
type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__name','__config','__state','__servers',)

  _yang_name = 'server-group'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__state = YANGDynClass(base=yc_state_openconfig_access_points__access_points_access_point_system_aaa_server_groups_server_group_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)
    self.__config = YANGDynClass(base=yc_config_openconfig_access_points__access_points_access_point_system_aaa_server_groups_server_group_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='leafref', is_config=True)
    self.__servers = YANGDynClass(base=yc_servers_openconfig_access_points__access_points_access_point_system_aaa_server_groups_server_group_servers, is_container='container', yang_name="servers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'access-points', u'access-point', u'system', u'aaa', u'server-groups', u'server-group']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /access_points/access_point/system/aaa/server_groups/server_group/name (leafref)

    YANG Description: Reference to configured name of the server group
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /access_points/access_point/system/aaa/server_groups/server_group/name (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Reference to configured name of the server group
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='leafref', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='leafref', is_config=True)


  def _get_config(self):
    """
    Getter method for config, mapped from YANG variable /access_points/access_point/system/aaa/server_groups/server_group/config (container)

    YANG Description: Configuration data for each server group
    """
    return self.__config
      
  def _set_config(self, v, load=False):
    """
    Setter method for config, mapped from YANG variable /access_points/access_point/system/aaa/server_groups/server_group/config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config() directly.

    YANG Description: Configuration data for each server group
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_config_openconfig_access_points__access_points_access_point_system_aaa_server_groups_server_group_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_config_openconfig_access_points__access_points_access_point_system_aaa_server_groups_server_group_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)""",
        })

    self.__config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config(self):
    self.__config = YANGDynClass(base=yc_config_openconfig_access_points__access_points_access_point_system_aaa_server_groups_server_group_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /access_points/access_point/system/aaa/server_groups/server_group/state (container)

    YANG Description: Operational state data for each server group
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /access_points/access_point/system/aaa/server_groups/server_group/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: Operational state data for each server group
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_access_points__access_points_access_point_system_aaa_server_groups_server_group_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_access_points__access_points_access_point_system_aaa_server_groups_server_group_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_access_points__access_points_access_point_system_aaa_server_groups_server_group_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)


  def _get_servers(self):
    """
    Getter method for servers, mapped from YANG variable /access_points/access_point/system/aaa/server_groups/server_group/servers (container)

    YANG Description: Enclosing container the list of servers
    """
    return self.__servers
      
  def _set_servers(self, v, load=False):
    """
    Setter method for servers, mapped from YANG variable /access_points/access_point/system/aaa/server_groups/server_group/servers (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_servers is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_servers() directly.

    YANG Description: Enclosing container the list of servers
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_servers_openconfig_access_points__access_points_access_point_system_aaa_server_groups_server_group_servers, is_container='container', yang_name="servers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """servers must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_servers_openconfig_access_points__access_points_access_point_system_aaa_server_groups_server_group_servers, is_container='container', yang_name="servers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)""",
        })

    self.__servers = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_servers(self):
    self.__servers = YANGDynClass(base=yc_servers_openconfig_access_points__access_points_access_point_system_aaa_server_groups_server_group_servers, is_container='container', yang_name="servers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)

  name = __builtin__.property(_get_name, _set_name)
  config = __builtin__.property(_get_config, _set_config)
  state = __builtin__.property(_get_state, _set_state)
  servers = __builtin__.property(_get_servers, _set_servers)


  _pyangbind_elements = OrderedDict([('name', name), ('config', config), ('state', state), ('servers', servers), ])


class yc_server_groups_openconfig_access_points__access_points_access_point_system_aaa_server_groups(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-access-points - based on the path /access-points/access-point/system/aaa/server-groups. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Enclosing container for AAA server groups
  """
  __slots__ = ('_path_helper', '_extmethods', '__server_group',)

  _yang_name = 'server-groups'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__server_group = YANGDynClass(base=YANGListType("name",yc_server_group_openconfig_access_points__access_points_access_point_system_aaa_server_groups_server_group, yang_name="server-group", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="server-group", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'access-points', u'access-point', u'system', u'aaa', u'server-groups']

  def _get_server_group(self):
    """
    Getter method for server_group, mapped from YANG variable /access_points/access_point/system/aaa/server_groups/server_group (list)

    YANG Description: List of AAA server groups.  All servers in a group
must have the same type as indicated by the server
type.
    """
    return self.__server_group
      
  def _set_server_group(self, v, load=False):
    """
    Setter method for server_group, mapped from YANG variable /access_points/access_point/system/aaa/server_groups/server_group (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_server_group is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_server_group() directly.

    YANG Description: List of AAA server groups.  All servers in a group
must have the same type as indicated by the server
type.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("name",yc_server_group_openconfig_access_points__access_points_access_point_system_aaa_server_groups_server_group, yang_name="server-group", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="server-group", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """server_group must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("name",yc_server_group_openconfig_access_points__access_points_access_point_system_aaa_server_groups_server_group, yang_name="server-group", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="server-group", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='list', is_config=True)""",
        })

    self.__server_group = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_server_group(self):
    self.__server_group = YANGDynClass(base=YANGListType("name",yc_server_group_openconfig_access_points__access_points_access_point_system_aaa_server_groups_server_group, yang_name="server-group", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="server-group", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='list', is_config=True)

  server_group = __builtin__.property(_get_server_group, _set_server_group)


  _pyangbind_elements = OrderedDict([('server_group', server_group), ])


class yc_aaa_openconfig_access_points__access_points_access_point_system_aaa(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-access-points - based on the path /access-points/access-point/system/aaa. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Top-level container for AAA services
  """
  __slots__ = ('_path_helper', '_extmethods', '__authentication','__authorization','__accounting','__server_groups',)

  _yang_name = 'aaa'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__accounting = YANGDynClass(base=yc_accounting_openconfig_access_points__access_points_access_point_system_aaa_accounting, is_container='container', yang_name="accounting", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)
    self.__authentication = YANGDynClass(base=yc_authentication_openconfig_access_points__access_points_access_point_system_aaa_authentication, is_container='container', yang_name="authentication", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)
    self.__authorization = YANGDynClass(base=yc_authorization_openconfig_access_points__access_points_access_point_system_aaa_authorization, is_container='container', yang_name="authorization", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)
    self.__server_groups = YANGDynClass(base=yc_server_groups_openconfig_access_points__access_points_access_point_system_aaa_server_groups, is_container='container', yang_name="server-groups", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'access-points', u'access-point', u'system', u'aaa']

  def _get_authentication(self):
    """
    Getter method for authentication, mapped from YANG variable /access_points/access_point/system/aaa/authentication (container)

    YANG Description: Top-level container for global authentication data
    """
    return self.__authentication
      
  def _set_authentication(self, v, load=False):
    """
    Setter method for authentication, mapped from YANG variable /access_points/access_point/system/aaa/authentication (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_authentication is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_authentication() directly.

    YANG Description: Top-level container for global authentication data
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_authentication_openconfig_access_points__access_points_access_point_system_aaa_authentication, is_container='container', yang_name="authentication", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """authentication must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_authentication_openconfig_access_points__access_points_access_point_system_aaa_authentication, is_container='container', yang_name="authentication", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)""",
        })

    self.__authentication = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_authentication(self):
    self.__authentication = YANGDynClass(base=yc_authentication_openconfig_access_points__access_points_access_point_system_aaa_authentication, is_container='container', yang_name="authentication", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)


  def _get_authorization(self):
    """
    Getter method for authorization, mapped from YANG variable /access_points/access_point/system/aaa/authorization (container)

    YANG Description: Top-level container for AAA authorization configuration
and operational state data
    """
    return self.__authorization
      
  def _set_authorization(self, v, load=False):
    """
    Setter method for authorization, mapped from YANG variable /access_points/access_point/system/aaa/authorization (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_authorization is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_authorization() directly.

    YANG Description: Top-level container for AAA authorization configuration
and operational state data
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_authorization_openconfig_access_points__access_points_access_point_system_aaa_authorization, is_container='container', yang_name="authorization", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """authorization must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_authorization_openconfig_access_points__access_points_access_point_system_aaa_authorization, is_container='container', yang_name="authorization", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)""",
        })

    self.__authorization = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_authorization(self):
    self.__authorization = YANGDynClass(base=yc_authorization_openconfig_access_points__access_points_access_point_system_aaa_authorization, is_container='container', yang_name="authorization", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)


  def _get_accounting(self):
    """
    Getter method for accounting, mapped from YANG variable /access_points/access_point/system/aaa/accounting (container)

    YANG Description: Top-level container for AAA accounting
    """
    return self.__accounting
      
  def _set_accounting(self, v, load=False):
    """
    Setter method for accounting, mapped from YANG variable /access_points/access_point/system/aaa/accounting (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_accounting is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_accounting() directly.

    YANG Description: Top-level container for AAA accounting
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_accounting_openconfig_access_points__access_points_access_point_system_aaa_accounting, is_container='container', yang_name="accounting", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """accounting must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_accounting_openconfig_access_points__access_points_access_point_system_aaa_accounting, is_container='container', yang_name="accounting", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)""",
        })

    self.__accounting = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_accounting(self):
    self.__accounting = YANGDynClass(base=yc_accounting_openconfig_access_points__access_points_access_point_system_aaa_accounting, is_container='container', yang_name="accounting", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)


  def _get_server_groups(self):
    """
    Getter method for server_groups, mapped from YANG variable /access_points/access_point/system/aaa/server_groups (container)

    YANG Description: Enclosing container for AAA server groups
    """
    return self.__server_groups
      
  def _set_server_groups(self, v, load=False):
    """
    Setter method for server_groups, mapped from YANG variable /access_points/access_point/system/aaa/server_groups (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_server_groups is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_server_groups() directly.

    YANG Description: Enclosing container for AAA server groups
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_server_groups_openconfig_access_points__access_points_access_point_system_aaa_server_groups, is_container='container', yang_name="server-groups", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """server_groups must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_server_groups_openconfig_access_points__access_points_access_point_system_aaa_server_groups, is_container='container', yang_name="server-groups", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)""",
        })

    self.__server_groups = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_server_groups(self):
    self.__server_groups = YANGDynClass(base=yc_server_groups_openconfig_access_points__access_points_access_point_system_aaa_server_groups, is_container='container', yang_name="server-groups", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)

  authentication = __builtin__.property(_get_authentication, _set_authentication)
  authorization = __builtin__.property(_get_authorization, _set_authorization)
  accounting = __builtin__.property(_get_accounting, _set_accounting)
  server_groups = __builtin__.property(_get_server_groups, _set_server_groups)


  _pyangbind_elements = OrderedDict([('authentication', authentication), ('authorization', authorization), ('accounting', accounting), ('server_groups', server_groups), ])


class yc_state_openconfig_access_points__access_points_access_point_system_memory_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-access-points - based on the path /access-points/access-point/system/memory/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Operational state data for system memory
  """
  __slots__ = ('_path_helper', '_extmethods', '__physical','__reserved',)

  _yang_name = 'state'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__reserved = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="reserved", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint64', is_config=False)
    self.__physical = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="physical", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint64', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'access-points', u'access-point', u'system', u'memory', u'state']

  def _get_physical(self):
    """
    Getter method for physical, mapped from YANG variable /access_points/access_point/system/memory/state/physical (uint64)

    YANG Description: Reports the total physical memory available on the
system.
    """
    return self.__physical
      
  def _set_physical(self, v, load=False):
    """
    Setter method for physical, mapped from YANG variable /access_points/access_point/system/memory/state/physical (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_physical is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_physical() directly.

    YANG Description: Reports the total physical memory available on the
system.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="physical", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """physical must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="physical", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint64', is_config=False)""",
        })

    self.__physical = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_physical(self):
    self.__physical = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="physical", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint64', is_config=False)


  def _get_reserved(self):
    """
    Getter method for reserved, mapped from YANG variable /access_points/access_point/system/memory/state/reserved (uint64)

    YANG Description: Memory reserved for system use
    """
    return self.__reserved
      
  def _set_reserved(self, v, load=False):
    """
    Setter method for reserved, mapped from YANG variable /access_points/access_point/system/memory/state/reserved (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_reserved is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_reserved() directly.

    YANG Description: Memory reserved for system use
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="reserved", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """reserved must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="reserved", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint64', is_config=False)""",
        })

    self.__reserved = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_reserved(self):
    self.__reserved = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="reserved", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint64', is_config=False)

  physical = __builtin__.property(_get_physical)
  reserved = __builtin__.property(_get_reserved)


  _pyangbind_elements = OrderedDict([('physical', physical), ('reserved', reserved), ])


class yc_memory_openconfig_access_points__access_points_access_point_system_memory(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-access-points - based on the path /access-points/access-point/system/memory. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Top-level container for system memory data
  """
  __slots__ = ('_path_helper', '_extmethods', '__state',)

  _yang_name = 'memory'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__state = YANGDynClass(base=yc_state_openconfig_access_points__access_points_access_point_system_memory_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'access-points', u'access-point', u'system', u'memory']

  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /access_points/access_point/system/memory/state (container)

    YANG Description: Operational state data for system memory
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /access_points/access_point/system/memory/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: Operational state data for system memory
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_access_points__access_points_access_point_system_memory_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_access_points__access_points_access_point_system_memory_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_access_points__access_points_access_point_system_memory_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)

  state = __builtin__.property(_get_state, _set_state)


  _pyangbind_elements = OrderedDict([('state', state), ])


class yc_total_openconfig_access_points__access_points_access_point_system_cpus_cpu_state_total(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-access-points - based on the path /access-points/access-point/system/cpus/cpu/state/total. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Total CPU utilization.
  """
  __slots__ = ('_path_helper', '_extmethods', '__instant','__avg','__min_','__max_','__interval','__min_time','__max_time',)

  _yang_name = 'total'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__instant = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={u'range': [u'0..100']}), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:percentage', is_config=False)
    self.__max_ = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={u'range': [u'0..100']}), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:percentage', is_config=False)
    self.__interval = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:stat-interval', is_config=False)
    self.__max_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:timeticks64', is_config=False)
    self.__min_ = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={u'range': [u'0..100']}), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:percentage', is_config=False)
    self.__min_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:timeticks64', is_config=False)
    self.__avg = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={u'range': [u'0..100']}), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:percentage', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'access-points', u'access-point', u'system', u'cpus', u'cpu', u'state', u'total']

  def _get_instant(self):
    """
    Getter method for instant, mapped from YANG variable /access_points/access_point/system/cpus/cpu/state/total/instant (oc-types:percentage)

    YANG Description: The instantaneous percentage value.
    """
    return self.__instant
      
  def _set_instant(self, v, load=False):
    """
    Setter method for instant, mapped from YANG variable /access_points/access_point/system/cpus/cpu/state/total/instant (oc-types:percentage)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_instant is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_instant() directly.

    YANG Description: The instantaneous percentage value.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={u'range': [u'0..100']}), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:percentage', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """instant must be of a type compatible with oc-types:percentage""",
          'defined-type': "oc-types:percentage",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={u'range': [u'0..100']}), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:percentage', is_config=False)""",
        })

    self.__instant = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_instant(self):
    self.__instant = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={u'range': [u'0..100']}), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:percentage', is_config=False)


  def _get_avg(self):
    """
    Getter method for avg, mapped from YANG variable /access_points/access_point/system/cpus/cpu/state/total/avg (oc-types:percentage)

    YANG Description: The arithmetic mean value of the percentage measure of the
statistic over the time interval.
    """
    return self.__avg
      
  def _set_avg(self, v, load=False):
    """
    Setter method for avg, mapped from YANG variable /access_points/access_point/system/cpus/cpu/state/total/avg (oc-types:percentage)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_avg is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_avg() directly.

    YANG Description: The arithmetic mean value of the percentage measure of the
statistic over the time interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={u'range': [u'0..100']}), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:percentage', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """avg must be of a type compatible with oc-types:percentage""",
          'defined-type': "oc-types:percentage",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={u'range': [u'0..100']}), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:percentage', is_config=False)""",
        })

    self.__avg = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_avg(self):
    self.__avg = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={u'range': [u'0..100']}), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:percentage', is_config=False)


  def _get_min_(self):
    """
    Getter method for min_, mapped from YANG variable /access_points/access_point/system/cpus/cpu/state/total/min (oc-types:percentage)

    YANG Description: The minimum value of the percentage measure of the
statistic over the time interval.
    """
    return self.__min_
      
  def _set_min_(self, v, load=False):
    """
    Setter method for min_, mapped from YANG variable /access_points/access_point/system/cpus/cpu/state/total/min (oc-types:percentage)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_min_ is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_min_() directly.

    YANG Description: The minimum value of the percentage measure of the
statistic over the time interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={u'range': [u'0..100']}), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:percentage', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """min_ must be of a type compatible with oc-types:percentage""",
          'defined-type': "oc-types:percentage",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={u'range': [u'0..100']}), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:percentage', is_config=False)""",
        })

    self.__min_ = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_min_(self):
    self.__min_ = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={u'range': [u'0..100']}), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:percentage', is_config=False)


  def _get_max_(self):
    """
    Getter method for max_, mapped from YANG variable /access_points/access_point/system/cpus/cpu/state/total/max (oc-types:percentage)

    YANG Description: The maximum value of the percentage measure of the
statistic over the time interval.
    """
    return self.__max_
      
  def _set_max_(self, v, load=False):
    """
    Setter method for max_, mapped from YANG variable /access_points/access_point/system/cpus/cpu/state/total/max (oc-types:percentage)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_ is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_() directly.

    YANG Description: The maximum value of the percentage measure of the
statistic over the time interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={u'range': [u'0..100']}), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:percentage', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_ must be of a type compatible with oc-types:percentage""",
          'defined-type': "oc-types:percentage",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={u'range': [u'0..100']}), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:percentage', is_config=False)""",
        })

    self.__max_ = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_(self):
    self.__max_ = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={u'range': [u'0..100']}), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:percentage', is_config=False)


  def _get_interval(self):
    """
    Getter method for interval, mapped from YANG variable /access_points/access_point/system/cpus/cpu/state/total/interval (oc-types:stat-interval)

    YANG Description: If supported by the system, this reports the time interval
over which the min/max/average statistics are computed by
the system.
    """
    return self.__interval
      
  def _set_interval(self, v, load=False):
    """
    Setter method for interval, mapped from YANG variable /access_points/access_point/system/cpus/cpu/state/total/interval (oc-types:stat-interval)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interval() directly.

    YANG Description: If supported by the system, this reports the time interval
over which the min/max/average statistics are computed by
the system.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:stat-interval', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interval must be of a type compatible with oc-types:stat-interval""",
          'defined-type': "oc-types:stat-interval",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:stat-interval', is_config=False)""",
        })

    self.__interval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interval(self):
    self.__interval = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:stat-interval', is_config=False)


  def _get_min_time(self):
    """
    Getter method for min_time, mapped from YANG variable /access_points/access_point/system/cpus/cpu/state/total/min_time (oc-types:timeticks64)

    YANG Description: The absolute time at which the minimum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    return self.__min_time
      
  def _set_min_time(self, v, load=False):
    """
    Setter method for min_time, mapped from YANG variable /access_points/access_point/system/cpus/cpu/state/total/min_time (oc-types:timeticks64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_min_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_min_time() directly.

    YANG Description: The absolute time at which the minimum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:timeticks64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """min_time must be of a type compatible with oc-types:timeticks64""",
          'defined-type': "oc-types:timeticks64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:timeticks64', is_config=False)""",
        })

    self.__min_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_min_time(self):
    self.__min_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:timeticks64', is_config=False)


  def _get_max_time(self):
    """
    Getter method for max_time, mapped from YANG variable /access_points/access_point/system/cpus/cpu/state/total/max_time (oc-types:timeticks64)

    YANG Description: The absolute time at which the maximum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    return self.__max_time
      
  def _set_max_time(self, v, load=False):
    """
    Setter method for max_time, mapped from YANG variable /access_points/access_point/system/cpus/cpu/state/total/max_time (oc-types:timeticks64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_time() directly.

    YANG Description: The absolute time at which the maximum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:timeticks64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_time must be of a type compatible with oc-types:timeticks64""",
          'defined-type': "oc-types:timeticks64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:timeticks64', is_config=False)""",
        })

    self.__max_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_time(self):
    self.__max_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:timeticks64', is_config=False)

  instant = __builtin__.property(_get_instant)
  avg = __builtin__.property(_get_avg)
  min_ = __builtin__.property(_get_min_)
  max_ = __builtin__.property(_get_max_)
  interval = __builtin__.property(_get_interval)
  min_time = __builtin__.property(_get_min_time)
  max_time = __builtin__.property(_get_max_time)


  _pyangbind_elements = OrderedDict([('instant', instant), ('avg', avg), ('min_', min_), ('max_', max_), ('interval', interval), ('min_time', min_time), ('max_time', max_time), ])


class yc_user_openconfig_access_points__access_points_access_point_system_cpus_cpu_state_user(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-access-points - based on the path /access-points/access-point/system/cpus/cpu/state/user. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Percentage of CPU time spent running in user space.
  """
  __slots__ = ('_path_helper', '_extmethods', '__instant','__avg','__min_','__max_','__interval','__min_time','__max_time',)

  _yang_name = 'user'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__instant = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={u'range': [u'0..100']}), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:percentage', is_config=False)
    self.__max_ = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={u'range': [u'0..100']}), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:percentage', is_config=False)
    self.__interval = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:stat-interval', is_config=False)
    self.__max_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:timeticks64', is_config=False)
    self.__min_ = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={u'range': [u'0..100']}), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:percentage', is_config=False)
    self.__min_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:timeticks64', is_config=False)
    self.__avg = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={u'range': [u'0..100']}), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:percentage', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'access-points', u'access-point', u'system', u'cpus', u'cpu', u'state', u'user']

  def _get_instant(self):
    """
    Getter method for instant, mapped from YANG variable /access_points/access_point/system/cpus/cpu/state/user/instant (oc-types:percentage)

    YANG Description: The instantaneous percentage value.
    """
    return self.__instant
      
  def _set_instant(self, v, load=False):
    """
    Setter method for instant, mapped from YANG variable /access_points/access_point/system/cpus/cpu/state/user/instant (oc-types:percentage)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_instant is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_instant() directly.

    YANG Description: The instantaneous percentage value.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={u'range': [u'0..100']}), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:percentage', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """instant must be of a type compatible with oc-types:percentage""",
          'defined-type': "oc-types:percentage",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={u'range': [u'0..100']}), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:percentage', is_config=False)""",
        })

    self.__instant = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_instant(self):
    self.__instant = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={u'range': [u'0..100']}), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:percentage', is_config=False)


  def _get_avg(self):
    """
    Getter method for avg, mapped from YANG variable /access_points/access_point/system/cpus/cpu/state/user/avg (oc-types:percentage)

    YANG Description: The arithmetic mean value of the percentage measure of the
statistic over the time interval.
    """
    return self.__avg
      
  def _set_avg(self, v, load=False):
    """
    Setter method for avg, mapped from YANG variable /access_points/access_point/system/cpus/cpu/state/user/avg (oc-types:percentage)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_avg is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_avg() directly.

    YANG Description: The arithmetic mean value of the percentage measure of the
statistic over the time interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={u'range': [u'0..100']}), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:percentage', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """avg must be of a type compatible with oc-types:percentage""",
          'defined-type': "oc-types:percentage",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={u'range': [u'0..100']}), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:percentage', is_config=False)""",
        })

    self.__avg = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_avg(self):
    self.__avg = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={u'range': [u'0..100']}), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:percentage', is_config=False)


  def _get_min_(self):
    """
    Getter method for min_, mapped from YANG variable /access_points/access_point/system/cpus/cpu/state/user/min (oc-types:percentage)

    YANG Description: The minimum value of the percentage measure of the
statistic over the time interval.
    """
    return self.__min_
      
  def _set_min_(self, v, load=False):
    """
    Setter method for min_, mapped from YANG variable /access_points/access_point/system/cpus/cpu/state/user/min (oc-types:percentage)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_min_ is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_min_() directly.

    YANG Description: The minimum value of the percentage measure of the
statistic over the time interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={u'range': [u'0..100']}), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:percentage', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """min_ must be of a type compatible with oc-types:percentage""",
          'defined-type': "oc-types:percentage",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={u'range': [u'0..100']}), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:percentage', is_config=False)""",
        })

    self.__min_ = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_min_(self):
    self.__min_ = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={u'range': [u'0..100']}), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:percentage', is_config=False)


  def _get_max_(self):
    """
    Getter method for max_, mapped from YANG variable /access_points/access_point/system/cpus/cpu/state/user/max (oc-types:percentage)

    YANG Description: The maximum value of the percentage measure of the
statistic over the time interval.
    """
    return self.__max_
      
  def _set_max_(self, v, load=False):
    """
    Setter method for max_, mapped from YANG variable /access_points/access_point/system/cpus/cpu/state/user/max (oc-types:percentage)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_ is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_() directly.

    YANG Description: The maximum value of the percentage measure of the
statistic over the time interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={u'range': [u'0..100']}), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:percentage', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_ must be of a type compatible with oc-types:percentage""",
          'defined-type': "oc-types:percentage",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={u'range': [u'0..100']}), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:percentage', is_config=False)""",
        })

    self.__max_ = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_(self):
    self.__max_ = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={u'range': [u'0..100']}), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:percentage', is_config=False)


  def _get_interval(self):
    """
    Getter method for interval, mapped from YANG variable /access_points/access_point/system/cpus/cpu/state/user/interval (oc-types:stat-interval)

    YANG Description: If supported by the system, this reports the time interval
over which the min/max/average statistics are computed by
the system.
    """
    return self.__interval
      
  def _set_interval(self, v, load=False):
    """
    Setter method for interval, mapped from YANG variable /access_points/access_point/system/cpus/cpu/state/user/interval (oc-types:stat-interval)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interval() directly.

    YANG Description: If supported by the system, this reports the time interval
over which the min/max/average statistics are computed by
the system.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:stat-interval', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interval must be of a type compatible with oc-types:stat-interval""",
          'defined-type': "oc-types:stat-interval",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:stat-interval', is_config=False)""",
        })

    self.__interval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interval(self):
    self.__interval = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:stat-interval', is_config=False)


  def _get_min_time(self):
    """
    Getter method for min_time, mapped from YANG variable /access_points/access_point/system/cpus/cpu/state/user/min_time (oc-types:timeticks64)

    YANG Description: The absolute time at which the minimum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    return self.__min_time
      
  def _set_min_time(self, v, load=False):
    """
    Setter method for min_time, mapped from YANG variable /access_points/access_point/system/cpus/cpu/state/user/min_time (oc-types:timeticks64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_min_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_min_time() directly.

    YANG Description: The absolute time at which the minimum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:timeticks64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """min_time must be of a type compatible with oc-types:timeticks64""",
          'defined-type': "oc-types:timeticks64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:timeticks64', is_config=False)""",
        })

    self.__min_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_min_time(self):
    self.__min_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:timeticks64', is_config=False)


  def _get_max_time(self):
    """
    Getter method for max_time, mapped from YANG variable /access_points/access_point/system/cpus/cpu/state/user/max_time (oc-types:timeticks64)

    YANG Description: The absolute time at which the maximum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    return self.__max_time
      
  def _set_max_time(self, v, load=False):
    """
    Setter method for max_time, mapped from YANG variable /access_points/access_point/system/cpus/cpu/state/user/max_time (oc-types:timeticks64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_time() directly.

    YANG Description: The absolute time at which the maximum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:timeticks64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_time must be of a type compatible with oc-types:timeticks64""",
          'defined-type': "oc-types:timeticks64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:timeticks64', is_config=False)""",
        })

    self.__max_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_time(self):
    self.__max_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:timeticks64', is_config=False)

  instant = __builtin__.property(_get_instant)
  avg = __builtin__.property(_get_avg)
  min_ = __builtin__.property(_get_min_)
  max_ = __builtin__.property(_get_max_)
  interval = __builtin__.property(_get_interval)
  min_time = __builtin__.property(_get_min_time)
  max_time = __builtin__.property(_get_max_time)


  _pyangbind_elements = OrderedDict([('instant', instant), ('avg', avg), ('min_', min_), ('max_', max_), ('interval', interval), ('min_time', min_time), ('max_time', max_time), ])


class yc_kernel_openconfig_access_points__access_points_access_point_system_cpus_cpu_state_kernel(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-access-points - based on the path /access-points/access-point/system/cpus/cpu/state/kernel. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Percentage of CPU time spent running in kernel space.
  """
  __slots__ = ('_path_helper', '_extmethods', '__instant','__avg','__min_','__max_','__interval','__min_time','__max_time',)

  _yang_name = 'kernel'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__instant = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={u'range': [u'0..100']}), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:percentage', is_config=False)
    self.__max_ = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={u'range': [u'0..100']}), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:percentage', is_config=False)
    self.__interval = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:stat-interval', is_config=False)
    self.__max_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:timeticks64', is_config=False)
    self.__min_ = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={u'range': [u'0..100']}), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:percentage', is_config=False)
    self.__min_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:timeticks64', is_config=False)
    self.__avg = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={u'range': [u'0..100']}), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:percentage', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'access-points', u'access-point', u'system', u'cpus', u'cpu', u'state', u'kernel']

  def _get_instant(self):
    """
    Getter method for instant, mapped from YANG variable /access_points/access_point/system/cpus/cpu/state/kernel/instant (oc-types:percentage)

    YANG Description: The instantaneous percentage value.
    """
    return self.__instant
      
  def _set_instant(self, v, load=False):
    """
    Setter method for instant, mapped from YANG variable /access_points/access_point/system/cpus/cpu/state/kernel/instant (oc-types:percentage)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_instant is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_instant() directly.

    YANG Description: The instantaneous percentage value.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={u'range': [u'0..100']}), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:percentage', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """instant must be of a type compatible with oc-types:percentage""",
          'defined-type': "oc-types:percentage",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={u'range': [u'0..100']}), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:percentage', is_config=False)""",
        })

    self.__instant = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_instant(self):
    self.__instant = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={u'range': [u'0..100']}), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:percentage', is_config=False)


  def _get_avg(self):
    """
    Getter method for avg, mapped from YANG variable /access_points/access_point/system/cpus/cpu/state/kernel/avg (oc-types:percentage)

    YANG Description: The arithmetic mean value of the percentage measure of the
statistic over the time interval.
    """
    return self.__avg
      
  def _set_avg(self, v, load=False):
    """
    Setter method for avg, mapped from YANG variable /access_points/access_point/system/cpus/cpu/state/kernel/avg (oc-types:percentage)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_avg is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_avg() directly.

    YANG Description: The arithmetic mean value of the percentage measure of the
statistic over the time interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={u'range': [u'0..100']}), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:percentage', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """avg must be of a type compatible with oc-types:percentage""",
          'defined-type': "oc-types:percentage",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={u'range': [u'0..100']}), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:percentage', is_config=False)""",
        })

    self.__avg = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_avg(self):
    self.__avg = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={u'range': [u'0..100']}), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:percentage', is_config=False)


  def _get_min_(self):
    """
    Getter method for min_, mapped from YANG variable /access_points/access_point/system/cpus/cpu/state/kernel/min (oc-types:percentage)

    YANG Description: The minimum value of the percentage measure of the
statistic over the time interval.
    """
    return self.__min_
      
  def _set_min_(self, v, load=False):
    """
    Setter method for min_, mapped from YANG variable /access_points/access_point/system/cpus/cpu/state/kernel/min (oc-types:percentage)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_min_ is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_min_() directly.

    YANG Description: The minimum value of the percentage measure of the
statistic over the time interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={u'range': [u'0..100']}), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:percentage', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """min_ must be of a type compatible with oc-types:percentage""",
          'defined-type': "oc-types:percentage",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={u'range': [u'0..100']}), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:percentage', is_config=False)""",
        })

    self.__min_ = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_min_(self):
    self.__min_ = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={u'range': [u'0..100']}), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:percentage', is_config=False)


  def _get_max_(self):
    """
    Getter method for max_, mapped from YANG variable /access_points/access_point/system/cpus/cpu/state/kernel/max (oc-types:percentage)

    YANG Description: The maximum value of the percentage measure of the
statistic over the time interval.
    """
    return self.__max_
      
  def _set_max_(self, v, load=False):
    """
    Setter method for max_, mapped from YANG variable /access_points/access_point/system/cpus/cpu/state/kernel/max (oc-types:percentage)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_ is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_() directly.

    YANG Description: The maximum value of the percentage measure of the
statistic over the time interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={u'range': [u'0..100']}), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:percentage', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_ must be of a type compatible with oc-types:percentage""",
          'defined-type': "oc-types:percentage",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={u'range': [u'0..100']}), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:percentage', is_config=False)""",
        })

    self.__max_ = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_(self):
    self.__max_ = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={u'range': [u'0..100']}), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:percentage', is_config=False)


  def _get_interval(self):
    """
    Getter method for interval, mapped from YANG variable /access_points/access_point/system/cpus/cpu/state/kernel/interval (oc-types:stat-interval)

    YANG Description: If supported by the system, this reports the time interval
over which the min/max/average statistics are computed by
the system.
    """
    return self.__interval
      
  def _set_interval(self, v, load=False):
    """
    Setter method for interval, mapped from YANG variable /access_points/access_point/system/cpus/cpu/state/kernel/interval (oc-types:stat-interval)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interval() directly.

    YANG Description: If supported by the system, this reports the time interval
over which the min/max/average statistics are computed by
the system.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:stat-interval', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interval must be of a type compatible with oc-types:stat-interval""",
          'defined-type': "oc-types:stat-interval",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:stat-interval', is_config=False)""",
        })

    self.__interval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interval(self):
    self.__interval = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:stat-interval', is_config=False)


  def _get_min_time(self):
    """
    Getter method for min_time, mapped from YANG variable /access_points/access_point/system/cpus/cpu/state/kernel/min_time (oc-types:timeticks64)

    YANG Description: The absolute time at which the minimum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    return self.__min_time
      
  def _set_min_time(self, v, load=False):
    """
    Setter method for min_time, mapped from YANG variable /access_points/access_point/system/cpus/cpu/state/kernel/min_time (oc-types:timeticks64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_min_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_min_time() directly.

    YANG Description: The absolute time at which the minimum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:timeticks64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """min_time must be of a type compatible with oc-types:timeticks64""",
          'defined-type': "oc-types:timeticks64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:timeticks64', is_config=False)""",
        })

    self.__min_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_min_time(self):
    self.__min_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:timeticks64', is_config=False)


  def _get_max_time(self):
    """
    Getter method for max_time, mapped from YANG variable /access_points/access_point/system/cpus/cpu/state/kernel/max_time (oc-types:timeticks64)

    YANG Description: The absolute time at which the maximum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    return self.__max_time
      
  def _set_max_time(self, v, load=False):
    """
    Setter method for max_time, mapped from YANG variable /access_points/access_point/system/cpus/cpu/state/kernel/max_time (oc-types:timeticks64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_time() directly.

    YANG Description: The absolute time at which the maximum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:timeticks64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_time must be of a type compatible with oc-types:timeticks64""",
          'defined-type': "oc-types:timeticks64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:timeticks64', is_config=False)""",
        })

    self.__max_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_time(self):
    self.__max_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:timeticks64', is_config=False)

  instant = __builtin__.property(_get_instant)
  avg = __builtin__.property(_get_avg)
  min_ = __builtin__.property(_get_min_)
  max_ = __builtin__.property(_get_max_)
  interval = __builtin__.property(_get_interval)
  min_time = __builtin__.property(_get_min_time)
  max_time = __builtin__.property(_get_max_time)


  _pyangbind_elements = OrderedDict([('instant', instant), ('avg', avg), ('min_', min_), ('max_', max_), ('interval', interval), ('min_time', min_time), ('max_time', max_time), ])


class yc_nice_openconfig_access_points__access_points_access_point_system_cpus_cpu_state_nice(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-access-points - based on the path /access-points/access-point/system/cpus/cpu/state/nice. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Percentage of CPU time spent running low-priority (niced)
user processes.
  """
  __slots__ = ('_path_helper', '_extmethods', '__instant','__avg','__min_','__max_','__interval','__min_time','__max_time',)

  _yang_name = 'nice'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__instant = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={u'range': [u'0..100']}), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:percentage', is_config=False)
    self.__max_ = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={u'range': [u'0..100']}), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:percentage', is_config=False)
    self.__interval = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:stat-interval', is_config=False)
    self.__max_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:timeticks64', is_config=False)
    self.__min_ = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={u'range': [u'0..100']}), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:percentage', is_config=False)
    self.__min_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:timeticks64', is_config=False)
    self.__avg = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={u'range': [u'0..100']}), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:percentage', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'access-points', u'access-point', u'system', u'cpus', u'cpu', u'state', u'nice']

  def _get_instant(self):
    """
    Getter method for instant, mapped from YANG variable /access_points/access_point/system/cpus/cpu/state/nice/instant (oc-types:percentage)

    YANG Description: The instantaneous percentage value.
    """
    return self.__instant
      
  def _set_instant(self, v, load=False):
    """
    Setter method for instant, mapped from YANG variable /access_points/access_point/system/cpus/cpu/state/nice/instant (oc-types:percentage)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_instant is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_instant() directly.

    YANG Description: The instantaneous percentage value.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={u'range': [u'0..100']}), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:percentage', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """instant must be of a type compatible with oc-types:percentage""",
          'defined-type': "oc-types:percentage",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={u'range': [u'0..100']}), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:percentage', is_config=False)""",
        })

    self.__instant = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_instant(self):
    self.__instant = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={u'range': [u'0..100']}), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:percentage', is_config=False)


  def _get_avg(self):
    """
    Getter method for avg, mapped from YANG variable /access_points/access_point/system/cpus/cpu/state/nice/avg (oc-types:percentage)

    YANG Description: The arithmetic mean value of the percentage measure of the
statistic over the time interval.
    """
    return self.__avg
      
  def _set_avg(self, v, load=False):
    """
    Setter method for avg, mapped from YANG variable /access_points/access_point/system/cpus/cpu/state/nice/avg (oc-types:percentage)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_avg is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_avg() directly.

    YANG Description: The arithmetic mean value of the percentage measure of the
statistic over the time interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={u'range': [u'0..100']}), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:percentage', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """avg must be of a type compatible with oc-types:percentage""",
          'defined-type': "oc-types:percentage",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={u'range': [u'0..100']}), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:percentage', is_config=False)""",
        })

    self.__avg = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_avg(self):
    self.__avg = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={u'range': [u'0..100']}), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:percentage', is_config=False)


  def _get_min_(self):
    """
    Getter method for min_, mapped from YANG variable /access_points/access_point/system/cpus/cpu/state/nice/min (oc-types:percentage)

    YANG Description: The minimum value of the percentage measure of the
statistic over the time interval.
    """
    return self.__min_
      
  def _set_min_(self, v, load=False):
    """
    Setter method for min_, mapped from YANG variable /access_points/access_point/system/cpus/cpu/state/nice/min (oc-types:percentage)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_min_ is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_min_() directly.

    YANG Description: The minimum value of the percentage measure of the
statistic over the time interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={u'range': [u'0..100']}), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:percentage', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """min_ must be of a type compatible with oc-types:percentage""",
          'defined-type': "oc-types:percentage",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={u'range': [u'0..100']}), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:percentage', is_config=False)""",
        })

    self.__min_ = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_min_(self):
    self.__min_ = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={u'range': [u'0..100']}), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:percentage', is_config=False)


  def _get_max_(self):
    """
    Getter method for max_, mapped from YANG variable /access_points/access_point/system/cpus/cpu/state/nice/max (oc-types:percentage)

    YANG Description: The maximum value of the percentage measure of the
statistic over the time interval.
    """
    return self.__max_
      
  def _set_max_(self, v, load=False):
    """
    Setter method for max_, mapped from YANG variable /access_points/access_point/system/cpus/cpu/state/nice/max (oc-types:percentage)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_ is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_() directly.

    YANG Description: The maximum value of the percentage measure of the
statistic over the time interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={u'range': [u'0..100']}), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:percentage', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_ must be of a type compatible with oc-types:percentage""",
          'defined-type': "oc-types:percentage",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={u'range': [u'0..100']}), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:percentage', is_config=False)""",
        })

    self.__max_ = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_(self):
    self.__max_ = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={u'range': [u'0..100']}), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:percentage', is_config=False)


  def _get_interval(self):
    """
    Getter method for interval, mapped from YANG variable /access_points/access_point/system/cpus/cpu/state/nice/interval (oc-types:stat-interval)

    YANG Description: If supported by the system, this reports the time interval
over which the min/max/average statistics are computed by
the system.
    """
    return self.__interval
      
  def _set_interval(self, v, load=False):
    """
    Setter method for interval, mapped from YANG variable /access_points/access_point/system/cpus/cpu/state/nice/interval (oc-types:stat-interval)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interval() directly.

    YANG Description: If supported by the system, this reports the time interval
over which the min/max/average statistics are computed by
the system.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:stat-interval', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interval must be of a type compatible with oc-types:stat-interval""",
          'defined-type': "oc-types:stat-interval",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:stat-interval', is_config=False)""",
        })

    self.__interval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interval(self):
    self.__interval = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:stat-interval', is_config=False)


  def _get_min_time(self):
    """
    Getter method for min_time, mapped from YANG variable /access_points/access_point/system/cpus/cpu/state/nice/min_time (oc-types:timeticks64)

    YANG Description: The absolute time at which the minimum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    return self.__min_time
      
  def _set_min_time(self, v, load=False):
    """
    Setter method for min_time, mapped from YANG variable /access_points/access_point/system/cpus/cpu/state/nice/min_time (oc-types:timeticks64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_min_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_min_time() directly.

    YANG Description: The absolute time at which the minimum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:timeticks64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """min_time must be of a type compatible with oc-types:timeticks64""",
          'defined-type': "oc-types:timeticks64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:timeticks64', is_config=False)""",
        })

    self.__min_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_min_time(self):
    self.__min_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:timeticks64', is_config=False)


  def _get_max_time(self):
    """
    Getter method for max_time, mapped from YANG variable /access_points/access_point/system/cpus/cpu/state/nice/max_time (oc-types:timeticks64)

    YANG Description: The absolute time at which the maximum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    return self.__max_time
      
  def _set_max_time(self, v, load=False):
    """
    Setter method for max_time, mapped from YANG variable /access_points/access_point/system/cpus/cpu/state/nice/max_time (oc-types:timeticks64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_time() directly.

    YANG Description: The absolute time at which the maximum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:timeticks64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_time must be of a type compatible with oc-types:timeticks64""",
          'defined-type': "oc-types:timeticks64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:timeticks64', is_config=False)""",
        })

    self.__max_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_time(self):
    self.__max_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:timeticks64', is_config=False)

  instant = __builtin__.property(_get_instant)
  avg = __builtin__.property(_get_avg)
  min_ = __builtin__.property(_get_min_)
  max_ = __builtin__.property(_get_max_)
  interval = __builtin__.property(_get_interval)
  min_time = __builtin__.property(_get_min_time)
  max_time = __builtin__.property(_get_max_time)


  _pyangbind_elements = OrderedDict([('instant', instant), ('avg', avg), ('min_', min_), ('max_', max_), ('interval', interval), ('min_time', min_time), ('max_time', max_time), ])


class yc_idle_openconfig_access_points__access_points_access_point_system_cpus_cpu_state_idle(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-access-points - based on the path /access-points/access-point/system/cpus/cpu/state/idle. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Percentage of CPU time spent idle.
  """
  __slots__ = ('_path_helper', '_extmethods', '__instant','__avg','__min_','__max_','__interval','__min_time','__max_time',)

  _yang_name = 'idle'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__instant = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={u'range': [u'0..100']}), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:percentage', is_config=False)
    self.__max_ = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={u'range': [u'0..100']}), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:percentage', is_config=False)
    self.__interval = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:stat-interval', is_config=False)
    self.__max_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:timeticks64', is_config=False)
    self.__min_ = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={u'range': [u'0..100']}), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:percentage', is_config=False)
    self.__min_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:timeticks64', is_config=False)
    self.__avg = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={u'range': [u'0..100']}), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:percentage', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'access-points', u'access-point', u'system', u'cpus', u'cpu', u'state', u'idle']

  def _get_instant(self):
    """
    Getter method for instant, mapped from YANG variable /access_points/access_point/system/cpus/cpu/state/idle/instant (oc-types:percentage)

    YANG Description: The instantaneous percentage value.
    """
    return self.__instant
      
  def _set_instant(self, v, load=False):
    """
    Setter method for instant, mapped from YANG variable /access_points/access_point/system/cpus/cpu/state/idle/instant (oc-types:percentage)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_instant is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_instant() directly.

    YANG Description: The instantaneous percentage value.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={u'range': [u'0..100']}), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:percentage', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """instant must be of a type compatible with oc-types:percentage""",
          'defined-type': "oc-types:percentage",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={u'range': [u'0..100']}), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:percentage', is_config=False)""",
        })

    self.__instant = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_instant(self):
    self.__instant = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={u'range': [u'0..100']}), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:percentage', is_config=False)


  def _get_avg(self):
    """
    Getter method for avg, mapped from YANG variable /access_points/access_point/system/cpus/cpu/state/idle/avg (oc-types:percentage)

    YANG Description: The arithmetic mean value of the percentage measure of the
statistic over the time interval.
    """
    return self.__avg
      
  def _set_avg(self, v, load=False):
    """
    Setter method for avg, mapped from YANG variable /access_points/access_point/system/cpus/cpu/state/idle/avg (oc-types:percentage)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_avg is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_avg() directly.

    YANG Description: The arithmetic mean value of the percentage measure of the
statistic over the time interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={u'range': [u'0..100']}), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:percentage', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """avg must be of a type compatible with oc-types:percentage""",
          'defined-type': "oc-types:percentage",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={u'range': [u'0..100']}), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:percentage', is_config=False)""",
        })

    self.__avg = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_avg(self):
    self.__avg = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={u'range': [u'0..100']}), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:percentage', is_config=False)


  def _get_min_(self):
    """
    Getter method for min_, mapped from YANG variable /access_points/access_point/system/cpus/cpu/state/idle/min (oc-types:percentage)

    YANG Description: The minimum value of the percentage measure of the
statistic over the time interval.
    """
    return self.__min_
      
  def _set_min_(self, v, load=False):
    """
    Setter method for min_, mapped from YANG variable /access_points/access_point/system/cpus/cpu/state/idle/min (oc-types:percentage)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_min_ is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_min_() directly.

    YANG Description: The minimum value of the percentage measure of the
statistic over the time interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={u'range': [u'0..100']}), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:percentage', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """min_ must be of a type compatible with oc-types:percentage""",
          'defined-type': "oc-types:percentage",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={u'range': [u'0..100']}), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:percentage', is_config=False)""",
        })

    self.__min_ = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_min_(self):
    self.__min_ = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={u'range': [u'0..100']}), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:percentage', is_config=False)


  def _get_max_(self):
    """
    Getter method for max_, mapped from YANG variable /access_points/access_point/system/cpus/cpu/state/idle/max (oc-types:percentage)

    YANG Description: The maximum value of the percentage measure of the
statistic over the time interval.
    """
    return self.__max_
      
  def _set_max_(self, v, load=False):
    """
    Setter method for max_, mapped from YANG variable /access_points/access_point/system/cpus/cpu/state/idle/max (oc-types:percentage)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_ is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_() directly.

    YANG Description: The maximum value of the percentage measure of the
statistic over the time interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={u'range': [u'0..100']}), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:percentage', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_ must be of a type compatible with oc-types:percentage""",
          'defined-type': "oc-types:percentage",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={u'range': [u'0..100']}), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:percentage', is_config=False)""",
        })

    self.__max_ = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_(self):
    self.__max_ = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={u'range': [u'0..100']}), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:percentage', is_config=False)


  def _get_interval(self):
    """
    Getter method for interval, mapped from YANG variable /access_points/access_point/system/cpus/cpu/state/idle/interval (oc-types:stat-interval)

    YANG Description: If supported by the system, this reports the time interval
over which the min/max/average statistics are computed by
the system.
    """
    return self.__interval
      
  def _set_interval(self, v, load=False):
    """
    Setter method for interval, mapped from YANG variable /access_points/access_point/system/cpus/cpu/state/idle/interval (oc-types:stat-interval)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interval() directly.

    YANG Description: If supported by the system, this reports the time interval
over which the min/max/average statistics are computed by
the system.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:stat-interval', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interval must be of a type compatible with oc-types:stat-interval""",
          'defined-type': "oc-types:stat-interval",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:stat-interval', is_config=False)""",
        })

    self.__interval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interval(self):
    self.__interval = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:stat-interval', is_config=False)


  def _get_min_time(self):
    """
    Getter method for min_time, mapped from YANG variable /access_points/access_point/system/cpus/cpu/state/idle/min_time (oc-types:timeticks64)

    YANG Description: The absolute time at which the minimum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    return self.__min_time
      
  def _set_min_time(self, v, load=False):
    """
    Setter method for min_time, mapped from YANG variable /access_points/access_point/system/cpus/cpu/state/idle/min_time (oc-types:timeticks64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_min_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_min_time() directly.

    YANG Description: The absolute time at which the minimum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:timeticks64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """min_time must be of a type compatible with oc-types:timeticks64""",
          'defined-type': "oc-types:timeticks64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:timeticks64', is_config=False)""",
        })

    self.__min_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_min_time(self):
    self.__min_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:timeticks64', is_config=False)


  def _get_max_time(self):
    """
    Getter method for max_time, mapped from YANG variable /access_points/access_point/system/cpus/cpu/state/idle/max_time (oc-types:timeticks64)

    YANG Description: The absolute time at which the maximum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    return self.__max_time
      
  def _set_max_time(self, v, load=False):
    """
    Setter method for max_time, mapped from YANG variable /access_points/access_point/system/cpus/cpu/state/idle/max_time (oc-types:timeticks64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_time() directly.

    YANG Description: The absolute time at which the maximum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:timeticks64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_time must be of a type compatible with oc-types:timeticks64""",
          'defined-type': "oc-types:timeticks64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:timeticks64', is_config=False)""",
        })

    self.__max_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_time(self):
    self.__max_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:timeticks64', is_config=False)

  instant = __builtin__.property(_get_instant)
  avg = __builtin__.property(_get_avg)
  min_ = __builtin__.property(_get_min_)
  max_ = __builtin__.property(_get_max_)
  interval = __builtin__.property(_get_interval)
  min_time = __builtin__.property(_get_min_time)
  max_time = __builtin__.property(_get_max_time)


  _pyangbind_elements = OrderedDict([('instant', instant), ('avg', avg), ('min_', min_), ('max_', max_), ('interval', interval), ('min_time', min_time), ('max_time', max_time), ])


class yc_wait_openconfig_access_points__access_points_access_point_system_cpus_cpu_state_wait(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-access-points - based on the path /access-points/access-point/system/cpus/cpu/state/wait. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Percentage of CPU time spent waiting for I/O.
  """
  __slots__ = ('_path_helper', '_extmethods', '__instant','__avg','__min_','__max_','__interval','__min_time','__max_time',)

  _yang_name = 'wait'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__instant = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={u'range': [u'0..100']}), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:percentage', is_config=False)
    self.__max_ = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={u'range': [u'0..100']}), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:percentage', is_config=False)
    self.__interval = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:stat-interval', is_config=False)
    self.__max_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:timeticks64', is_config=False)
    self.__min_ = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={u'range': [u'0..100']}), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:percentage', is_config=False)
    self.__min_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:timeticks64', is_config=False)
    self.__avg = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={u'range': [u'0..100']}), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:percentage', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'access-points', u'access-point', u'system', u'cpus', u'cpu', u'state', u'wait']

  def _get_instant(self):
    """
    Getter method for instant, mapped from YANG variable /access_points/access_point/system/cpus/cpu/state/wait/instant (oc-types:percentage)

    YANG Description: The instantaneous percentage value.
    """
    return self.__instant
      
  def _set_instant(self, v, load=False):
    """
    Setter method for instant, mapped from YANG variable /access_points/access_point/system/cpus/cpu/state/wait/instant (oc-types:percentage)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_instant is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_instant() directly.

    YANG Description: The instantaneous percentage value.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={u'range': [u'0..100']}), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:percentage', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """instant must be of a type compatible with oc-types:percentage""",
          'defined-type': "oc-types:percentage",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={u'range': [u'0..100']}), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:percentage', is_config=False)""",
        })

    self.__instant = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_instant(self):
    self.__instant = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={u'range': [u'0..100']}), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:percentage', is_config=False)


  def _get_avg(self):
    """
    Getter method for avg, mapped from YANG variable /access_points/access_point/system/cpus/cpu/state/wait/avg (oc-types:percentage)

    YANG Description: The arithmetic mean value of the percentage measure of the
statistic over the time interval.
    """
    return self.__avg
      
  def _set_avg(self, v, load=False):
    """
    Setter method for avg, mapped from YANG variable /access_points/access_point/system/cpus/cpu/state/wait/avg (oc-types:percentage)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_avg is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_avg() directly.

    YANG Description: The arithmetic mean value of the percentage measure of the
statistic over the time interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={u'range': [u'0..100']}), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:percentage', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """avg must be of a type compatible with oc-types:percentage""",
          'defined-type': "oc-types:percentage",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={u'range': [u'0..100']}), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:percentage', is_config=False)""",
        })

    self.__avg = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_avg(self):
    self.__avg = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={u'range': [u'0..100']}), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:percentage', is_config=False)


  def _get_min_(self):
    """
    Getter method for min_, mapped from YANG variable /access_points/access_point/system/cpus/cpu/state/wait/min (oc-types:percentage)

    YANG Description: The minimum value of the percentage measure of the
statistic over the time interval.
    """
    return self.__min_
      
  def _set_min_(self, v, load=False):
    """
    Setter method for min_, mapped from YANG variable /access_points/access_point/system/cpus/cpu/state/wait/min (oc-types:percentage)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_min_ is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_min_() directly.

    YANG Description: The minimum value of the percentage measure of the
statistic over the time interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={u'range': [u'0..100']}), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:percentage', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """min_ must be of a type compatible with oc-types:percentage""",
          'defined-type': "oc-types:percentage",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={u'range': [u'0..100']}), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:percentage', is_config=False)""",
        })

    self.__min_ = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_min_(self):
    self.__min_ = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={u'range': [u'0..100']}), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:percentage', is_config=False)


  def _get_max_(self):
    """
    Getter method for max_, mapped from YANG variable /access_points/access_point/system/cpus/cpu/state/wait/max (oc-types:percentage)

    YANG Description: The maximum value of the percentage measure of the
statistic over the time interval.
    """
    return self.__max_
      
  def _set_max_(self, v, load=False):
    """
    Setter method for max_, mapped from YANG variable /access_points/access_point/system/cpus/cpu/state/wait/max (oc-types:percentage)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_ is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_() directly.

    YANG Description: The maximum value of the percentage measure of the
statistic over the time interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={u'range': [u'0..100']}), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:percentage', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_ must be of a type compatible with oc-types:percentage""",
          'defined-type': "oc-types:percentage",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={u'range': [u'0..100']}), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:percentage', is_config=False)""",
        })

    self.__max_ = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_(self):
    self.__max_ = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={u'range': [u'0..100']}), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:percentage', is_config=False)


  def _get_interval(self):
    """
    Getter method for interval, mapped from YANG variable /access_points/access_point/system/cpus/cpu/state/wait/interval (oc-types:stat-interval)

    YANG Description: If supported by the system, this reports the time interval
over which the min/max/average statistics are computed by
the system.
    """
    return self.__interval
      
  def _set_interval(self, v, load=False):
    """
    Setter method for interval, mapped from YANG variable /access_points/access_point/system/cpus/cpu/state/wait/interval (oc-types:stat-interval)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interval() directly.

    YANG Description: If supported by the system, this reports the time interval
over which the min/max/average statistics are computed by
the system.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:stat-interval', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interval must be of a type compatible with oc-types:stat-interval""",
          'defined-type': "oc-types:stat-interval",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:stat-interval', is_config=False)""",
        })

    self.__interval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interval(self):
    self.__interval = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:stat-interval', is_config=False)


  def _get_min_time(self):
    """
    Getter method for min_time, mapped from YANG variable /access_points/access_point/system/cpus/cpu/state/wait/min_time (oc-types:timeticks64)

    YANG Description: The absolute time at which the minimum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    return self.__min_time
      
  def _set_min_time(self, v, load=False):
    """
    Setter method for min_time, mapped from YANG variable /access_points/access_point/system/cpus/cpu/state/wait/min_time (oc-types:timeticks64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_min_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_min_time() directly.

    YANG Description: The absolute time at which the minimum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:timeticks64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """min_time must be of a type compatible with oc-types:timeticks64""",
          'defined-type': "oc-types:timeticks64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:timeticks64', is_config=False)""",
        })

    self.__min_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_min_time(self):
    self.__min_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:timeticks64', is_config=False)


  def _get_max_time(self):
    """
    Getter method for max_time, mapped from YANG variable /access_points/access_point/system/cpus/cpu/state/wait/max_time (oc-types:timeticks64)

    YANG Description: The absolute time at which the maximum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    return self.__max_time
      
  def _set_max_time(self, v, load=False):
    """
    Setter method for max_time, mapped from YANG variable /access_points/access_point/system/cpus/cpu/state/wait/max_time (oc-types:timeticks64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_time() directly.

    YANG Description: The absolute time at which the maximum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:timeticks64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_time must be of a type compatible with oc-types:timeticks64""",
          'defined-type': "oc-types:timeticks64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:timeticks64', is_config=False)""",
        })

    self.__max_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_time(self):
    self.__max_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:timeticks64', is_config=False)

  instant = __builtin__.property(_get_instant)
  avg = __builtin__.property(_get_avg)
  min_ = __builtin__.property(_get_min_)
  max_ = __builtin__.property(_get_max_)
  interval = __builtin__.property(_get_interval)
  min_time = __builtin__.property(_get_min_time)
  max_time = __builtin__.property(_get_max_time)


  _pyangbind_elements = OrderedDict([('instant', instant), ('avg', avg), ('min_', min_), ('max_', max_), ('interval', interval), ('min_time', min_time), ('max_time', max_time), ])


class yc_hardware_interrupt_openconfig_access_points__access_points_access_point_system_cpus_cpu_state_hardware_interrupt(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-access-points - based on the path /access-points/access-point/system/cpus/cpu/state/hardware-interrupt. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Percentage of CPU time spent servicing hardware interrupts.
  """
  __slots__ = ('_path_helper', '_extmethods', '__instant','__avg','__min_','__max_','__interval','__min_time','__max_time',)

  _yang_name = 'hardware-interrupt'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__instant = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={u'range': [u'0..100']}), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:percentage', is_config=False)
    self.__max_ = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={u'range': [u'0..100']}), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:percentage', is_config=False)
    self.__interval = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:stat-interval', is_config=False)
    self.__max_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:timeticks64', is_config=False)
    self.__min_ = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={u'range': [u'0..100']}), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:percentage', is_config=False)
    self.__min_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:timeticks64', is_config=False)
    self.__avg = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={u'range': [u'0..100']}), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:percentage', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'access-points', u'access-point', u'system', u'cpus', u'cpu', u'state', u'hardware-interrupt']

  def _get_instant(self):
    """
    Getter method for instant, mapped from YANG variable /access_points/access_point/system/cpus/cpu/state/hardware_interrupt/instant (oc-types:percentage)

    YANG Description: The instantaneous percentage value.
    """
    return self.__instant
      
  def _set_instant(self, v, load=False):
    """
    Setter method for instant, mapped from YANG variable /access_points/access_point/system/cpus/cpu/state/hardware_interrupt/instant (oc-types:percentage)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_instant is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_instant() directly.

    YANG Description: The instantaneous percentage value.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={u'range': [u'0..100']}), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:percentage', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """instant must be of a type compatible with oc-types:percentage""",
          'defined-type': "oc-types:percentage",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={u'range': [u'0..100']}), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:percentage', is_config=False)""",
        })

    self.__instant = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_instant(self):
    self.__instant = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={u'range': [u'0..100']}), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:percentage', is_config=False)


  def _get_avg(self):
    """
    Getter method for avg, mapped from YANG variable /access_points/access_point/system/cpus/cpu/state/hardware_interrupt/avg (oc-types:percentage)

    YANG Description: The arithmetic mean value of the percentage measure of the
statistic over the time interval.
    """
    return self.__avg
      
  def _set_avg(self, v, load=False):
    """
    Setter method for avg, mapped from YANG variable /access_points/access_point/system/cpus/cpu/state/hardware_interrupt/avg (oc-types:percentage)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_avg is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_avg() directly.

    YANG Description: The arithmetic mean value of the percentage measure of the
statistic over the time interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={u'range': [u'0..100']}), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:percentage', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """avg must be of a type compatible with oc-types:percentage""",
          'defined-type': "oc-types:percentage",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={u'range': [u'0..100']}), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:percentage', is_config=False)""",
        })

    self.__avg = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_avg(self):
    self.__avg = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={u'range': [u'0..100']}), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:percentage', is_config=False)


  def _get_min_(self):
    """
    Getter method for min_, mapped from YANG variable /access_points/access_point/system/cpus/cpu/state/hardware_interrupt/min (oc-types:percentage)

    YANG Description: The minimum value of the percentage measure of the
statistic over the time interval.
    """
    return self.__min_
      
  def _set_min_(self, v, load=False):
    """
    Setter method for min_, mapped from YANG variable /access_points/access_point/system/cpus/cpu/state/hardware_interrupt/min (oc-types:percentage)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_min_ is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_min_() directly.

    YANG Description: The minimum value of the percentage measure of the
statistic over the time interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={u'range': [u'0..100']}), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:percentage', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """min_ must be of a type compatible with oc-types:percentage""",
          'defined-type': "oc-types:percentage",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={u'range': [u'0..100']}), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:percentage', is_config=False)""",
        })

    self.__min_ = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_min_(self):
    self.__min_ = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={u'range': [u'0..100']}), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:percentage', is_config=False)


  def _get_max_(self):
    """
    Getter method for max_, mapped from YANG variable /access_points/access_point/system/cpus/cpu/state/hardware_interrupt/max (oc-types:percentage)

    YANG Description: The maximum value of the percentage measure of the
statistic over the time interval.
    """
    return self.__max_
      
  def _set_max_(self, v, load=False):
    """
    Setter method for max_, mapped from YANG variable /access_points/access_point/system/cpus/cpu/state/hardware_interrupt/max (oc-types:percentage)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_ is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_() directly.

    YANG Description: The maximum value of the percentage measure of the
statistic over the time interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={u'range': [u'0..100']}), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:percentage', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_ must be of a type compatible with oc-types:percentage""",
          'defined-type': "oc-types:percentage",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={u'range': [u'0..100']}), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:percentage', is_config=False)""",
        })

    self.__max_ = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_(self):
    self.__max_ = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={u'range': [u'0..100']}), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:percentage', is_config=False)


  def _get_interval(self):
    """
    Getter method for interval, mapped from YANG variable /access_points/access_point/system/cpus/cpu/state/hardware_interrupt/interval (oc-types:stat-interval)

    YANG Description: If supported by the system, this reports the time interval
over which the min/max/average statistics are computed by
the system.
    """
    return self.__interval
      
  def _set_interval(self, v, load=False):
    """
    Setter method for interval, mapped from YANG variable /access_points/access_point/system/cpus/cpu/state/hardware_interrupt/interval (oc-types:stat-interval)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interval() directly.

    YANG Description: If supported by the system, this reports the time interval
over which the min/max/average statistics are computed by
the system.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:stat-interval', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interval must be of a type compatible with oc-types:stat-interval""",
          'defined-type': "oc-types:stat-interval",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:stat-interval', is_config=False)""",
        })

    self.__interval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interval(self):
    self.__interval = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:stat-interval', is_config=False)


  def _get_min_time(self):
    """
    Getter method for min_time, mapped from YANG variable /access_points/access_point/system/cpus/cpu/state/hardware_interrupt/min_time (oc-types:timeticks64)

    YANG Description: The absolute time at which the minimum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    return self.__min_time
      
  def _set_min_time(self, v, load=False):
    """
    Setter method for min_time, mapped from YANG variable /access_points/access_point/system/cpus/cpu/state/hardware_interrupt/min_time (oc-types:timeticks64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_min_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_min_time() directly.

    YANG Description: The absolute time at which the minimum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:timeticks64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """min_time must be of a type compatible with oc-types:timeticks64""",
          'defined-type': "oc-types:timeticks64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:timeticks64', is_config=False)""",
        })

    self.__min_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_min_time(self):
    self.__min_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:timeticks64', is_config=False)


  def _get_max_time(self):
    """
    Getter method for max_time, mapped from YANG variable /access_points/access_point/system/cpus/cpu/state/hardware_interrupt/max_time (oc-types:timeticks64)

    YANG Description: The absolute time at which the maximum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    return self.__max_time
      
  def _set_max_time(self, v, load=False):
    """
    Setter method for max_time, mapped from YANG variable /access_points/access_point/system/cpus/cpu/state/hardware_interrupt/max_time (oc-types:timeticks64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_time() directly.

    YANG Description: The absolute time at which the maximum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:timeticks64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_time must be of a type compatible with oc-types:timeticks64""",
          'defined-type': "oc-types:timeticks64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:timeticks64', is_config=False)""",
        })

    self.__max_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_time(self):
    self.__max_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:timeticks64', is_config=False)

  instant = __builtin__.property(_get_instant)
  avg = __builtin__.property(_get_avg)
  min_ = __builtin__.property(_get_min_)
  max_ = __builtin__.property(_get_max_)
  interval = __builtin__.property(_get_interval)
  min_time = __builtin__.property(_get_min_time)
  max_time = __builtin__.property(_get_max_time)


  _pyangbind_elements = OrderedDict([('instant', instant), ('avg', avg), ('min_', min_), ('max_', max_), ('interval', interval), ('min_time', min_time), ('max_time', max_time), ])


class yc_software_interrupt_openconfig_access_points__access_points_access_point_system_cpus_cpu_state_software_interrupt(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-access-points - based on the path /access-points/access-point/system/cpus/cpu/state/software-interrupt. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Percentage of CPU time spent servicing software interrupts
  """
  __slots__ = ('_path_helper', '_extmethods', '__instant','__avg','__min_','__max_','__interval','__min_time','__max_time',)

  _yang_name = 'software-interrupt'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__instant = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={u'range': [u'0..100']}), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:percentage', is_config=False)
    self.__max_ = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={u'range': [u'0..100']}), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:percentage', is_config=False)
    self.__interval = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:stat-interval', is_config=False)
    self.__max_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:timeticks64', is_config=False)
    self.__min_ = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={u'range': [u'0..100']}), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:percentage', is_config=False)
    self.__min_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:timeticks64', is_config=False)
    self.__avg = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={u'range': [u'0..100']}), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:percentage', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'access-points', u'access-point', u'system', u'cpus', u'cpu', u'state', u'software-interrupt']

  def _get_instant(self):
    """
    Getter method for instant, mapped from YANG variable /access_points/access_point/system/cpus/cpu/state/software_interrupt/instant (oc-types:percentage)

    YANG Description: The instantaneous percentage value.
    """
    return self.__instant
      
  def _set_instant(self, v, load=False):
    """
    Setter method for instant, mapped from YANG variable /access_points/access_point/system/cpus/cpu/state/software_interrupt/instant (oc-types:percentage)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_instant is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_instant() directly.

    YANG Description: The instantaneous percentage value.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={u'range': [u'0..100']}), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:percentage', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """instant must be of a type compatible with oc-types:percentage""",
          'defined-type': "oc-types:percentage",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={u'range': [u'0..100']}), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:percentage', is_config=False)""",
        })

    self.__instant = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_instant(self):
    self.__instant = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={u'range': [u'0..100']}), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:percentage', is_config=False)


  def _get_avg(self):
    """
    Getter method for avg, mapped from YANG variable /access_points/access_point/system/cpus/cpu/state/software_interrupt/avg (oc-types:percentage)

    YANG Description: The arithmetic mean value of the percentage measure of the
statistic over the time interval.
    """
    return self.__avg
      
  def _set_avg(self, v, load=False):
    """
    Setter method for avg, mapped from YANG variable /access_points/access_point/system/cpus/cpu/state/software_interrupt/avg (oc-types:percentage)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_avg is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_avg() directly.

    YANG Description: The arithmetic mean value of the percentage measure of the
statistic over the time interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={u'range': [u'0..100']}), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:percentage', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """avg must be of a type compatible with oc-types:percentage""",
          'defined-type': "oc-types:percentage",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={u'range': [u'0..100']}), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:percentage', is_config=False)""",
        })

    self.__avg = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_avg(self):
    self.__avg = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={u'range': [u'0..100']}), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:percentage', is_config=False)


  def _get_min_(self):
    """
    Getter method for min_, mapped from YANG variable /access_points/access_point/system/cpus/cpu/state/software_interrupt/min (oc-types:percentage)

    YANG Description: The minimum value of the percentage measure of the
statistic over the time interval.
    """
    return self.__min_
      
  def _set_min_(self, v, load=False):
    """
    Setter method for min_, mapped from YANG variable /access_points/access_point/system/cpus/cpu/state/software_interrupt/min (oc-types:percentage)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_min_ is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_min_() directly.

    YANG Description: The minimum value of the percentage measure of the
statistic over the time interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={u'range': [u'0..100']}), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:percentage', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """min_ must be of a type compatible with oc-types:percentage""",
          'defined-type': "oc-types:percentage",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={u'range': [u'0..100']}), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:percentage', is_config=False)""",
        })

    self.__min_ = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_min_(self):
    self.__min_ = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={u'range': [u'0..100']}), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:percentage', is_config=False)


  def _get_max_(self):
    """
    Getter method for max_, mapped from YANG variable /access_points/access_point/system/cpus/cpu/state/software_interrupt/max (oc-types:percentage)

    YANG Description: The maximum value of the percentage measure of the
statistic over the time interval.
    """
    return self.__max_
      
  def _set_max_(self, v, load=False):
    """
    Setter method for max_, mapped from YANG variable /access_points/access_point/system/cpus/cpu/state/software_interrupt/max (oc-types:percentage)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_ is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_() directly.

    YANG Description: The maximum value of the percentage measure of the
statistic over the time interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={u'range': [u'0..100']}), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:percentage', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_ must be of a type compatible with oc-types:percentage""",
          'defined-type': "oc-types:percentage",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={u'range': [u'0..100']}), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:percentage', is_config=False)""",
        })

    self.__max_ = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_(self):
    self.__max_ = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={u'range': [u'0..100']}), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:percentage', is_config=False)


  def _get_interval(self):
    """
    Getter method for interval, mapped from YANG variable /access_points/access_point/system/cpus/cpu/state/software_interrupt/interval (oc-types:stat-interval)

    YANG Description: If supported by the system, this reports the time interval
over which the min/max/average statistics are computed by
the system.
    """
    return self.__interval
      
  def _set_interval(self, v, load=False):
    """
    Setter method for interval, mapped from YANG variable /access_points/access_point/system/cpus/cpu/state/software_interrupt/interval (oc-types:stat-interval)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interval() directly.

    YANG Description: If supported by the system, this reports the time interval
over which the min/max/average statistics are computed by
the system.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:stat-interval', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interval must be of a type compatible with oc-types:stat-interval""",
          'defined-type': "oc-types:stat-interval",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:stat-interval', is_config=False)""",
        })

    self.__interval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interval(self):
    self.__interval = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:stat-interval', is_config=False)


  def _get_min_time(self):
    """
    Getter method for min_time, mapped from YANG variable /access_points/access_point/system/cpus/cpu/state/software_interrupt/min_time (oc-types:timeticks64)

    YANG Description: The absolute time at which the minimum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    return self.__min_time
      
  def _set_min_time(self, v, load=False):
    """
    Setter method for min_time, mapped from YANG variable /access_points/access_point/system/cpus/cpu/state/software_interrupt/min_time (oc-types:timeticks64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_min_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_min_time() directly.

    YANG Description: The absolute time at which the minimum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:timeticks64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """min_time must be of a type compatible with oc-types:timeticks64""",
          'defined-type': "oc-types:timeticks64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:timeticks64', is_config=False)""",
        })

    self.__min_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_min_time(self):
    self.__min_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:timeticks64', is_config=False)


  def _get_max_time(self):
    """
    Getter method for max_time, mapped from YANG variable /access_points/access_point/system/cpus/cpu/state/software_interrupt/max_time (oc-types:timeticks64)

    YANG Description: The absolute time at which the maximum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    return self.__max_time
      
  def _set_max_time(self, v, load=False):
    """
    Setter method for max_time, mapped from YANG variable /access_points/access_point/system/cpus/cpu/state/software_interrupt/max_time (oc-types:timeticks64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_time() directly.

    YANG Description: The absolute time at which the maximum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:timeticks64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_time must be of a type compatible with oc-types:timeticks64""",
          'defined-type': "oc-types:timeticks64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:timeticks64', is_config=False)""",
        })

    self.__max_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_time(self):
    self.__max_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:timeticks64', is_config=False)

  instant = __builtin__.property(_get_instant)
  avg = __builtin__.property(_get_avg)
  min_ = __builtin__.property(_get_min_)
  max_ = __builtin__.property(_get_max_)
  interval = __builtin__.property(_get_interval)
  min_time = __builtin__.property(_get_min_time)
  max_time = __builtin__.property(_get_max_time)


  _pyangbind_elements = OrderedDict([('instant', instant), ('avg', avg), ('min_', min_), ('max_', max_), ('interval', interval), ('min_time', min_time), ('max_time', max_time), ])


class yc_state_openconfig_access_points__access_points_access_point_system_cpus_cpu_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-access-points - based on the path /access-points/access-point/system/cpus/cpu/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Operational state data for the system CPU(s)
  """
  __slots__ = ('_path_helper', '_extmethods', '__index','__total','__user','__kernel','__nice','__idle','__wait','__hardware_interrupt','__software_interrupt',)

  _yang_name = 'state'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__index = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'ALL': {}},),RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32),], is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='union', is_config=False)
    self.__kernel = YANGDynClass(base=yc_kernel_openconfig_access_points__access_points_access_point_system_cpus_cpu_state_kernel, is_container='container', yang_name="kernel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=False)
    self.__hardware_interrupt = YANGDynClass(base=yc_hardware_interrupt_openconfig_access_points__access_points_access_point_system_cpus_cpu_state_hardware_interrupt, is_container='container', yang_name="hardware-interrupt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=False)
    self.__wait = YANGDynClass(base=yc_wait_openconfig_access_points__access_points_access_point_system_cpus_cpu_state_wait, is_container='container', yang_name="wait", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=False)
    self.__idle = YANGDynClass(base=yc_idle_openconfig_access_points__access_points_access_point_system_cpus_cpu_state_idle, is_container='container', yang_name="idle", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=False)
    self.__user = YANGDynClass(base=yc_user_openconfig_access_points__access_points_access_point_system_cpus_cpu_state_user, is_container='container', yang_name="user", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=False)
    self.__software_interrupt = YANGDynClass(base=yc_software_interrupt_openconfig_access_points__access_points_access_point_system_cpus_cpu_state_software_interrupt, is_container='container', yang_name="software-interrupt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=False)
    self.__total = YANGDynClass(base=yc_total_openconfig_access_points__access_points_access_point_system_cpus_cpu_state_total, is_container='container', yang_name="total", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=False)
    self.__nice = YANGDynClass(base=yc_nice_openconfig_access_points__access_points_access_point_system_cpus_cpu_state_nice, is_container='container', yang_name="nice", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'access-points', u'access-point', u'system', u'cpus', u'cpu', u'state']

  def _get_index(self):
    """
    Getter method for index, mapped from YANG variable /access_points/access_point/system/cpus/cpu/state/index (union)

    YANG Description: The CPU index for each processor core on the system.  On a
single-core system, the index should be zero.  The ALL
index signifies an aggregation of the CPU utilization
statistics over all cores in the system.
    """
    return self.__index
      
  def _set_index(self, v, load=False):
    """
    Setter method for index, mapped from YANG variable /access_points/access_point/system/cpus/cpu/state/index (union)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_index is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_index() directly.

    YANG Description: The CPU index for each processor core on the system.  On a
single-core system, the index should be zero.  The ALL
index signifies an aggregation of the CPU utilization
statistics over all cores in the system.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=[RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'ALL': {}},),RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32),], is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='union', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """index must be of a type compatible with union""",
          'defined-type': "openconfig-access-points:union",
          'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'ALL': {}},),RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32),], is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='union', is_config=False)""",
        })

    self.__index = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_index(self):
    self.__index = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'ALL': {}},),RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32),], is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='union', is_config=False)


  def _get_total(self):
    """
    Getter method for total, mapped from YANG variable /access_points/access_point/system/cpus/cpu/state/total (container)

    YANG Description: Total CPU utilization.
    """
    return self.__total
      
  def _set_total(self, v, load=False):
    """
    Setter method for total, mapped from YANG variable /access_points/access_point/system/cpus/cpu/state/total (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_total is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_total() directly.

    YANG Description: Total CPU utilization.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_total_openconfig_access_points__access_points_access_point_system_cpus_cpu_state_total, is_container='container', yang_name="total", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """total must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_total_openconfig_access_points__access_points_access_point_system_cpus_cpu_state_total, is_container='container', yang_name="total", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=False)""",
        })

    self.__total = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_total(self):
    self.__total = YANGDynClass(base=yc_total_openconfig_access_points__access_points_access_point_system_cpus_cpu_state_total, is_container='container', yang_name="total", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=False)


  def _get_user(self):
    """
    Getter method for user, mapped from YANG variable /access_points/access_point/system/cpus/cpu/state/user (container)

    YANG Description: Percentage of CPU time spent running in user space.
    """
    return self.__user
      
  def _set_user(self, v, load=False):
    """
    Setter method for user, mapped from YANG variable /access_points/access_point/system/cpus/cpu/state/user (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_user is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_user() directly.

    YANG Description: Percentage of CPU time spent running in user space.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_user_openconfig_access_points__access_points_access_point_system_cpus_cpu_state_user, is_container='container', yang_name="user", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """user must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_user_openconfig_access_points__access_points_access_point_system_cpus_cpu_state_user, is_container='container', yang_name="user", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=False)""",
        })

    self.__user = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_user(self):
    self.__user = YANGDynClass(base=yc_user_openconfig_access_points__access_points_access_point_system_cpus_cpu_state_user, is_container='container', yang_name="user", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=False)


  def _get_kernel(self):
    """
    Getter method for kernel, mapped from YANG variable /access_points/access_point/system/cpus/cpu/state/kernel (container)

    YANG Description: Percentage of CPU time spent running in kernel space.
    """
    return self.__kernel
      
  def _set_kernel(self, v, load=False):
    """
    Setter method for kernel, mapped from YANG variable /access_points/access_point/system/cpus/cpu/state/kernel (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_kernel is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_kernel() directly.

    YANG Description: Percentage of CPU time spent running in kernel space.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_kernel_openconfig_access_points__access_points_access_point_system_cpus_cpu_state_kernel, is_container='container', yang_name="kernel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """kernel must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_kernel_openconfig_access_points__access_points_access_point_system_cpus_cpu_state_kernel, is_container='container', yang_name="kernel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=False)""",
        })

    self.__kernel = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_kernel(self):
    self.__kernel = YANGDynClass(base=yc_kernel_openconfig_access_points__access_points_access_point_system_cpus_cpu_state_kernel, is_container='container', yang_name="kernel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=False)


  def _get_nice(self):
    """
    Getter method for nice, mapped from YANG variable /access_points/access_point/system/cpus/cpu/state/nice (container)

    YANG Description: Percentage of CPU time spent running low-priority (niced)
user processes.
    """
    return self.__nice
      
  def _set_nice(self, v, load=False):
    """
    Setter method for nice, mapped from YANG variable /access_points/access_point/system/cpus/cpu/state/nice (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_nice is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_nice() directly.

    YANG Description: Percentage of CPU time spent running low-priority (niced)
user processes.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_nice_openconfig_access_points__access_points_access_point_system_cpus_cpu_state_nice, is_container='container', yang_name="nice", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """nice must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_nice_openconfig_access_points__access_points_access_point_system_cpus_cpu_state_nice, is_container='container', yang_name="nice", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=False)""",
        })

    self.__nice = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_nice(self):
    self.__nice = YANGDynClass(base=yc_nice_openconfig_access_points__access_points_access_point_system_cpus_cpu_state_nice, is_container='container', yang_name="nice", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=False)


  def _get_idle(self):
    """
    Getter method for idle, mapped from YANG variable /access_points/access_point/system/cpus/cpu/state/idle (container)

    YANG Description: Percentage of CPU time spent idle.
    """
    return self.__idle
      
  def _set_idle(self, v, load=False):
    """
    Setter method for idle, mapped from YANG variable /access_points/access_point/system/cpus/cpu/state/idle (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_idle is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_idle() directly.

    YANG Description: Percentage of CPU time spent idle.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_idle_openconfig_access_points__access_points_access_point_system_cpus_cpu_state_idle, is_container='container', yang_name="idle", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """idle must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_idle_openconfig_access_points__access_points_access_point_system_cpus_cpu_state_idle, is_container='container', yang_name="idle", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=False)""",
        })

    self.__idle = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_idle(self):
    self.__idle = YANGDynClass(base=yc_idle_openconfig_access_points__access_points_access_point_system_cpus_cpu_state_idle, is_container='container', yang_name="idle", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=False)


  def _get_wait(self):
    """
    Getter method for wait, mapped from YANG variable /access_points/access_point/system/cpus/cpu/state/wait (container)

    YANG Description: Percentage of CPU time spent waiting for I/O.
    """
    return self.__wait
      
  def _set_wait(self, v, load=False):
    """
    Setter method for wait, mapped from YANG variable /access_points/access_point/system/cpus/cpu/state/wait (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_wait is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_wait() directly.

    YANG Description: Percentage of CPU time spent waiting for I/O.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_wait_openconfig_access_points__access_points_access_point_system_cpus_cpu_state_wait, is_container='container', yang_name="wait", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """wait must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_wait_openconfig_access_points__access_points_access_point_system_cpus_cpu_state_wait, is_container='container', yang_name="wait", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=False)""",
        })

    self.__wait = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_wait(self):
    self.__wait = YANGDynClass(base=yc_wait_openconfig_access_points__access_points_access_point_system_cpus_cpu_state_wait, is_container='container', yang_name="wait", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=False)


  def _get_hardware_interrupt(self):
    """
    Getter method for hardware_interrupt, mapped from YANG variable /access_points/access_point/system/cpus/cpu/state/hardware_interrupt (container)

    YANG Description: Percentage of CPU time spent servicing hardware interrupts.
    """
    return self.__hardware_interrupt
      
  def _set_hardware_interrupt(self, v, load=False):
    """
    Setter method for hardware_interrupt, mapped from YANG variable /access_points/access_point/system/cpus/cpu/state/hardware_interrupt (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_hardware_interrupt is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_hardware_interrupt() directly.

    YANG Description: Percentage of CPU time spent servicing hardware interrupts.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_hardware_interrupt_openconfig_access_points__access_points_access_point_system_cpus_cpu_state_hardware_interrupt, is_container='container', yang_name="hardware-interrupt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """hardware_interrupt must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_hardware_interrupt_openconfig_access_points__access_points_access_point_system_cpus_cpu_state_hardware_interrupt, is_container='container', yang_name="hardware-interrupt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=False)""",
        })

    self.__hardware_interrupt = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_hardware_interrupt(self):
    self.__hardware_interrupt = YANGDynClass(base=yc_hardware_interrupt_openconfig_access_points__access_points_access_point_system_cpus_cpu_state_hardware_interrupt, is_container='container', yang_name="hardware-interrupt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=False)


  def _get_software_interrupt(self):
    """
    Getter method for software_interrupt, mapped from YANG variable /access_points/access_point/system/cpus/cpu/state/software_interrupt (container)

    YANG Description: Percentage of CPU time spent servicing software interrupts
    """
    return self.__software_interrupt
      
  def _set_software_interrupt(self, v, load=False):
    """
    Setter method for software_interrupt, mapped from YANG variable /access_points/access_point/system/cpus/cpu/state/software_interrupt (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_software_interrupt is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_software_interrupt() directly.

    YANG Description: Percentage of CPU time spent servicing software interrupts
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_software_interrupt_openconfig_access_points__access_points_access_point_system_cpus_cpu_state_software_interrupt, is_container='container', yang_name="software-interrupt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """software_interrupt must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_software_interrupt_openconfig_access_points__access_points_access_point_system_cpus_cpu_state_software_interrupt, is_container='container', yang_name="software-interrupt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=False)""",
        })

    self.__software_interrupt = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_software_interrupt(self):
    self.__software_interrupt = YANGDynClass(base=yc_software_interrupt_openconfig_access_points__access_points_access_point_system_cpus_cpu_state_software_interrupt, is_container='container', yang_name="software-interrupt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=False)

  index = __builtin__.property(_get_index)
  total = __builtin__.property(_get_total)
  user = __builtin__.property(_get_user)
  kernel = __builtin__.property(_get_kernel)
  nice = __builtin__.property(_get_nice)
  idle = __builtin__.property(_get_idle)
  wait = __builtin__.property(_get_wait)
  hardware_interrupt = __builtin__.property(_get_hardware_interrupt)
  software_interrupt = __builtin__.property(_get_software_interrupt)


  _pyangbind_elements = OrderedDict([('index', index), ('total', total), ('user', user), ('kernel', kernel), ('nice', nice), ('idle', idle), ('wait', wait), ('hardware_interrupt', hardware_interrupt), ('software_interrupt', software_interrupt), ])


class yc_cpu_openconfig_access_points__access_points_access_point_system_cpus_cpu(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-access-points - based on the path /access-points/access-point/system/cpus/cpu. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of CPU cores on the system (including logical CPUs
on hyperthreaded systems), keyed by either a numerical
index, or the ALL value for an entry representing the
aggregation across all CPUs.
  """
  __slots__ = ('_path_helper', '_extmethods', '__index','__state',)

  _yang_name = 'cpu'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__index = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='leafref', is_config=False)
    self.__state = YANGDynClass(base=yc_state_openconfig_access_points__access_points_access_point_system_cpus_cpu_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'access-points', u'access-point', u'system', u'cpus', u'cpu']

  def _get_index(self):
    """
    Getter method for index, mapped from YANG variable /access_points/access_point/system/cpus/cpu/index (leafref)

    YANG Description: Reference to list key
    """
    return self.__index
      
  def _set_index(self, v, load=False):
    """
    Setter method for index, mapped from YANG variable /access_points/access_point/system/cpus/cpu/index (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_index is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_index() directly.

    YANG Description: Reference to list key
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='leafref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """index must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='leafref', is_config=False)""",
        })

    self.__index = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_index(self):
    self.__index = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='leafref', is_config=False)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /access_points/access_point/system/cpus/cpu/state (container)

    YANG Description: Operational state data for the system CPU(s)
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /access_points/access_point/system/cpus/cpu/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: Operational state data for the system CPU(s)
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_access_points__access_points_access_point_system_cpus_cpu_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_access_points__access_points_access_point_system_cpus_cpu_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=False)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_access_points__access_points_access_point_system_cpus_cpu_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=False)

  index = __builtin__.property(_get_index)
  state = __builtin__.property(_get_state)


  _pyangbind_elements = OrderedDict([('index', index), ('state', state), ])


class yc_cpus_openconfig_access_points__access_points_access_point_system_cpus(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-access-points - based on the path /access-points/access-point/system/cpus. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Enclosing container for the list of CPU cores on the
system
  """
  __slots__ = ('_path_helper', '_extmethods', '__cpu',)

  _yang_name = 'cpus'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__cpu = YANGDynClass(base=YANGListType("index",yc_cpu_openconfig_access_points__access_points_access_point_system_cpus_cpu, yang_name="cpu", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='index', extensions=None), is_container='list', yang_name="cpu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='list', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'access-points', u'access-point', u'system', u'cpus']

  def _get_cpu(self):
    """
    Getter method for cpu, mapped from YANG variable /access_points/access_point/system/cpus/cpu (list)

    YANG Description: List of CPU cores on the system (including logical CPUs
on hyperthreaded systems), keyed by either a numerical
index, or the ALL value for an entry representing the
aggregation across all CPUs.
    """
    return self.__cpu
      
  def _set_cpu(self, v, load=False):
    """
    Setter method for cpu, mapped from YANG variable /access_points/access_point/system/cpus/cpu (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cpu is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cpu() directly.

    YANG Description: List of CPU cores on the system (including logical CPUs
on hyperthreaded systems), keyed by either a numerical
index, or the ALL value for an entry representing the
aggregation across all CPUs.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("index",yc_cpu_openconfig_access_points__access_points_access_point_system_cpus_cpu, yang_name="cpu", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='index', extensions=None), is_container='list', yang_name="cpu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='list', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """cpu must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("index",yc_cpu_openconfig_access_points__access_points_access_point_system_cpus_cpu, yang_name="cpu", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='index', extensions=None), is_container='list', yang_name="cpu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='list', is_config=False)""",
        })

    self.__cpu = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_cpu(self):
    self.__cpu = YANGDynClass(base=YANGListType("index",yc_cpu_openconfig_access_points__access_points_access_point_system_cpus_cpu, yang_name="cpu", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='index', extensions=None), is_container='list', yang_name="cpu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='list', is_config=False)

  cpu = __builtin__.property(_get_cpu)


  _pyangbind_elements = OrderedDict([('cpu', cpu), ])


class yc_state_openconfig_access_points__access_points_access_point_system_processes_process_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-access-points - based on the path /access-points/access-point/system/processes/process/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: State parameters related to monitored processes
  """
  __slots__ = ('_path_helper', '_extmethods', '__pid','__name','__args','__start_time','__uptime','__cpu_usage_user','__cpu_usage_system','__cpu_utilization','__memory_usage','__memory_utilization',)

  _yang_name = 'state'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__uptime = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="uptime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:timeticks64', is_config=False)
    self.__cpu_utilization = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={u'range': [u'0..100']}), is_leaf=True, yang_name="cpu-utilization", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:percentage', is_config=False)
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='string', is_config=False)
    self.__start_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="start-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint64', is_config=False)
    self.__args = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="args", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='string', is_config=False)
    self.__pid = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="pid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint64', is_config=False)
    self.__memory_utilization = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={u'range': [u'0..100']}), is_leaf=True, yang_name="memory-utilization", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:percentage', is_config=False)
    self.__cpu_usage_system = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="cpu-usage-system", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:timeticks64', is_config=False)
    self.__cpu_usage_user = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="cpu-usage-user", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:timeticks64', is_config=False)
    self.__memory_usage = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="memory-usage", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint64', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'access-points', u'access-point', u'system', u'processes', u'process', u'state']

  def _get_pid(self):
    """
    Getter method for pid, mapped from YANG variable /access_points/access_point/system/processes/process/state/pid (uint64)

    YANG Description: The process pid
    """
    return self.__pid
      
  def _set_pid(self, v, load=False):
    """
    Setter method for pid, mapped from YANG variable /access_points/access_point/system/processes/process/state/pid (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_pid is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_pid() directly.

    YANG Description: The process pid
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="pid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """pid must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="pid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint64', is_config=False)""",
        })

    self.__pid = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_pid(self):
    self.__pid = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="pid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint64', is_config=False)


  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /access_points/access_point/system/processes/process/state/name (string)

    YANG Description: The process name
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /access_points/access_point/system/processes/process/state/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: The process name
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='string', is_config=False)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='string', is_config=False)


  def _get_args(self):
    """
    Getter method for args, mapped from YANG variable /access_points/access_point/system/processes/process/state/args (string)

    YANG Description: Current process command line arguments.  Arguments with
a parameter (e.g., --option 10  or -option=10) should be
represented as a single element of the list with the
argument name and parameter together.  Flag arguments, i.e.,
those without a parameter should also be in their own list
element.
    """
    return self.__args
      
  def _set_args(self, v, load=False):
    """
    Setter method for args, mapped from YANG variable /access_points/access_point/system/processes/process/state/args (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_args is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_args() directly.

    YANG Description: Current process command line arguments.  Arguments with
a parameter (e.g., --option 10  or -option=10) should be
represented as a single element of the list with the
argument name and parameter together.  Flag arguments, i.e.,
those without a parameter should also be in their own list
element.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="args", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """args must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="args", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='string', is_config=False)""",
        })

    self.__args = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_args(self):
    self.__args = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="args", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='string', is_config=False)


  def _get_start_time(self):
    """
    Getter method for start_time, mapped from YANG variable /access_points/access_point/system/processes/process/state/start_time (uint64)

    YANG Description: The time at which this process started,
reported as nanoseconds since the UNIX epoch.  The
system must be synchronized such that the start-time
can be reported accurately, otherwise it should not be
reported.
    """
    return self.__start_time
      
  def _set_start_time(self, v, load=False):
    """
    Setter method for start_time, mapped from YANG variable /access_points/access_point/system/processes/process/state/start_time (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_start_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_start_time() directly.

    YANG Description: The time at which this process started,
reported as nanoseconds since the UNIX epoch.  The
system must be synchronized such that the start-time
can be reported accurately, otherwise it should not be
reported.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="start-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """start_time must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="start-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint64', is_config=False)""",
        })

    self.__start_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_start_time(self):
    self.__start_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="start-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint64', is_config=False)


  def _get_uptime(self):
    """
    Getter method for uptime, mapped from YANG variable /access_points/access_point/system/processes/process/state/uptime (oc-types:timeticks64)

    YANG Description: Amount of time elapsed since this process started.
    """
    return self.__uptime
      
  def _set_uptime(self, v, load=False):
    """
    Setter method for uptime, mapped from YANG variable /access_points/access_point/system/processes/process/state/uptime (oc-types:timeticks64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_uptime is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_uptime() directly.

    YANG Description: Amount of time elapsed since this process started.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="uptime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:timeticks64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """uptime must be of a type compatible with oc-types:timeticks64""",
          'defined-type': "oc-types:timeticks64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="uptime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:timeticks64', is_config=False)""",
        })

    self.__uptime = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_uptime(self):
    self.__uptime = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="uptime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:timeticks64', is_config=False)


  def _get_cpu_usage_user(self):
    """
    Getter method for cpu_usage_user, mapped from YANG variable /access_points/access_point/system/processes/process/state/cpu_usage_user (oc-types:timeticks64)

    YANG Description: CPU time consumed by this process in user mode.
    """
    return self.__cpu_usage_user
      
  def _set_cpu_usage_user(self, v, load=False):
    """
    Setter method for cpu_usage_user, mapped from YANG variable /access_points/access_point/system/processes/process/state/cpu_usage_user (oc-types:timeticks64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cpu_usage_user is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cpu_usage_user() directly.

    YANG Description: CPU time consumed by this process in user mode.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="cpu-usage-user", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:timeticks64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """cpu_usage_user must be of a type compatible with oc-types:timeticks64""",
          'defined-type': "oc-types:timeticks64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="cpu-usage-user", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:timeticks64', is_config=False)""",
        })

    self.__cpu_usage_user = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_cpu_usage_user(self):
    self.__cpu_usage_user = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="cpu-usage-user", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:timeticks64', is_config=False)


  def _get_cpu_usage_system(self):
    """
    Getter method for cpu_usage_system, mapped from YANG variable /access_points/access_point/system/processes/process/state/cpu_usage_system (oc-types:timeticks64)

    YANG Description: CPU time consumed by this process in kernel mode.
    """
    return self.__cpu_usage_system
      
  def _set_cpu_usage_system(self, v, load=False):
    """
    Setter method for cpu_usage_system, mapped from YANG variable /access_points/access_point/system/processes/process/state/cpu_usage_system (oc-types:timeticks64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cpu_usage_system is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cpu_usage_system() directly.

    YANG Description: CPU time consumed by this process in kernel mode.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="cpu-usage-system", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:timeticks64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """cpu_usage_system must be of a type compatible with oc-types:timeticks64""",
          'defined-type': "oc-types:timeticks64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="cpu-usage-system", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:timeticks64', is_config=False)""",
        })

    self.__cpu_usage_system = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_cpu_usage_system(self):
    self.__cpu_usage_system = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="cpu-usage-system", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:timeticks64', is_config=False)


  def _get_cpu_utilization(self):
    """
    Getter method for cpu_utilization, mapped from YANG variable /access_points/access_point/system/processes/process/state/cpu_utilization (oc-types:percentage)

    YANG Description: The percentage of CPU that is being used by the process.
    """
    return self.__cpu_utilization
      
  def _set_cpu_utilization(self, v, load=False):
    """
    Setter method for cpu_utilization, mapped from YANG variable /access_points/access_point/system/processes/process/state/cpu_utilization (oc-types:percentage)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cpu_utilization is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cpu_utilization() directly.

    YANG Description: The percentage of CPU that is being used by the process.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={u'range': [u'0..100']}), is_leaf=True, yang_name="cpu-utilization", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:percentage', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """cpu_utilization must be of a type compatible with oc-types:percentage""",
          'defined-type': "oc-types:percentage",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={u'range': [u'0..100']}), is_leaf=True, yang_name="cpu-utilization", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:percentage', is_config=False)""",
        })

    self.__cpu_utilization = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_cpu_utilization(self):
    self.__cpu_utilization = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={u'range': [u'0..100']}), is_leaf=True, yang_name="cpu-utilization", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:percentage', is_config=False)


  def _get_memory_usage(self):
    """
    Getter method for memory_usage, mapped from YANG variable /access_points/access_point/system/processes/process/state/memory_usage (uint64)

    YANG Description: Bytes allocated and still in use by the process
    """
    return self.__memory_usage
      
  def _set_memory_usage(self, v, load=False):
    """
    Setter method for memory_usage, mapped from YANG variable /access_points/access_point/system/processes/process/state/memory_usage (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_memory_usage is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_memory_usage() directly.

    YANG Description: Bytes allocated and still in use by the process
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="memory-usage", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """memory_usage must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="memory-usage", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint64', is_config=False)""",
        })

    self.__memory_usage = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_memory_usage(self):
    self.__memory_usage = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="memory-usage", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint64', is_config=False)


  def _get_memory_utilization(self):
    """
    Getter method for memory_utilization, mapped from YANG variable /access_points/access_point/system/processes/process/state/memory_utilization (oc-types:percentage)

    YANG Description: The percentage of RAM that is being used by the process.
    """
    return self.__memory_utilization
      
  def _set_memory_utilization(self, v, load=False):
    """
    Setter method for memory_utilization, mapped from YANG variable /access_points/access_point/system/processes/process/state/memory_utilization (oc-types:percentage)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_memory_utilization is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_memory_utilization() directly.

    YANG Description: The percentage of RAM that is being used by the process.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={u'range': [u'0..100']}), is_leaf=True, yang_name="memory-utilization", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:percentage', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """memory_utilization must be of a type compatible with oc-types:percentage""",
          'defined-type': "oc-types:percentage",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={u'range': [u'0..100']}), is_leaf=True, yang_name="memory-utilization", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:percentage', is_config=False)""",
        })

    self.__memory_utilization = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_memory_utilization(self):
    self.__memory_utilization = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={u'range': [u'0..100']}), is_leaf=True, yang_name="memory-utilization", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:percentage', is_config=False)

  pid = __builtin__.property(_get_pid)
  name = __builtin__.property(_get_name)
  args = __builtin__.property(_get_args)
  start_time = __builtin__.property(_get_start_time)
  uptime = __builtin__.property(_get_uptime)
  cpu_usage_user = __builtin__.property(_get_cpu_usage_user)
  cpu_usage_system = __builtin__.property(_get_cpu_usage_system)
  cpu_utilization = __builtin__.property(_get_cpu_utilization)
  memory_usage = __builtin__.property(_get_memory_usage)
  memory_utilization = __builtin__.property(_get_memory_utilization)


  _pyangbind_elements = OrderedDict([('pid', pid), ('name', name), ('args', args), ('start_time', start_time), ('uptime', uptime), ('cpu_usage_user', cpu_usage_user), ('cpu_usage_system', cpu_usage_system), ('cpu_utilization', cpu_utilization), ('memory_usage', memory_usage), ('memory_utilization', memory_utilization), ])


class yc_process_openconfig_access_points__access_points_access_point_system_processes_process(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-access-points - based on the path /access-points/access-point/system/processes/process. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of monitored processes
  """
  __slots__ = ('_path_helper', '_extmethods', '__pid','__state',)

  _yang_name = 'process'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__state = YANGDynClass(base=yc_state_openconfig_access_points__access_points_access_point_system_processes_process_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=False)
    self.__pid = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="pid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='leafref', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'access-points', u'access-point', u'system', u'processes', u'process']

  def _get_pid(self):
    """
    Getter method for pid, mapped from YANG variable /access_points/access_point/system/processes/process/pid (leafref)

    YANG Description: Reference to the process pid key
    """
    return self.__pid
      
  def _set_pid(self, v, load=False):
    """
    Setter method for pid, mapped from YANG variable /access_points/access_point/system/processes/process/pid (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_pid is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_pid() directly.

    YANG Description: Reference to the process pid key
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="pid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='leafref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """pid must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="pid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='leafref', is_config=False)""",
        })

    self.__pid = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_pid(self):
    self.__pid = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="pid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='leafref', is_config=False)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /access_points/access_point/system/processes/process/state (container)

    YANG Description: State parameters related to monitored processes
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /access_points/access_point/system/processes/process/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: State parameters related to monitored processes
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_access_points__access_points_access_point_system_processes_process_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_access_points__access_points_access_point_system_processes_process_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=False)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_access_points__access_points_access_point_system_processes_process_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=False)

  pid = __builtin__.property(_get_pid)
  state = __builtin__.property(_get_state)


  _pyangbind_elements = OrderedDict([('pid', pid), ('state', state), ])


class yc_processes_openconfig_access_points__access_points_access_point_system_processes(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-access-points - based on the path /access-points/access-point/system/processes. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Parameters related to all monitored processes
  """
  __slots__ = ('_path_helper', '_extmethods', '__process',)

  _yang_name = 'processes'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__process = YANGDynClass(base=YANGListType("pid",yc_process_openconfig_access_points__access_points_access_point_system_processes_process, yang_name="process", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='pid', extensions=None), is_container='list', yang_name="process", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'access-points', u'access-point', u'system', u'processes']

  def _get_process(self):
    """
    Getter method for process, mapped from YANG variable /access_points/access_point/system/processes/process (list)

    YANG Description: List of monitored processes
    """
    return self.__process
      
  def _set_process(self, v, load=False):
    """
    Setter method for process, mapped from YANG variable /access_points/access_point/system/processes/process (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_process is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_process() directly.

    YANG Description: List of monitored processes
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("pid",yc_process_openconfig_access_points__access_points_access_point_system_processes_process, yang_name="process", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='pid', extensions=None), is_container='list', yang_name="process", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """process must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("pid",yc_process_openconfig_access_points__access_points_access_point_system_processes_process, yang_name="process", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='pid', extensions=None), is_container='list', yang_name="process", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='list', is_config=True)""",
        })

    self.__process = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_process(self):
    self.__process = YANGDynClass(base=YANGListType("pid",yc_process_openconfig_access_points__access_points_access_point_system_processes_process, yang_name="process", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='pid', extensions=None), is_container='list', yang_name="process", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='list', is_config=True)

  process = __builtin__.property(_get_process, _set_process)


  _pyangbind_elements = OrderedDict([('process', process), ])


class yc_state_openconfig_access_points__access_points_access_point_system_alarms_alarm_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-access-points - based on the path /access-points/access-point/system/alarms/alarm/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Operational state data for a device alarm
  """
  __slots__ = ('_path_helper', '_extmethods', '__id','__resource','__text','__time_created','__severity','__type_id',)

  _yang_name = 'state'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__resource = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="resource", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='string', is_config=False)
    self.__severity = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'MAJOR': {u'@namespace': u'http://openconfig.net/yang/alarms/types', u'@module': u'openconfig-alarm-types'}, u'oc-alarm-types:MAJOR': {u'@namespace': u'http://openconfig.net/yang/alarms/types', u'@module': u'openconfig-alarm-types'}, u'WARNING': {u'@namespace': u'http://openconfig.net/yang/alarms/types', u'@module': u'openconfig-alarm-types'}, u'oc-alarm-types:UNKNOWN': {u'@namespace': u'http://openconfig.net/yang/alarms/types', u'@module': u'openconfig-alarm-types'}, u'UNKNOWN': {u'@namespace': u'http://openconfig.net/yang/alarms/types', u'@module': u'openconfig-alarm-types'}, u'oc-alarm-types:WARNING': {u'@namespace': u'http://openconfig.net/yang/alarms/types', u'@module': u'openconfig-alarm-types'}, u'CRITICAL': {u'@namespace': u'http://openconfig.net/yang/alarms/types', u'@module': u'openconfig-alarm-types'}, u'oc-alarm-types:CRITICAL': {u'@namespace': u'http://openconfig.net/yang/alarms/types', u'@module': u'openconfig-alarm-types'}, u'MINOR': {u'@namespace': u'http://openconfig.net/yang/alarms/types', u'@module': u'openconfig-alarm-types'}, u'oc-alarm-types:MINOR': {u'@namespace': u'http://openconfig.net/yang/alarms/types', u'@module': u'openconfig-alarm-types'}},), is_leaf=True, yang_name="severity", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='identityref', is_config=False)
    self.__type_id = YANGDynClass(base=[six.text_type,RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'oc-alarm-types:EQPT': {u'@namespace': u'http://openconfig.net/yang/alarms/types', u'@module': u'openconfig-alarm-types'}, u'AIS': {u'@namespace': u'http://openconfig.net/yang/alarms/types', u'@module': u'openconfig-alarm-types'}, u'oc-alarm-types:AIS': {u'@namespace': u'http://openconfig.net/yang/alarms/types', u'@module': u'openconfig-alarm-types'}, u'oc-alarm-types:LOS': {u'@namespace': u'http://openconfig.net/yang/alarms/types', u'@module': u'openconfig-alarm-types'}, u'LOS': {u'@namespace': u'http://openconfig.net/yang/alarms/types', u'@module': u'openconfig-alarm-types'}, u'EQPT': {u'@namespace': u'http://openconfig.net/yang/alarms/types', u'@module': u'openconfig-alarm-types'}, u'oc-alarm-types:OTS': {u'@namespace': u'http://openconfig.net/yang/alarms/types', u'@module': u'openconfig-alarm-types'}, u'OTS': {u'@namespace': u'http://openconfig.net/yang/alarms/types', u'@module': u'openconfig-alarm-types'}},),], is_leaf=True, yang_name="type-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='union', is_config=False)
    self.__text = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="text", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='string', is_config=False)
    self.__time_created = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="time-created", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:timeticks64', is_config=False)
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='string', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'access-points', u'access-point', u'system', u'alarms', u'alarm', u'state']

  def _get_id(self):
    """
    Getter method for id, mapped from YANG variable /access_points/access_point/system/alarms/alarm/state/id (string)

    YANG Description: Unique ID for the alarm -- this will not be a
configurable parameter on many implementations
    """
    return self.__id
      
  def _set_id(self, v, load=False):
    """
    Setter method for id, mapped from YANG variable /access_points/access_point/system/alarms/alarm/state/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: Unique ID for the alarm -- this will not be a
configurable parameter on many implementations
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """id must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='string', is_config=False)""",
        })

    self.__id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_id(self):
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='string', is_config=False)


  def _get_resource(self):
    """
    Getter method for resource, mapped from YANG variable /access_points/access_point/system/alarms/alarm/state/resource (string)

    YANG Description: The item that is under alarm within the device. The
resource may be a reference to an item which is
defined elsewhere in the model. For example, it
may be a platform/component, interfaces/interface,
terminal-device/logical-channels/channel, etc. In this
case the system should match the name of the referenced
item exactly. The referenced item could alternatively be
the path of the item within the model.
    """
    return self.__resource
      
  def _set_resource(self, v, load=False):
    """
    Setter method for resource, mapped from YANG variable /access_points/access_point/system/alarms/alarm/state/resource (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_resource is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_resource() directly.

    YANG Description: The item that is under alarm within the device. The
resource may be a reference to an item which is
defined elsewhere in the model. For example, it
may be a platform/component, interfaces/interface,
terminal-device/logical-channels/channel, etc. In this
case the system should match the name of the referenced
item exactly. The referenced item could alternatively be
the path of the item within the model.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="resource", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """resource must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="resource", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='string', is_config=False)""",
        })

    self.__resource = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_resource(self):
    self.__resource = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="resource", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='string', is_config=False)


  def _get_text(self):
    """
    Getter method for text, mapped from YANG variable /access_points/access_point/system/alarms/alarm/state/text (string)

    YANG Description: The string used to inform operators about the alarm. This
MUST contain enough information for an operator to be able
to understand the problem. If this string contains structure,
this format should be clearly documented for programs to be
able to parse that information
    """
    return self.__text
      
  def _set_text(self, v, load=False):
    """
    Setter method for text, mapped from YANG variable /access_points/access_point/system/alarms/alarm/state/text (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_text is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_text() directly.

    YANG Description: The string used to inform operators about the alarm. This
MUST contain enough information for an operator to be able
to understand the problem. If this string contains structure,
this format should be clearly documented for programs to be
able to parse that information
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="text", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """text must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="text", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='string', is_config=False)""",
        })

    self.__text = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_text(self):
    self.__text = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="text", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='string', is_config=False)


  def _get_time_created(self):
    """
    Getter method for time_created, mapped from YANG variable /access_points/access_point/system/alarms/alarm/state/time_created (oc-types:timeticks64)

    YANG Description: The time at which the alarm was raised by the system.
This value is expressed as nanoseconds since the Unix Epoch
    """
    return self.__time_created
      
  def _set_time_created(self, v, load=False):
    """
    Setter method for time_created, mapped from YANG variable /access_points/access_point/system/alarms/alarm/state/time_created (oc-types:timeticks64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_time_created is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_time_created() directly.

    YANG Description: The time at which the alarm was raised by the system.
This value is expressed as nanoseconds since the Unix Epoch
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="time-created", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:timeticks64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """time_created must be of a type compatible with oc-types:timeticks64""",
          'defined-type': "oc-types:timeticks64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="time-created", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:timeticks64', is_config=False)""",
        })

    self.__time_created = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_time_created(self):
    self.__time_created = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="time-created", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-types:timeticks64', is_config=False)


  def _get_severity(self):
    """
    Getter method for severity, mapped from YANG variable /access_points/access_point/system/alarms/alarm/state/severity (identityref)

    YANG Description: The severity level indicating the criticality and impact
of the alarm
    """
    return self.__severity
      
  def _set_severity(self, v, load=False):
    """
    Setter method for severity, mapped from YANG variable /access_points/access_point/system/alarms/alarm/state/severity (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_severity is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_severity() directly.

    YANG Description: The severity level indicating the criticality and impact
of the alarm
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'MAJOR': {u'@namespace': u'http://openconfig.net/yang/alarms/types', u'@module': u'openconfig-alarm-types'}, u'oc-alarm-types:MAJOR': {u'@namespace': u'http://openconfig.net/yang/alarms/types', u'@module': u'openconfig-alarm-types'}, u'WARNING': {u'@namespace': u'http://openconfig.net/yang/alarms/types', u'@module': u'openconfig-alarm-types'}, u'oc-alarm-types:UNKNOWN': {u'@namespace': u'http://openconfig.net/yang/alarms/types', u'@module': u'openconfig-alarm-types'}, u'UNKNOWN': {u'@namespace': u'http://openconfig.net/yang/alarms/types', u'@module': u'openconfig-alarm-types'}, u'oc-alarm-types:WARNING': {u'@namespace': u'http://openconfig.net/yang/alarms/types', u'@module': u'openconfig-alarm-types'}, u'CRITICAL': {u'@namespace': u'http://openconfig.net/yang/alarms/types', u'@module': u'openconfig-alarm-types'}, u'oc-alarm-types:CRITICAL': {u'@namespace': u'http://openconfig.net/yang/alarms/types', u'@module': u'openconfig-alarm-types'}, u'MINOR': {u'@namespace': u'http://openconfig.net/yang/alarms/types', u'@module': u'openconfig-alarm-types'}, u'oc-alarm-types:MINOR': {u'@namespace': u'http://openconfig.net/yang/alarms/types', u'@module': u'openconfig-alarm-types'}},), is_leaf=True, yang_name="severity", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='identityref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """severity must be of a type compatible with identityref""",
          'defined-type': "openconfig-access-points:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'MAJOR': {u'@namespace': u'http://openconfig.net/yang/alarms/types', u'@module': u'openconfig-alarm-types'}, u'oc-alarm-types:MAJOR': {u'@namespace': u'http://openconfig.net/yang/alarms/types', u'@module': u'openconfig-alarm-types'}, u'WARNING': {u'@namespace': u'http://openconfig.net/yang/alarms/types', u'@module': u'openconfig-alarm-types'}, u'oc-alarm-types:UNKNOWN': {u'@namespace': u'http://openconfig.net/yang/alarms/types', u'@module': u'openconfig-alarm-types'}, u'UNKNOWN': {u'@namespace': u'http://openconfig.net/yang/alarms/types', u'@module': u'openconfig-alarm-types'}, u'oc-alarm-types:WARNING': {u'@namespace': u'http://openconfig.net/yang/alarms/types', u'@module': u'openconfig-alarm-types'}, u'CRITICAL': {u'@namespace': u'http://openconfig.net/yang/alarms/types', u'@module': u'openconfig-alarm-types'}, u'oc-alarm-types:CRITICAL': {u'@namespace': u'http://openconfig.net/yang/alarms/types', u'@module': u'openconfig-alarm-types'}, u'MINOR': {u'@namespace': u'http://openconfig.net/yang/alarms/types', u'@module': u'openconfig-alarm-types'}, u'oc-alarm-types:MINOR': {u'@namespace': u'http://openconfig.net/yang/alarms/types', u'@module': u'openconfig-alarm-types'}},), is_leaf=True, yang_name="severity", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='identityref', is_config=False)""",
        })

    self.__severity = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_severity(self):
    self.__severity = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'MAJOR': {u'@namespace': u'http://openconfig.net/yang/alarms/types', u'@module': u'openconfig-alarm-types'}, u'oc-alarm-types:MAJOR': {u'@namespace': u'http://openconfig.net/yang/alarms/types', u'@module': u'openconfig-alarm-types'}, u'WARNING': {u'@namespace': u'http://openconfig.net/yang/alarms/types', u'@module': u'openconfig-alarm-types'}, u'oc-alarm-types:UNKNOWN': {u'@namespace': u'http://openconfig.net/yang/alarms/types', u'@module': u'openconfig-alarm-types'}, u'UNKNOWN': {u'@namespace': u'http://openconfig.net/yang/alarms/types', u'@module': u'openconfig-alarm-types'}, u'oc-alarm-types:WARNING': {u'@namespace': u'http://openconfig.net/yang/alarms/types', u'@module': u'openconfig-alarm-types'}, u'CRITICAL': {u'@namespace': u'http://openconfig.net/yang/alarms/types', u'@module': u'openconfig-alarm-types'}, u'oc-alarm-types:CRITICAL': {u'@namespace': u'http://openconfig.net/yang/alarms/types', u'@module': u'openconfig-alarm-types'}, u'MINOR': {u'@namespace': u'http://openconfig.net/yang/alarms/types', u'@module': u'openconfig-alarm-types'}, u'oc-alarm-types:MINOR': {u'@namespace': u'http://openconfig.net/yang/alarms/types', u'@module': u'openconfig-alarm-types'}},), is_leaf=True, yang_name="severity", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='identityref', is_config=False)


  def _get_type_id(self):
    """
    Getter method for type_id, mapped from YANG variable /access_points/access_point/system/alarms/alarm/state/type_id (union)

    YANG Description: The abbreviated name of the alarm, for example LOS,
EQPT, or OTS. Also referred to in different systems as
condition type, alarm identifier, or alarm mnemonic. It
is recommended to use the OPENCONFIG_ALARM_TYPE_ID
identities where possible and only use the string type
when the desired identityref is not yet defined
    """
    return self.__type_id
      
  def _set_type_id(self, v, load=False):
    """
    Setter method for type_id, mapped from YANG variable /access_points/access_point/system/alarms/alarm/state/type_id (union)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_type_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_type_id() directly.

    YANG Description: The abbreviated name of the alarm, for example LOS,
EQPT, or OTS. Also referred to in different systems as
condition type, alarm identifier, or alarm mnemonic. It
is recommended to use the OPENCONFIG_ALARM_TYPE_ID
identities where possible and only use the string type
when the desired identityref is not yet defined
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=[six.text_type,RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'oc-alarm-types:EQPT': {u'@namespace': u'http://openconfig.net/yang/alarms/types', u'@module': u'openconfig-alarm-types'}, u'AIS': {u'@namespace': u'http://openconfig.net/yang/alarms/types', u'@module': u'openconfig-alarm-types'}, u'oc-alarm-types:AIS': {u'@namespace': u'http://openconfig.net/yang/alarms/types', u'@module': u'openconfig-alarm-types'}, u'oc-alarm-types:LOS': {u'@namespace': u'http://openconfig.net/yang/alarms/types', u'@module': u'openconfig-alarm-types'}, u'LOS': {u'@namespace': u'http://openconfig.net/yang/alarms/types', u'@module': u'openconfig-alarm-types'}, u'EQPT': {u'@namespace': u'http://openconfig.net/yang/alarms/types', u'@module': u'openconfig-alarm-types'}, u'oc-alarm-types:OTS': {u'@namespace': u'http://openconfig.net/yang/alarms/types', u'@module': u'openconfig-alarm-types'}, u'OTS': {u'@namespace': u'http://openconfig.net/yang/alarms/types', u'@module': u'openconfig-alarm-types'}},),], is_leaf=True, yang_name="type-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='union', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """type_id must be of a type compatible with union""",
          'defined-type': "openconfig-access-points:union",
          'generated-type': """YANGDynClass(base=[six.text_type,RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'oc-alarm-types:EQPT': {u'@namespace': u'http://openconfig.net/yang/alarms/types', u'@module': u'openconfig-alarm-types'}, u'AIS': {u'@namespace': u'http://openconfig.net/yang/alarms/types', u'@module': u'openconfig-alarm-types'}, u'oc-alarm-types:AIS': {u'@namespace': u'http://openconfig.net/yang/alarms/types', u'@module': u'openconfig-alarm-types'}, u'oc-alarm-types:LOS': {u'@namespace': u'http://openconfig.net/yang/alarms/types', u'@module': u'openconfig-alarm-types'}, u'LOS': {u'@namespace': u'http://openconfig.net/yang/alarms/types', u'@module': u'openconfig-alarm-types'}, u'EQPT': {u'@namespace': u'http://openconfig.net/yang/alarms/types', u'@module': u'openconfig-alarm-types'}, u'oc-alarm-types:OTS': {u'@namespace': u'http://openconfig.net/yang/alarms/types', u'@module': u'openconfig-alarm-types'}, u'OTS': {u'@namespace': u'http://openconfig.net/yang/alarms/types', u'@module': u'openconfig-alarm-types'}},),], is_leaf=True, yang_name="type-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='union', is_config=False)""",
        })

    self.__type_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_type_id(self):
    self.__type_id = YANGDynClass(base=[six.text_type,RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'oc-alarm-types:EQPT': {u'@namespace': u'http://openconfig.net/yang/alarms/types', u'@module': u'openconfig-alarm-types'}, u'AIS': {u'@namespace': u'http://openconfig.net/yang/alarms/types', u'@module': u'openconfig-alarm-types'}, u'oc-alarm-types:AIS': {u'@namespace': u'http://openconfig.net/yang/alarms/types', u'@module': u'openconfig-alarm-types'}, u'oc-alarm-types:LOS': {u'@namespace': u'http://openconfig.net/yang/alarms/types', u'@module': u'openconfig-alarm-types'}, u'LOS': {u'@namespace': u'http://openconfig.net/yang/alarms/types', u'@module': u'openconfig-alarm-types'}, u'EQPT': {u'@namespace': u'http://openconfig.net/yang/alarms/types', u'@module': u'openconfig-alarm-types'}, u'oc-alarm-types:OTS': {u'@namespace': u'http://openconfig.net/yang/alarms/types', u'@module': u'openconfig-alarm-types'}, u'OTS': {u'@namespace': u'http://openconfig.net/yang/alarms/types', u'@module': u'openconfig-alarm-types'}},),], is_leaf=True, yang_name="type-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='union', is_config=False)

  id = __builtin__.property(_get_id)
  resource = __builtin__.property(_get_resource)
  text = __builtin__.property(_get_text)
  time_created = __builtin__.property(_get_time_created)
  severity = __builtin__.property(_get_severity)
  type_id = __builtin__.property(_get_type_id)


  _pyangbind_elements = OrderedDict([('id', id), ('resource', resource), ('text', text), ('time_created', time_created), ('severity', severity), ('type_id', type_id), ])


class yc_alarm_openconfig_access_points__access_points_access_point_system_alarms_alarm(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-access-points - based on the path /access-points/access-point/system/alarms/alarm. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of alarms, keyed by a unique id
  """
  __slots__ = ('_path_helper', '_extmethods', '__id','__state',)

  _yang_name = 'alarm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__state = YANGDynClass(base=yc_state_openconfig_access_points__access_points_access_point_system_alarms_alarm_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=False)
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='leafref', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'access-points', u'access-point', u'system', u'alarms', u'alarm']

  def _get_id(self):
    """
    Getter method for id, mapped from YANG variable /access_points/access_point/system/alarms/alarm/id (leafref)

    YANG Description: References the unique alarm id
    """
    return self.__id
      
  def _set_id(self, v, load=False):
    """
    Setter method for id, mapped from YANG variable /access_points/access_point/system/alarms/alarm/id (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: References the unique alarm id
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='leafref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """id must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='leafref', is_config=False)""",
        })

    self.__id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_id(self):
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='leafref', is_config=False)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /access_points/access_point/system/alarms/alarm/state (container)

    YANG Description: Operational state data for a device alarm
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /access_points/access_point/system/alarms/alarm/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: Operational state data for a device alarm
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_access_points__access_points_access_point_system_alarms_alarm_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_access_points__access_points_access_point_system_alarms_alarm_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=False)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_access_points__access_points_access_point_system_alarms_alarm_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=False)

  id = __builtin__.property(_get_id)
  state = __builtin__.property(_get_state)


  _pyangbind_elements = OrderedDict([('id', id), ('state', state), ])


class yc_alarms_openconfig_access_points__access_points_access_point_system_alarms(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-access-points - based on the path /access-points/access-point/system/alarms. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Top-level container for device alarms
  """
  __slots__ = ('_path_helper', '_extmethods', '__alarm',)

  _yang_name = 'alarms'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__alarm = YANGDynClass(base=YANGListType("id",yc_alarm_openconfig_access_points__access_points_access_point_system_alarms_alarm, yang_name="alarm", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="alarm", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='list', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'access-points', u'access-point', u'system', u'alarms']

  def _get_alarm(self):
    """
    Getter method for alarm, mapped from YANG variable /access_points/access_point/system/alarms/alarm (list)

    YANG Description: List of alarms, keyed by a unique id
    """
    return self.__alarm
      
  def _set_alarm(self, v, load=False):
    """
    Setter method for alarm, mapped from YANG variable /access_points/access_point/system/alarms/alarm (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_alarm is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_alarm() directly.

    YANG Description: List of alarms, keyed by a unique id
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("id",yc_alarm_openconfig_access_points__access_points_access_point_system_alarms_alarm, yang_name="alarm", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="alarm", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='list', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """alarm must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("id",yc_alarm_openconfig_access_points__access_points_access_point_system_alarms_alarm, yang_name="alarm", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="alarm", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='list', is_config=False)""",
        })

    self.__alarm = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_alarm(self):
    self.__alarm = YANGDynClass(base=YANGListType("id",yc_alarm_openconfig_access_points__access_points_access_point_system_alarms_alarm, yang_name="alarm", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="alarm", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='list', is_config=False)

  alarm = __builtin__.property(_get_alarm)


  _pyangbind_elements = OrderedDict([('alarm', alarm), ])


class yc_system_openconfig_access_points__access_points_access_point_system(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-access-points - based on the path /access-points/access-point/system. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Enclosing container for system-related configuration and
operational state data
  """
  __slots__ = ('_path_helper', '_extmethods', '__config','__state','__clock','__dns','__ntp','__grpc_server','__ssh_server','__telnet_server','__logging','__aaa','__memory','__cpus','__processes','__alarms',)

  _yang_name = 'system'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__memory = YANGDynClass(base=yc_memory_openconfig_access_points__access_points_access_point_system_memory, is_container='container', yang_name="memory", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)
    self.__processes = YANGDynClass(base=yc_processes_openconfig_access_points__access_points_access_point_system_processes, is_container='container', yang_name="processes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)
    self.__logging = YANGDynClass(base=yc_logging_openconfig_access_points__access_points_access_point_system_logging, is_container='container', yang_name="logging", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)
    self.__clock = YANGDynClass(base=yc_clock_openconfig_access_points__access_points_access_point_system_clock, is_container='container', yang_name="clock", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)
    self.__ntp = YANGDynClass(base=yc_ntp_openconfig_access_points__access_points_access_point_system_ntp, is_container='container', yang_name="ntp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)
    self.__telnet_server = YANGDynClass(base=yc_telnet_server_openconfig_access_points__access_points_access_point_system_telnet_server, is_container='container', yang_name="telnet-server", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)
    self.__cpus = YANGDynClass(base=yc_cpus_openconfig_access_points__access_points_access_point_system_cpus, is_container='container', yang_name="cpus", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)
    self.__state = YANGDynClass(base=yc_state_openconfig_access_points__access_points_access_point_system_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)
    self.__dns = YANGDynClass(base=yc_dns_openconfig_access_points__access_points_access_point_system_dns, is_container='container', yang_name="dns", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)
    self.__grpc_server = YANGDynClass(base=yc_grpc_server_openconfig_access_points__access_points_access_point_system_grpc_server, is_container='container', yang_name="grpc-server", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)
    self.__alarms = YANGDynClass(base=yc_alarms_openconfig_access_points__access_points_access_point_system_alarms, is_container='container', yang_name="alarms", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)
    self.__aaa = YANGDynClass(base=yc_aaa_openconfig_access_points__access_points_access_point_system_aaa, is_container='container', yang_name="aaa", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)
    self.__config = YANGDynClass(base=yc_config_openconfig_access_points__access_points_access_point_system_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)
    self.__ssh_server = YANGDynClass(base=yc_ssh_server_openconfig_access_points__access_points_access_point_system_ssh_server, is_container='container', yang_name="ssh-server", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'access-points', u'access-point', u'system']

  def _get_config(self):
    """
    Getter method for config, mapped from YANG variable /access_points/access_point/system/config (container)

    YANG Description: Global configuration data for the system
    """
    return self.__config
      
  def _set_config(self, v, load=False):
    """
    Setter method for config, mapped from YANG variable /access_points/access_point/system/config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config() directly.

    YANG Description: Global configuration data for the system
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_config_openconfig_access_points__access_points_access_point_system_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_config_openconfig_access_points__access_points_access_point_system_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)""",
        })

    self.__config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config(self):
    self.__config = YANGDynClass(base=yc_config_openconfig_access_points__access_points_access_point_system_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /access_points/access_point/system/state (container)

    YANG Description: Global operational state data for the system
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /access_points/access_point/system/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: Global operational state data for the system
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_access_points__access_points_access_point_system_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_access_points__access_points_access_point_system_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_access_points__access_points_access_point_system_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)


  def _get_clock(self):
    """
    Getter method for clock, mapped from YANG variable /access_points/access_point/system/clock (container)

    YANG Description: Top-level container for clock configuration data
    """
    return self.__clock
      
  def _set_clock(self, v, load=False):
    """
    Setter method for clock, mapped from YANG variable /access_points/access_point/system/clock (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_clock is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_clock() directly.

    YANG Description: Top-level container for clock configuration data
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_clock_openconfig_access_points__access_points_access_point_system_clock, is_container='container', yang_name="clock", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """clock must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_clock_openconfig_access_points__access_points_access_point_system_clock, is_container='container', yang_name="clock", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)""",
        })

    self.__clock = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_clock(self):
    self.__clock = YANGDynClass(base=yc_clock_openconfig_access_points__access_points_access_point_system_clock, is_container='container', yang_name="clock", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)


  def _get_dns(self):
    """
    Getter method for dns, mapped from YANG variable /access_points/access_point/system/dns (container)

    YANG Description: Enclosing container for DNS resolver data
    """
    return self.__dns
      
  def _set_dns(self, v, load=False):
    """
    Setter method for dns, mapped from YANG variable /access_points/access_point/system/dns (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dns is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dns() directly.

    YANG Description: Enclosing container for DNS resolver data
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_dns_openconfig_access_points__access_points_access_point_system_dns, is_container='container', yang_name="dns", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dns must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_dns_openconfig_access_points__access_points_access_point_system_dns, is_container='container', yang_name="dns", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)""",
        })

    self.__dns = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dns(self):
    self.__dns = YANGDynClass(base=yc_dns_openconfig_access_points__access_points_access_point_system_dns, is_container='container', yang_name="dns", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)


  def _get_ntp(self):
    """
    Getter method for ntp, mapped from YANG variable /access_points/access_point/system/ntp (container)

    YANG Description: Top-level container for NTP configuration and state
    """
    return self.__ntp
      
  def _set_ntp(self, v, load=False):
    """
    Setter method for ntp, mapped from YANG variable /access_points/access_point/system/ntp (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ntp is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ntp() directly.

    YANG Description: Top-level container for NTP configuration and state
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_ntp_openconfig_access_points__access_points_access_point_system_ntp, is_container='container', yang_name="ntp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ntp must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_ntp_openconfig_access_points__access_points_access_point_system_ntp, is_container='container', yang_name="ntp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)""",
        })

    self.__ntp = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ntp(self):
    self.__ntp = YANGDynClass(base=yc_ntp_openconfig_access_points__access_points_access_point_system_ntp, is_container='container', yang_name="ntp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)


  def _get_grpc_server(self):
    """
    Getter method for grpc_server, mapped from YANG variable /access_points/access_point/system/grpc_server (container)

    YANG Description: Top-level container for the gRPC server
    """
    return self.__grpc_server
      
  def _set_grpc_server(self, v, load=False):
    """
    Setter method for grpc_server, mapped from YANG variable /access_points/access_point/system/grpc_server (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_grpc_server is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_grpc_server() directly.

    YANG Description: Top-level container for the gRPC server
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_grpc_server_openconfig_access_points__access_points_access_point_system_grpc_server, is_container='container', yang_name="grpc-server", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """grpc_server must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_grpc_server_openconfig_access_points__access_points_access_point_system_grpc_server, is_container='container', yang_name="grpc-server", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)""",
        })

    self.__grpc_server = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_grpc_server(self):
    self.__grpc_server = YANGDynClass(base=yc_grpc_server_openconfig_access_points__access_points_access_point_system_grpc_server, is_container='container', yang_name="grpc-server", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)


  def _get_ssh_server(self):
    """
    Getter method for ssh_server, mapped from YANG variable /access_points/access_point/system/ssh_server (container)

    YANG Description: Top-level container for ssh server
    """
    return self.__ssh_server
      
  def _set_ssh_server(self, v, load=False):
    """
    Setter method for ssh_server, mapped from YANG variable /access_points/access_point/system/ssh_server (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ssh_server is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ssh_server() directly.

    YANG Description: Top-level container for ssh server
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_ssh_server_openconfig_access_points__access_points_access_point_system_ssh_server, is_container='container', yang_name="ssh-server", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ssh_server must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_ssh_server_openconfig_access_points__access_points_access_point_system_ssh_server, is_container='container', yang_name="ssh-server", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)""",
        })

    self.__ssh_server = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ssh_server(self):
    self.__ssh_server = YANGDynClass(base=yc_ssh_server_openconfig_access_points__access_points_access_point_system_ssh_server, is_container='container', yang_name="ssh-server", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)


  def _get_telnet_server(self):
    """
    Getter method for telnet_server, mapped from YANG variable /access_points/access_point/system/telnet_server (container)

    YANG Description: Top-level container for telnet terminal servers
    """
    return self.__telnet_server
      
  def _set_telnet_server(self, v, load=False):
    """
    Setter method for telnet_server, mapped from YANG variable /access_points/access_point/system/telnet_server (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_telnet_server is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_telnet_server() directly.

    YANG Description: Top-level container for telnet terminal servers
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_telnet_server_openconfig_access_points__access_points_access_point_system_telnet_server, is_container='container', yang_name="telnet-server", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """telnet_server must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_telnet_server_openconfig_access_points__access_points_access_point_system_telnet_server, is_container='container', yang_name="telnet-server", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)""",
        })

    self.__telnet_server = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_telnet_server(self):
    self.__telnet_server = YANGDynClass(base=yc_telnet_server_openconfig_access_points__access_points_access_point_system_telnet_server, is_container='container', yang_name="telnet-server", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)


  def _get_logging(self):
    """
    Getter method for logging, mapped from YANG variable /access_points/access_point/system/logging (container)

    YANG Description: Top-level container for data related to logging / syslog
    """
    return self.__logging
      
  def _set_logging(self, v, load=False):
    """
    Setter method for logging, mapped from YANG variable /access_points/access_point/system/logging (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_logging is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_logging() directly.

    YANG Description: Top-level container for data related to logging / syslog
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_logging_openconfig_access_points__access_points_access_point_system_logging, is_container='container', yang_name="logging", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """logging must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_logging_openconfig_access_points__access_points_access_point_system_logging, is_container='container', yang_name="logging", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)""",
        })

    self.__logging = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_logging(self):
    self.__logging = YANGDynClass(base=yc_logging_openconfig_access_points__access_points_access_point_system_logging, is_container='container', yang_name="logging", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)


  def _get_aaa(self):
    """
    Getter method for aaa, mapped from YANG variable /access_points/access_point/system/aaa (container)

    YANG Description: Top-level container for AAA services
    """
    return self.__aaa
      
  def _set_aaa(self, v, load=False):
    """
    Setter method for aaa, mapped from YANG variable /access_points/access_point/system/aaa (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_aaa is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_aaa() directly.

    YANG Description: Top-level container for AAA services
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_aaa_openconfig_access_points__access_points_access_point_system_aaa, is_container='container', yang_name="aaa", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """aaa must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_aaa_openconfig_access_points__access_points_access_point_system_aaa, is_container='container', yang_name="aaa", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)""",
        })

    self.__aaa = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_aaa(self):
    self.__aaa = YANGDynClass(base=yc_aaa_openconfig_access_points__access_points_access_point_system_aaa, is_container='container', yang_name="aaa", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)


  def _get_memory(self):
    """
    Getter method for memory, mapped from YANG variable /access_points/access_point/system/memory (container)

    YANG Description: Top-level container for system memory data
    """
    return self.__memory
      
  def _set_memory(self, v, load=False):
    """
    Setter method for memory, mapped from YANG variable /access_points/access_point/system/memory (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_memory is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_memory() directly.

    YANG Description: Top-level container for system memory data
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_memory_openconfig_access_points__access_points_access_point_system_memory, is_container='container', yang_name="memory", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """memory must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_memory_openconfig_access_points__access_points_access_point_system_memory, is_container='container', yang_name="memory", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)""",
        })

    self.__memory = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_memory(self):
    self.__memory = YANGDynClass(base=yc_memory_openconfig_access_points__access_points_access_point_system_memory, is_container='container', yang_name="memory", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)


  def _get_cpus(self):
    """
    Getter method for cpus, mapped from YANG variable /access_points/access_point/system/cpus (container)

    YANG Description: Enclosing container for the list of CPU cores on the
system
    """
    return self.__cpus
      
  def _set_cpus(self, v, load=False):
    """
    Setter method for cpus, mapped from YANG variable /access_points/access_point/system/cpus (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cpus is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cpus() directly.

    YANG Description: Enclosing container for the list of CPU cores on the
system
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_cpus_openconfig_access_points__access_points_access_point_system_cpus, is_container='container', yang_name="cpus", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """cpus must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_cpus_openconfig_access_points__access_points_access_point_system_cpus, is_container='container', yang_name="cpus", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)""",
        })

    self.__cpus = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_cpus(self):
    self.__cpus = YANGDynClass(base=yc_cpus_openconfig_access_points__access_points_access_point_system_cpus, is_container='container', yang_name="cpus", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)


  def _get_processes(self):
    """
    Getter method for processes, mapped from YANG variable /access_points/access_point/system/processes (container)

    YANG Description: Parameters related to all monitored processes
    """
    return self.__processes
      
  def _set_processes(self, v, load=False):
    """
    Setter method for processes, mapped from YANG variable /access_points/access_point/system/processes (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_processes is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_processes() directly.

    YANG Description: Parameters related to all monitored processes
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_processes_openconfig_access_points__access_points_access_point_system_processes, is_container='container', yang_name="processes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """processes must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_processes_openconfig_access_points__access_points_access_point_system_processes, is_container='container', yang_name="processes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)""",
        })

    self.__processes = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_processes(self):
    self.__processes = YANGDynClass(base=yc_processes_openconfig_access_points__access_points_access_point_system_processes, is_container='container', yang_name="processes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)


  def _get_alarms(self):
    """
    Getter method for alarms, mapped from YANG variable /access_points/access_point/system/alarms (container)

    YANG Description: Top-level container for device alarms
    """
    return self.__alarms
      
  def _set_alarms(self, v, load=False):
    """
    Setter method for alarms, mapped from YANG variable /access_points/access_point/system/alarms (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_alarms is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_alarms() directly.

    YANG Description: Top-level container for device alarms
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_alarms_openconfig_access_points__access_points_access_point_system_alarms, is_container='container', yang_name="alarms", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """alarms must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_alarms_openconfig_access_points__access_points_access_point_system_alarms, is_container='container', yang_name="alarms", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)""",
        })

    self.__alarms = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_alarms(self):
    self.__alarms = YANGDynClass(base=yc_alarms_openconfig_access_points__access_points_access_point_system_alarms, is_container='container', yang_name="alarms", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)

  config = __builtin__.property(_get_config, _set_config)
  state = __builtin__.property(_get_state, _set_state)
  clock = __builtin__.property(_get_clock, _set_clock)
  dns = __builtin__.property(_get_dns, _set_dns)
  ntp = __builtin__.property(_get_ntp, _set_ntp)
  grpc_server = __builtin__.property(_get_grpc_server, _set_grpc_server)
  ssh_server = __builtin__.property(_get_ssh_server, _set_ssh_server)
  telnet_server = __builtin__.property(_get_telnet_server, _set_telnet_server)
  logging = __builtin__.property(_get_logging, _set_logging)
  aaa = __builtin__.property(_get_aaa, _set_aaa)
  memory = __builtin__.property(_get_memory, _set_memory)
  cpus = __builtin__.property(_get_cpus, _set_cpus)
  processes = __builtin__.property(_get_processes, _set_processes)
  alarms = __builtin__.property(_get_alarms, _set_alarms)


  _pyangbind_elements = OrderedDict([('config', config), ('state', state), ('clock', clock), ('dns', dns), ('ntp', ntp), ('grpc_server', grpc_server), ('ssh_server', ssh_server), ('telnet_server', telnet_server), ('logging', logging), ('aaa', aaa), ('memory', memory), ('cpus', cpus), ('processes', processes), ('alarms', alarms), ])


class yc_config_openconfig_access_points__access_points_access_point_assigned_ap_managers_ap_manager_config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-access-points - based on the path /access-points/access-point/assigned-ap-managers/ap-manager/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Config. container for assigning APs to managers.
  """
  __slots__ = ('_path_helper', '_extmethods', '__id','__fqdn','__ap_manager_ipv4_address','__ap_manager_ipv6_address',)

  _yang_name = 'config'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__ap_manager_ipv4_address = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])$'}), is_leaf=True, yang_name="ap-manager-ipv4-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-inet:ipv4-address', is_config=True)
    self.__ap_manager_ipv6_address = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))$'})), is_leaf=False, yang_name="ap-manager-ipv6-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-inet:ipv6-address', is_config=True)
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='string', is_config=True)
    self.__fqdn = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'((([a-zA-Z0-9_]([a-zA-Z0-9\\-_]){0,61})?[a-zA-Z0-9]\\.)*([a-zA-Z0-9_]([a-zA-Z0-9\\-_]){0,61})?[a-zA-Z0-9]\\.?)|\\.', u'length': [u'1..253']}), is_leaf=True, yang_name="fqdn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-inet:domain-name', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'access-points', u'access-point', u'assigned-ap-managers', u'ap-manager', u'config']

  def _get_id(self):
    """
    Getter method for id, mapped from YANG variable /access_points/access_point/assigned_ap_managers/ap_manager/config/id (string)

    YANG Description: The unique reference for the AP manager described in the list entry.
    """
    return self.__id
      
  def _set_id(self, v, load=False):
    """
    Setter method for id, mapped from YANG variable /access_points/access_point/assigned_ap_managers/ap_manager/config/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: The unique reference for the AP manager described in the list entry.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """id must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='string', is_config=True)""",
        })

    self.__id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_id(self):
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='string', is_config=True)


  def _get_fqdn(self):
    """
    Getter method for fqdn, mapped from YANG variable /access_points/access_point/assigned_ap_managers/ap_manager/config/fqdn (oc-inet:domain-name)

    YANG Description: The FQDN of a manager this AP is assigned to. The list should be
ordered, according to priority. eg Primary first,
Secondary second, Tertiary third etc.
    """
    return self.__fqdn
      
  def _set_fqdn(self, v, load=False):
    """
    Setter method for fqdn, mapped from YANG variable /access_points/access_point/assigned_ap_managers/ap_manager/config/fqdn (oc-inet:domain-name)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_fqdn is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_fqdn() directly.

    YANG Description: The FQDN of a manager this AP is assigned to. The list should be
ordered, according to priority. eg Primary first,
Secondary second, Tertiary third etc.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'((([a-zA-Z0-9_]([a-zA-Z0-9\\-_]){0,61})?[a-zA-Z0-9]\\.)*([a-zA-Z0-9_]([a-zA-Z0-9\\-_]){0,61})?[a-zA-Z0-9]\\.?)|\\.', u'length': [u'1..253']}), is_leaf=True, yang_name="fqdn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-inet:domain-name', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """fqdn must be of a type compatible with oc-inet:domain-name""",
          'defined-type': "oc-inet:domain-name",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'((([a-zA-Z0-9_]([a-zA-Z0-9\\-_]){0,61})?[a-zA-Z0-9]\\.)*([a-zA-Z0-9_]([a-zA-Z0-9\\-_]){0,61})?[a-zA-Z0-9]\\.?)|\\.', u'length': [u'1..253']}), is_leaf=True, yang_name="fqdn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-inet:domain-name', is_config=True)""",
        })

    self.__fqdn = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_fqdn(self):
    self.__fqdn = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'((([a-zA-Z0-9_]([a-zA-Z0-9\\-_]){0,61})?[a-zA-Z0-9]\\.)*([a-zA-Z0-9_]([a-zA-Z0-9\\-_]){0,61})?[a-zA-Z0-9]\\.?)|\\.', u'length': [u'1..253']}), is_leaf=True, yang_name="fqdn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-inet:domain-name', is_config=True)


  def _get_ap_manager_ipv4_address(self):
    """
    Getter method for ap_manager_ipv4_address, mapped from YANG variable /access_points/access_point/assigned_ap_managers/ap_manager/config/ap_manager_ipv4_address (oc-inet:ipv4-address)

    YANG Description: IPv4 address of a manager for this AP. The list should be
ordered, according to priority. eg. Primary first, Secondary second,
Tertiary third etc.
    """
    return self.__ap_manager_ipv4_address
      
  def _set_ap_manager_ipv4_address(self, v, load=False):
    """
    Setter method for ap_manager_ipv4_address, mapped from YANG variable /access_points/access_point/assigned_ap_managers/ap_manager/config/ap_manager_ipv4_address (oc-inet:ipv4-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ap_manager_ipv4_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ap_manager_ipv4_address() directly.

    YANG Description: IPv4 address of a manager for this AP. The list should be
ordered, according to priority. eg. Primary first, Secondary second,
Tertiary third etc.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])$'}), is_leaf=True, yang_name="ap-manager-ipv4-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-inet:ipv4-address', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ap_manager_ipv4_address must be of a type compatible with oc-inet:ipv4-address""",
          'defined-type': "oc-inet:ipv4-address",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])$'}), is_leaf=True, yang_name="ap-manager-ipv4-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-inet:ipv4-address', is_config=True)""",
        })

    self.__ap_manager_ipv4_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ap_manager_ipv4_address(self):
    self.__ap_manager_ipv4_address = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])$'}), is_leaf=True, yang_name="ap-manager-ipv4-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-inet:ipv4-address', is_config=True)


  def _get_ap_manager_ipv6_address(self):
    """
    Getter method for ap_manager_ipv6_address, mapped from YANG variable /access_points/access_point/assigned_ap_managers/ap_manager/config/ap_manager_ipv6_address (oc-inet:ipv6-address)

    YANG Description: IPv6 address of a manager for this AP. The list should be
ordered, according to priority. eg. Primary first, Secondary second,
Tertiary third etc.
    """
    return self.__ap_manager_ipv6_address
      
  def _set_ap_manager_ipv6_address(self, v, load=False):
    """
    Setter method for ap_manager_ipv6_address, mapped from YANG variable /access_points/access_point/assigned_ap_managers/ap_manager/config/ap_manager_ipv6_address (oc-inet:ipv6-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ap_manager_ipv6_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ap_manager_ipv6_address() directly.

    YANG Description: IPv6 address of a manager for this AP. The list should be
ordered, according to priority. eg. Primary first, Secondary second,
Tertiary third etc.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))$'})), is_leaf=False, yang_name="ap-manager-ipv6-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-inet:ipv6-address', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ap_manager_ipv6_address must be of a type compatible with oc-inet:ipv6-address""",
          'defined-type': "oc-inet:ipv6-address",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))$'})), is_leaf=False, yang_name="ap-manager-ipv6-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-inet:ipv6-address', is_config=True)""",
        })

    self.__ap_manager_ipv6_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ap_manager_ipv6_address(self):
    self.__ap_manager_ipv6_address = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))$'})), is_leaf=False, yang_name="ap-manager-ipv6-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-inet:ipv6-address', is_config=True)

  id = __builtin__.property(_get_id, _set_id)
  fqdn = __builtin__.property(_get_fqdn, _set_fqdn)
  ap_manager_ipv4_address = __builtin__.property(_get_ap_manager_ipv4_address, _set_ap_manager_ipv4_address)
  ap_manager_ipv6_address = __builtin__.property(_get_ap_manager_ipv6_address, _set_ap_manager_ipv6_address)


  _pyangbind_elements = OrderedDict([('id', id), ('fqdn', fqdn), ('ap_manager_ipv4_address', ap_manager_ipv4_address), ('ap_manager_ipv6_address', ap_manager_ipv6_address), ])


class yc_state_openconfig_access_points__access_points_access_point_assigned_ap_managers_ap_manager_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-access-points - based on the path /access-points/access-point/assigned-ap-managers/ap-manager/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: State container for APs assigned to managers.
  """
  __slots__ = ('_path_helper', '_extmethods', '__id','__fqdn','__ap_manager_ipv4_address','__ap_manager_ipv6_address','__joined',)

  _yang_name = 'state'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__joined = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="joined", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=False)
    self.__ap_manager_ipv4_address = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])$'}), is_leaf=True, yang_name="ap-manager-ipv4-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-inet:ipv4-address', is_config=False)
    self.__ap_manager_ipv6_address = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))$'})), is_leaf=False, yang_name="ap-manager-ipv6-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-inet:ipv6-address', is_config=False)
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='string', is_config=False)
    self.__fqdn = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'((([a-zA-Z0-9_]([a-zA-Z0-9\\-_]){0,61})?[a-zA-Z0-9]\\.)*([a-zA-Z0-9_]([a-zA-Z0-9\\-_]){0,61})?[a-zA-Z0-9]\\.?)|\\.', u'length': [u'1..253']}), is_leaf=True, yang_name="fqdn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-inet:domain-name', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'access-points', u'access-point', u'assigned-ap-managers', u'ap-manager', u'state']

  def _get_id(self):
    """
    Getter method for id, mapped from YANG variable /access_points/access_point/assigned_ap_managers/ap_manager/state/id (string)

    YANG Description: The unique reference for the AP manager described in the list entry.
    """
    return self.__id
      
  def _set_id(self, v, load=False):
    """
    Setter method for id, mapped from YANG variable /access_points/access_point/assigned_ap_managers/ap_manager/state/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: The unique reference for the AP manager described in the list entry.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """id must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='string', is_config=False)""",
        })

    self.__id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_id(self):
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='string', is_config=False)


  def _get_fqdn(self):
    """
    Getter method for fqdn, mapped from YANG variable /access_points/access_point/assigned_ap_managers/ap_manager/state/fqdn (oc-inet:domain-name)

    YANG Description: The FQDN of a manager this AP is assigned to. The list should be
ordered, according to priority. eg Primary first,
Secondary second, Tertiary third etc.
    """
    return self.__fqdn
      
  def _set_fqdn(self, v, load=False):
    """
    Setter method for fqdn, mapped from YANG variable /access_points/access_point/assigned_ap_managers/ap_manager/state/fqdn (oc-inet:domain-name)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_fqdn is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_fqdn() directly.

    YANG Description: The FQDN of a manager this AP is assigned to. The list should be
ordered, according to priority. eg Primary first,
Secondary second, Tertiary third etc.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'((([a-zA-Z0-9_]([a-zA-Z0-9\\-_]){0,61})?[a-zA-Z0-9]\\.)*([a-zA-Z0-9_]([a-zA-Z0-9\\-_]){0,61})?[a-zA-Z0-9]\\.?)|\\.', u'length': [u'1..253']}), is_leaf=True, yang_name="fqdn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-inet:domain-name', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """fqdn must be of a type compatible with oc-inet:domain-name""",
          'defined-type': "oc-inet:domain-name",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'((([a-zA-Z0-9_]([a-zA-Z0-9\\-_]){0,61})?[a-zA-Z0-9]\\.)*([a-zA-Z0-9_]([a-zA-Z0-9\\-_]){0,61})?[a-zA-Z0-9]\\.?)|\\.', u'length': [u'1..253']}), is_leaf=True, yang_name="fqdn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-inet:domain-name', is_config=False)""",
        })

    self.__fqdn = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_fqdn(self):
    self.__fqdn = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'((([a-zA-Z0-9_]([a-zA-Z0-9\\-_]){0,61})?[a-zA-Z0-9]\\.)*([a-zA-Z0-9_]([a-zA-Z0-9\\-_]){0,61})?[a-zA-Z0-9]\\.?)|\\.', u'length': [u'1..253']}), is_leaf=True, yang_name="fqdn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-inet:domain-name', is_config=False)


  def _get_ap_manager_ipv4_address(self):
    """
    Getter method for ap_manager_ipv4_address, mapped from YANG variable /access_points/access_point/assigned_ap_managers/ap_manager/state/ap_manager_ipv4_address (oc-inet:ipv4-address)

    YANG Description: IPv4 address of a manager for this AP. The list should be
ordered, according to priority. eg. Primary first, Secondary second,
Tertiary third etc.
    """
    return self.__ap_manager_ipv4_address
      
  def _set_ap_manager_ipv4_address(self, v, load=False):
    """
    Setter method for ap_manager_ipv4_address, mapped from YANG variable /access_points/access_point/assigned_ap_managers/ap_manager/state/ap_manager_ipv4_address (oc-inet:ipv4-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ap_manager_ipv4_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ap_manager_ipv4_address() directly.

    YANG Description: IPv4 address of a manager for this AP. The list should be
ordered, according to priority. eg. Primary first, Secondary second,
Tertiary third etc.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])$'}), is_leaf=True, yang_name="ap-manager-ipv4-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-inet:ipv4-address', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ap_manager_ipv4_address must be of a type compatible with oc-inet:ipv4-address""",
          'defined-type': "oc-inet:ipv4-address",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])$'}), is_leaf=True, yang_name="ap-manager-ipv4-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-inet:ipv4-address', is_config=False)""",
        })

    self.__ap_manager_ipv4_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ap_manager_ipv4_address(self):
    self.__ap_manager_ipv4_address = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])$'}), is_leaf=True, yang_name="ap-manager-ipv4-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-inet:ipv4-address', is_config=False)


  def _get_ap_manager_ipv6_address(self):
    """
    Getter method for ap_manager_ipv6_address, mapped from YANG variable /access_points/access_point/assigned_ap_managers/ap_manager/state/ap_manager_ipv6_address (oc-inet:ipv6-address)

    YANG Description: IPv6 address of a manager for this AP. The list should be
ordered, according to priority. eg. Primary first, Secondary second,
Tertiary third etc.
    """
    return self.__ap_manager_ipv6_address
      
  def _set_ap_manager_ipv6_address(self, v, load=False):
    """
    Setter method for ap_manager_ipv6_address, mapped from YANG variable /access_points/access_point/assigned_ap_managers/ap_manager/state/ap_manager_ipv6_address (oc-inet:ipv6-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ap_manager_ipv6_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ap_manager_ipv6_address() directly.

    YANG Description: IPv6 address of a manager for this AP. The list should be
ordered, according to priority. eg. Primary first, Secondary second,
Tertiary third etc.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))$'})), is_leaf=False, yang_name="ap-manager-ipv6-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-inet:ipv6-address', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ap_manager_ipv6_address must be of a type compatible with oc-inet:ipv6-address""",
          'defined-type': "oc-inet:ipv6-address",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))$'})), is_leaf=False, yang_name="ap-manager-ipv6-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-inet:ipv6-address', is_config=False)""",
        })

    self.__ap_manager_ipv6_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ap_manager_ipv6_address(self):
    self.__ap_manager_ipv6_address = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))$'})), is_leaf=False, yang_name="ap-manager-ipv6-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-inet:ipv6-address', is_config=False)


  def _get_joined(self):
    """
    Getter method for joined, mapped from YANG variable /access_points/access_point/assigned_ap_managers/ap_manager/state/joined (boolean)

    YANG Description: True only if this AP is currently joined to a manager. If this AP
is configured to join manager(s), however is not currently joined
to any manager, this MUST return False.
    """
    return self.__joined
      
  def _set_joined(self, v, load=False):
    """
    Setter method for joined, mapped from YANG variable /access_points/access_point/assigned_ap_managers/ap_manager/state/joined (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_joined is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_joined() directly.

    YANG Description: True only if this AP is currently joined to a manager. If this AP
is configured to join manager(s), however is not currently joined
to any manager, this MUST return False.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="joined", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """joined must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="joined", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=False)""",
        })

    self.__joined = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_joined(self):
    self.__joined = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="joined", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='boolean', is_config=False)

  id = __builtin__.property(_get_id)
  fqdn = __builtin__.property(_get_fqdn)
  ap_manager_ipv4_address = __builtin__.property(_get_ap_manager_ipv4_address)
  ap_manager_ipv6_address = __builtin__.property(_get_ap_manager_ipv6_address)
  joined = __builtin__.property(_get_joined)


  _pyangbind_elements = OrderedDict([('id', id), ('fqdn', fqdn), ('ap_manager_ipv4_address', ap_manager_ipv4_address), ('ap_manager_ipv6_address', ap_manager_ipv6_address), ('joined', joined), ])


class yc_ap_manager_openconfig_access_points__access_points_access_point_assigned_ap_managers_ap_manager(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-access-points - based on the path /access-points/access-point/assigned-ap-managers/ap-manager. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Manager(s) this AP is assinged to, referenced by id.
  """
  __slots__ = ('_path_helper', '_extmethods', '__id','__config','__state',)

  _yang_name = 'ap-manager'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__state = YANGDynClass(base=yc_state_openconfig_access_points__access_points_access_point_assigned_ap_managers_ap_manager_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)
    self.__config = YANGDynClass(base=yc_config_openconfig_access_points__access_points_access_point_assigned_ap_managers_ap_manager_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='leafref', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'access-points', u'access-point', u'assigned-ap-managers', u'ap-manager']

  def _get_id(self):
    """
    Getter method for id, mapped from YANG variable /access_points/access_point/assigned_ap_managers/ap_manager/id (leafref)

    YANG Description: id serves as a reference point to the [1-n] manager(s) this AP
is assigned to.
    """
    return self.__id
      
  def _set_id(self, v, load=False):
    """
    Setter method for id, mapped from YANG variable /access_points/access_point/assigned_ap_managers/ap_manager/id (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: id serves as a reference point to the [1-n] manager(s) this AP
is assigned to.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """id must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='leafref', is_config=True)""",
        })

    self.__id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_id(self):
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='leafref', is_config=True)


  def _get_config(self):
    """
    Getter method for config, mapped from YANG variable /access_points/access_point/assigned_ap_managers/ap_manager/config (container)

    YANG Description: Config. container for assigning APs to managers.
    """
    return self.__config
      
  def _set_config(self, v, load=False):
    """
    Setter method for config, mapped from YANG variable /access_points/access_point/assigned_ap_managers/ap_manager/config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config() directly.

    YANG Description: Config. container for assigning APs to managers.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_config_openconfig_access_points__access_points_access_point_assigned_ap_managers_ap_manager_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_config_openconfig_access_points__access_points_access_point_assigned_ap_managers_ap_manager_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)""",
        })

    self.__config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config(self):
    self.__config = YANGDynClass(base=yc_config_openconfig_access_points__access_points_access_point_assigned_ap_managers_ap_manager_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /access_points/access_point/assigned_ap_managers/ap_manager/state (container)

    YANG Description: State container for APs assigned to managers.
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /access_points/access_point/assigned_ap_managers/ap_manager/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: State container for APs assigned to managers.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_access_points__access_points_access_point_assigned_ap_managers_ap_manager_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_access_points__access_points_access_point_assigned_ap_managers_ap_manager_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_access_points__access_points_access_point_assigned_ap_managers_ap_manager_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)

  id = __builtin__.property(_get_id, _set_id)
  config = __builtin__.property(_get_config, _set_config)
  state = __builtin__.property(_get_state, _set_state)


  _pyangbind_elements = OrderedDict([('id', id), ('config', config), ('state', state), ])


class yc_assigned_ap_managers_openconfig_access_points__access_points_access_point_assigned_ap_managers(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-access-points - based on the path /access-points/access-point/assigned-ap-managers. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Wireless manager(s) this AP is assigned to. eg. Primary
Secondary, Tertiary etc.
  """
  __slots__ = ('_path_helper', '_extmethods', '__ap_manager',)

  _yang_name = 'assigned-ap-managers'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__ap_manager = YANGDynClass(base=YANGListType("id",yc_ap_manager_openconfig_access_points__access_points_access_point_assigned_ap_managers_ap_manager, yang_name="ap-manager", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="ap-manager", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'access-points', u'access-point', u'assigned-ap-managers']

  def _get_ap_manager(self):
    """
    Getter method for ap_manager, mapped from YANG variable /access_points/access_point/assigned_ap_managers/ap_manager (list)

    YANG Description: Manager(s) this AP is assinged to, referenced by id.
    """
    return self.__ap_manager
      
  def _set_ap_manager(self, v, load=False):
    """
    Setter method for ap_manager, mapped from YANG variable /access_points/access_point/assigned_ap_managers/ap_manager (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ap_manager is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ap_manager() directly.

    YANG Description: Manager(s) this AP is assinged to, referenced by id.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("id",yc_ap_manager_openconfig_access_points__access_points_access_point_assigned_ap_managers_ap_manager, yang_name="ap-manager", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="ap-manager", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ap_manager must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("id",yc_ap_manager_openconfig_access_points__access_points_access_point_assigned_ap_managers_ap_manager, yang_name="ap-manager", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="ap-manager", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='list', is_config=True)""",
        })

    self.__ap_manager = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ap_manager(self):
    self.__ap_manager = YANGDynClass(base=YANGListType("id",yc_ap_manager_openconfig_access_points__access_points_access_point_assigned_ap_managers_ap_manager, yang_name="ap-manager", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="ap-manager", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='list', is_config=True)

  ap_manager = __builtin__.property(_get_ap_manager, _set_ap_manager)


  _pyangbind_elements = OrderedDict([('ap_manager', ap_manager), ])


class yc_access_point_openconfig_access_points__access_points_access_point(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-access-points - based on the path /access-points/access-point. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration and state data for the access point referenced in the
list entry.
  """
  __slots__ = ('_path_helper', '_extmethods', '__hostname','__radios','__ssids','__system','__assigned_ap_managers',)

  _yang_name = 'access-point'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__assigned_ap_managers = YANGDynClass(base=yc_assigned_ap_managers_openconfig_access_points__access_points_access_point_assigned_ap_managers, is_container='container', yang_name="assigned-ap-managers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)
    self.__hostname = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'((([a-zA-Z0-9_]([a-zA-Z0-9\\-_]){0,61})?[a-zA-Z0-9]\\.)*([a-zA-Z0-9_]([a-zA-Z0-9\\-_]){0,61})?[a-zA-Z0-9]\\.?)|\\.', u'length': [u'1..253']}), is_leaf=True, yang_name="hostname", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-inet:domain-name', is_config=True)
    self.__ssids = YANGDynClass(base=yc_ssids_openconfig_access_points__access_points_access_point_ssids, is_container='container', yang_name="ssids", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)
    self.__radios = YANGDynClass(base=yc_radios_openconfig_access_points__access_points_access_point_radios, is_container='container', yang_name="radios", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)
    self.__system = YANGDynClass(base=yc_system_openconfig_access_points__access_points_access_point_system, is_container='container', yang_name="system", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'access-points', u'access-point']

  def _get_hostname(self):
    """
    Getter method for hostname, mapped from YANG variable /access_points/access_point/hostname (oc-inet:domain-name)

    YANG Description: AP FQDN
    """
    return self.__hostname
      
  def _set_hostname(self, v, load=False):
    """
    Setter method for hostname, mapped from YANG variable /access_points/access_point/hostname (oc-inet:domain-name)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_hostname is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_hostname() directly.

    YANG Description: AP FQDN
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'((([a-zA-Z0-9_]([a-zA-Z0-9\\-_]){0,61})?[a-zA-Z0-9]\\.)*([a-zA-Z0-9_]([a-zA-Z0-9\\-_]){0,61})?[a-zA-Z0-9]\\.?)|\\.', u'length': [u'1..253']}), is_leaf=True, yang_name="hostname", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-inet:domain-name', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """hostname must be of a type compatible with oc-inet:domain-name""",
          'defined-type': "oc-inet:domain-name",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'((([a-zA-Z0-9_]([a-zA-Z0-9\\-_]){0,61})?[a-zA-Z0-9]\\.)*([a-zA-Z0-9_]([a-zA-Z0-9\\-_]){0,61})?[a-zA-Z0-9]\\.?)|\\.', u'length': [u'1..253']}), is_leaf=True, yang_name="hostname", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-inet:domain-name', is_config=True)""",
        })

    self.__hostname = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_hostname(self):
    self.__hostname = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'((([a-zA-Z0-9_]([a-zA-Z0-9\\-_]){0,61})?[a-zA-Z0-9]\\.)*([a-zA-Z0-9_]([a-zA-Z0-9\\-_]){0,61})?[a-zA-Z0-9]\\.?)|\\.', u'length': [u'1..253']}), is_leaf=True, yang_name="hostname", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-inet:domain-name', is_config=True)


  def _get_radios(self):
    """
    Getter method for radios, mapped from YANG variable /access_points/access_point/radios (container)

    YANG Description: Top level container for radios, including configuration
and state data.
    """
    return self.__radios
      
  def _set_radios(self, v, load=False):
    """
    Setter method for radios, mapped from YANG variable /access_points/access_point/radios (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_radios is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_radios() directly.

    YANG Description: Top level container for radios, including configuration
and state data.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_radios_openconfig_access_points__access_points_access_point_radios, is_container='container', yang_name="radios", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """radios must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_radios_openconfig_access_points__access_points_access_point_radios, is_container='container', yang_name="radios", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)""",
        })

    self.__radios = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_radios(self):
    self.__radios = YANGDynClass(base=yc_radios_openconfig_access_points__access_points_access_point_radios, is_container='container', yang_name="radios", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)


  def _get_ssids(self):
    """
    Getter method for ssids, mapped from YANG variable /access_points/access_point/ssids (container)

    YANG Description: Top level container for ssids, including configuration
and state data.
    """
    return self.__ssids
      
  def _set_ssids(self, v, load=False):
    """
    Setter method for ssids, mapped from YANG variable /access_points/access_point/ssids (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ssids is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ssids() directly.

    YANG Description: Top level container for ssids, including configuration
and state data.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_ssids_openconfig_access_points__access_points_access_point_ssids, is_container='container', yang_name="ssids", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ssids must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_ssids_openconfig_access_points__access_points_access_point_ssids, is_container='container', yang_name="ssids", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)""",
        })

    self.__ssids = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ssids(self):
    self.__ssids = YANGDynClass(base=yc_ssids_openconfig_access_points__access_points_access_point_ssids, is_container='container', yang_name="ssids", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)


  def _get_system(self):
    """
    Getter method for system, mapped from YANG variable /access_points/access_point/system (container)

    YANG Description: Enclosing container for system-related configuration and
operational state data
    """
    return self.__system
      
  def _set_system(self, v, load=False):
    """
    Setter method for system, mapped from YANG variable /access_points/access_point/system (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_system is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_system() directly.

    YANG Description: Enclosing container for system-related configuration and
operational state data
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_system_openconfig_access_points__access_points_access_point_system, is_container='container', yang_name="system", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """system must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_system_openconfig_access_points__access_points_access_point_system, is_container='container', yang_name="system", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)""",
        })

    self.__system = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_system(self):
    self.__system = YANGDynClass(base=yc_system_openconfig_access_points__access_points_access_point_system, is_container='container', yang_name="system", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)


  def _get_assigned_ap_managers(self):
    """
    Getter method for assigned_ap_managers, mapped from YANG variable /access_points/access_point/assigned_ap_managers (container)

    YANG Description: Wireless manager(s) this AP is assigned to. eg. Primary
Secondary, Tertiary etc.
    """
    return self.__assigned_ap_managers
      
  def _set_assigned_ap_managers(self, v, load=False):
    """
    Setter method for assigned_ap_managers, mapped from YANG variable /access_points/access_point/assigned_ap_managers (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_assigned_ap_managers is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_assigned_ap_managers() directly.

    YANG Description: Wireless manager(s) this AP is assigned to. eg. Primary
Secondary, Tertiary etc.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_assigned_ap_managers_openconfig_access_points__access_points_access_point_assigned_ap_managers, is_container='container', yang_name="assigned-ap-managers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """assigned_ap_managers must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_assigned_ap_managers_openconfig_access_points__access_points_access_point_assigned_ap_managers, is_container='container', yang_name="assigned-ap-managers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)""",
        })

    self.__assigned_ap_managers = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_assigned_ap_managers(self):
    self.__assigned_ap_managers = YANGDynClass(base=yc_assigned_ap_managers_openconfig_access_points__access_points_access_point_assigned_ap_managers, is_container='container', yang_name="assigned-ap-managers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)

  hostname = __builtin__.property(_get_hostname, _set_hostname)
  radios = __builtin__.property(_get_radios, _set_radios)
  ssids = __builtin__.property(_get_ssids, _set_ssids)
  system = __builtin__.property(_get_system, _set_system)
  assigned_ap_managers = __builtin__.property(_get_assigned_ap_managers, _set_assigned_ap_managers)


  _pyangbind_elements = OrderedDict([('hostname', hostname), ('radios', radios), ('ssids', ssids), ('system', system), ('assigned_ap_managers', assigned_ap_managers), ])


class yc_access_points_openconfig_access_points__access_points(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-access-points - based on the path /access-points. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Top most container for configuration and state data for Access
Points.
  """
  __slots__ = ('_path_helper', '_extmethods', '__access_point',)

  _yang_name = 'access-points'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__access_point = YANGDynClass(base=YANGListType("hostname",yc_access_point_openconfig_access_points__access_points_access_point, yang_name="access-point", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='hostname', extensions=None), is_container='list', yang_name="access-point", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'access-points']

  def _get_access_point(self):
    """
    Getter method for access_point, mapped from YANG variable /access_points/access_point (list)

    YANG Description: Configuration and state data for the access point referenced in the
list entry.
    """
    return self.__access_point
      
  def _set_access_point(self, v, load=False):
    """
    Setter method for access_point, mapped from YANG variable /access_points/access_point (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_access_point is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_access_point() directly.

    YANG Description: Configuration and state data for the access point referenced in the
list entry.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("hostname",yc_access_point_openconfig_access_points__access_points_access_point, yang_name="access-point", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='hostname', extensions=None), is_container='list', yang_name="access-point", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """access_point must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("hostname",yc_access_point_openconfig_access_points__access_points_access_point, yang_name="access-point", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='hostname', extensions=None), is_container='list', yang_name="access-point", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='list', is_config=True)""",
        })

    self.__access_point = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_access_point(self):
    self.__access_point = YANGDynClass(base=YANGListType("hostname",yc_access_point_openconfig_access_points__access_points_access_point, yang_name="access-point", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='hostname', extensions=None), is_container='list', yang_name="access-point", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='list', is_config=True)

  access_point = __builtin__.property(_get_access_point, _set_access_point)


  _pyangbind_elements = OrderedDict([('access_point', access_point), ])


class openconfig_access_points(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-access-points - based on the path /openconfig-access-points. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module defines the top level WiFi Configurations for a list of
Access Points.
  """
  __slots__ = ('_path_helper', '_extmethods', '__access_points',)

  _yang_name = 'openconfig-access-points'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__access_points = YANGDynClass(base=yc_access_points_openconfig_access_points__access_points, is_container='container', yang_name="access-points", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _get_access_points(self):
    """
    Getter method for access_points, mapped from YANG variable /access_points (container)

    YANG Description: Top most container for configuration and state data for Access
Points.
    """
    return self.__access_points
      
  def _set_access_points(self, v, load=False):
    """
    Setter method for access_points, mapped from YANG variable /access_points (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_access_points is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_access_points() directly.

    YANG Description: Top most container for configuration and state data for Access
Points.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_access_points_openconfig_access_points__access_points, is_container='container', yang_name="access-points", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """access_points must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_access_points_openconfig_access_points__access_points, is_container='container', yang_name="access-points", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)""",
        })

    self.__access_points = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_access_points(self):
    self.__access_points = YANGDynClass(base=yc_access_points_openconfig_access_points__access_points, is_container='container', yang_name="access-points", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)

  access_points = __builtin__.property(_get_access_points, _set_access_points)


  _pyangbind_elements = OrderedDict([('access_points', access_points), ])


